[
  {
    "objectID": "posts/informatique/vim tips autocorriger les erreurs.html",
    "href": "posts/informatique/vim tips autocorriger les erreurs.html",
    "title": "vim tips autocorriger les erreurs",
    "section": "",
    "text": "Cet article est une traduction\n\n\n\nCet article est une traduction des deux articles suivants\nhttps://nanotipsforvim.prose.sh/autofix-misspellings\nhttps://castel.dev/post/lecture-notes-1/\n\n\nVim possède un correcteur d’orthographe intégré, que l’on peut activer avec set spell. On peut ensuite changer la langue avec set spelllang=fr (ici pour passer en français).\nPour corriger une erreur, on peut utiliser z= sur un mot : cela affiche une liste des remplacements possibles. Pour se déplacer d’erreur en erreur, on utilise ]s (erreur suivante), et [s (erreur suivante).\nCela donne quelque chose comme ça :\n\n\n\nexemple de corrections d’orthographe avec vim\n\n\nC’est assez long, parce que pour chaque mot, il faut faire : z=1 puis appuyer sur entrée.\n\nMeilleur raccourci pour remplacer\nOn peut aussi faire 1z= : cela sélectionne directement la première correction dans la liste. Mais 1z= est plutôt long à taper.\nUne première solution est de créer un raccourci pour 1z=, comme za, par exemple.\nnnoremap za 1z=\nCela permet d’accélérer un peu :\n\n\n\nexemple de corrections d’orthographe avec vim\n\n\n\n\nRemplacer depuis le mode insertion\nLorsque l’on rédige des textes avec vim, on est plus souvent en mode insertion (à l’opposé, on est surtout en mode normal quand on édite du code).\nCela rend encore plus long le fait de corriger une faute de frappe, puisqu’il faut aller en mode normal, et revenir en mode insertion ensuite\nPour fluidifier ce mode d’édition (surtout si, comme moi, vous tapez vite mais avec peu de précision), on peut créer un raccourci qui, depuis le mode insertion, va corriger la dernière erreur, et revenir en mode insertion.\nCela donne quelque chose comme ça (le curseur est à droite, en mode insertion) :\n\nPersonnellement, j’utilise <c-q>, mais <c-l> peut être utilisé également, ou n’importe quel raccourci qui vous convient.\nLe raccourci à ajouter est :\ninoremap <c-q> <c-g>u<esc>[s1z=`]a<c-g>u\n\nles <c-g>u permettent d’annuler rapidement les remplacements\nle `] permet de remettre le curseur à la position de départ\n\n\n\n\n\n\n\nExplication détaillée du raccourci\n\n\n\n\n\n\n<c-g>u permet d’annuler le remplacement appart\n\nsinon, il sera considéré comme une partie de l’édition en cours\n\n<esc> va en mode normal\n[s va à la dernière erreur avant le curseur\n1z= remplace l’erreur par la première correction disponible\n`] revient à la dernière position du curseur (au dernier caractère modifié)\na revient en mode insertion\n<c-g>u fait à nouveau en sorte que l’annulation du remplacement soit faîte appart\n\nsinon, il sera considéré comme une partie de l’édition future"
  },
  {
    "objectID": "posts/informatique/algo avancee tableau.html",
    "href": "posts/informatique/algo avancee tableau.html",
    "title": "Structure de données : tableau",
    "section": "",
    "text": "Structure de données statique\n\nLa taille du tableau est fixe\n\nPermet de stocker une liste de données\n\n\n\n\n\n\n\nAvantages des tableaux\n\n\n\n\nL’accès aux éléments est très rapide, en \\(O(1)\\)\n\nCar on sait directement où est un élément donné dans la mémoire\n\ncar la taille des cases est fixe\n\n\nUn tableau prends peu de place en mémoire\n\n\n\n\n\n\n\n\n\nDésavantages des tableaux\n\n\n\n\nIl impossible (ou difficile) de changer la taille d’un tableau\n\nsi on veut l’augmenter, il faut créer un nouveau tableau\n\nLa supression d’éléments est en \\(O(n)\\) (longue)\n\nil faut “décaler” tous les éléments après la valeur supprimée\n\nL’insertion d’éléments est impossible\n\nil faut augmenter la taille du tableau, donc en créer un nouveau, ou bien supprimer un autre élément"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html",
    "href": "posts/informatique/algo avancee activite 3.html",
    "title": "Algorithmique avancée : activité 3",
    "section": "",
    "text": "Définition d’une liste chaînée\n\n\n\n\n\n\nclass Node:\n    def __init__(self, valeur, suivant: 'Node' =None):\n        self.valeur = valeur\n        self.suivant = suivant\n\nclass Liste:\n    def __init__(self, head: Node):\n        self.head = head\n\n    def __str__(self) -> str:\n        return \"(\" + \",\".join(map(lambda e: str(Liste(e) if isinstance(e, Node) else e),\n                                  self.to_list())) + \")\"\n\n    def to_list(self) -> list:\n        if self.head is None:\n            return []\n        return [self.head.valeur] + self.cdr().to_list()\n\n    def __len__(self) -> int:\n        \"\"\"Longueur de la liste.\n        \"\"\"\n        if self.head is None:\n            return 0\n        return 1 + len(self.head.suivant)\n\n    def append(self, valeur) -> None:\n        \"\"\"Ajouter une valeur à la fin de la liste.\n        \"\"\"\n        # cas de base :\n        # on doit s'arrêter dès que la liste est terminer\n        if self.head.suivant is None:\n            # on créé un nouveau Node\n            self.head.suivant = Node(valeur)\n        # récursion pour atteindre la fin de la liste\n        self.cdr().append(valeur)\n\n    def car(self):\n        \"\"\"Récupérer la valeur en tête de liste\n        \"\"\"\n        return self.head.value\n\n    def cdr(self) -> 'Liste':\n        \"\"\"Récupérer la liste sans son premier élément.\n        \"\"\"\n        if self.head is None:\n            return None\n        return Liste(self.head.suivant)\n\n    def last(self):\n        \"\"\"Récupérer le dernier élément de la liste.\n        \"\"\"\n        if self.head.suivant is None:\n            return self.last(Liste(self.head.suivant))\n        return self.head.valeur"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html#bégaie",
    "href": "posts/informatique/algo avancee activite 3.html#bégaie",
    "title": "Algorithmique avancée : activité 3",
    "section": "1.1 Bégaie",
    "text": "1.1 Bégaie\n\n1.1.1 Fonction itérative\n\nécrire la fonction itérative begaie qui, étant donnée une liste d’éléments, renvoie la liste où chaque élément est répété. Par exemple : begaie(1,2,3,1,4) = (1,1,2,2,3,3,1,1,4,4) et begaie(None) = None.\n\n\ndef begaie(L: Node) -> Node:\n    p = L\n    while p is not None:\n        # insérer un mode contenant la même valeur\n        tmp = Node(p.valeur, p.suivant)\n        p.suivant = tmp\n        # on passe au pointeur suivant\n        p = p.suivant.suivant\n    return L\n\nOn peut tester :\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nprint(Liste(L))\nprint(Liste(begaie(L)))\n\n(3,1,4,1,5,9)\n(3,3,1,1,4,4,1,1,5,5,9,9)\n\n\nEt on a bien :\n\nprint(begaie(None))\n\nNone\n\n\n\n\n1.1.2 Fonction récursive\n\nDonner maintenant une fonction récursive begaieRec qui effectue le même traitement que la fonction begaie précédente\n\n\ndef begaieRec(L: Node) -> Node:\n    if L is None:\n        return None\n    return Node(L.valeur, Node(L.valeur, begaieRec(L.suivant)))\n\nElle fonctionne également :\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nprint(Liste(L))\n# La fonction modifie la valeur de L, donc on pourrait\n# simplement appeler la fonction, sans modifier\n# explicitement L (sans mettre le `L = `)\nL = begaie(L)\n\n(3,1,4,1,5,9)"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html#dé-bégaie",
    "href": "posts/informatique/algo avancee activite 3.html#dé-bégaie",
    "title": "Algorithmique avancée : activité 3",
    "section": "1.2 Dé bégaie",
    "text": "1.2 Dé bégaie\n\n1.2.1 Fonction itérative\n\nÉcrire maintenant la fonction itérative debegaie qui prend en argument une liste bégayée et retourne la liste privée de ses doublons. La fonction de bégaie est telle que debegaie(begaie(L)) = L\n\n\ndef debegaie(L: Node) -> Node:\n    if L is None:\n        return None\n    p = L\n    # on est obligé \n    while p.suivant.suivant is not None:\n        p.suivant = p.suivant.suivant\n        p = p.suivant\n    # on retire le dernier élément\n    # p.suivant = None\n    return L\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nL = begaie(L)\nprint(Liste(L))\nL = debegaie(L)\nprint(Liste(L))\n\n(3,3,1,1,4,4,1,1,5,5,9,9)\n(3,1,4,1,5,9,9)\n\n\n\n\n1.2.2 Fonction récursive\n\nÉcrire enfin la fonction récursive debegaieRec qui réalise le même traitement que la fonction debegaie.\n\n\ndef debegaieRec(L: Node) -> Node:\n    # cas de base\n    if L is None:\n        return None\n    # on doit ajouter ce cas de base car on utilise\n    # L.suivant.suivant, donc L.suivant ne doit pas être None\n    if L.suivant is None:\n        return None\n    # On créée une nouvelle liste qui saute un élément\n    return Node(L.valeur, debegaieRec(L.suivant.suivant))\n\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nL = begaie(L)\nprint(Liste(L))\nL = debegaie(L)\nprint(Liste(L))\n\n(3,3,1,1,4,4,1,1,5,5,9,9)\n(3,1,4,1,5,9,9)"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html#itérative",
    "href": "posts/informatique/algo avancee activite 3.html#itérative",
    "title": "Algorithmique avancée : activité 3",
    "section": "2.1 Itérative",
    "text": "2.1 Itérative\n\nÉcrire la fonction itérative zip(l1, l2) qui permet d’obtenir le résultat désiré en suivant le formalisme des listes chaînées étudiées en cours. On supposera les listes en argument de même taille et non vides.\n\n\ndef zip_iter(L1: Node, L2: Node) -> Node:\n    p = L1\n    q = L2\n    res = None\n    last = None\n    while p is not None and q is not None:\n        if res is None:\n            res = Node(Node(p.valeur, Node(q.valeur)))\n            last = res\n        else:\n            last.suivant = Node(Node(p.valeur, Node(q.valeur)))\n            last = last.suivant\n        p = p.suivant\n        q = q.suivant\n    return res\n\nL1 = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9, Node(2)))))))\nL2 = Node(1, Node(6, Node(1, Node(8, Node(0, Node(3, Node(3)))))))\nprint(Liste(zip_iter(L1, L2)))\nprint(Liste(L1), Liste(L2))\n\n((3,1),(1,6),(4,1),(1,8),(5,0),(9,3),(2,3))\n(3,1,4,1,5,9,2) (1,6,1,8,0,3,3)"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html#récursive",
    "href": "posts/informatique/algo avancee activite 3.html#récursive",
    "title": "Algorithmique avancée : activité 3",
    "section": "2.2 Récursive",
    "text": "2.2 Récursive\n\nProduire une solution récursive équivalente.\n\n\ndef zip_rec(L1: Node, L2: Node) -> Node:\n    if L1 is None or L2 is None:\n        return None\n    return Node(Node(L1.valeur, Node(L2.valeur)),\n                zip_rec(L1.suivant, L2.suivant))\n\n\nL1 = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9, Node(2)))))))\nL2 = Node(1, Node(6, Node(1, Node(8, Node(0, Node(3, Node(3)))))))\nL3 = Node(1, Node(2, Node(3)))\nprint(Liste(zip_rec(L1, L2)))\nprint(Liste(zip_rec(L1, L3)))\n\n((3,1),(1,6),(4,1),(1,8),(5,0),(9,3),(2,3))\n((3,1),(1,2),(4,3))"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html#itérative-1",
    "href": "posts/informatique/algo avancee activite 3.html#itérative-1",
    "title": "Algorithmique avancée : activité 3",
    "section": "3.1 Itérative",
    "text": "3.1 Itérative\n\nÉcrire la fonction itérative croissante(L) qui prend en argument une telle liste et retourne True si et seulement si la liste est triée par ordre croissant au sens large.\n\nOn implémentera la fonction en considérant les cas de base suivants : - une liste vide est considérée comme triée par ordre croissant - une liste avec un seul élément est croissante également\n\ndef croissante_iter(L: Node) -> bool:\n    if L is None: return True\n    p = L\n    while p.suivant is not None:\n        # si deux éléments sont dans un ordre décroissant\n        if p.valeur > p.suivant.valeur:\n            # on sait que la liste n'est pas croissante\n            return False\n        p = p.suivant\n    # si on a trouvé aucune valeur décroissante dans la liste, on sait qu'elle\n    # est croissante\n    return True\n\nL = Node(1, Node(6, Node(6, Node(42, Node(73)))))\nprint(croissante_iter(L))  # True\nL = Node(1, Node(6, Node(0, Node(42))))\nprint(croissante_iter(L))  # False\n\nTrue\nFalse"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html#récursive-1",
    "href": "posts/informatique/algo avancee activite 3.html#récursive-1",
    "title": "Algorithmique avancée : activité 3",
    "section": "3.2 Récursive",
    "text": "3.2 Récursive\n\nProposer une solution récursive.\n\n\ndef croissante_rec(L: Node) -> bool:\n    if L is None: return True\n    if L.suivant is None: return True\n    # si les valeurs en tête sont décroissantes\n    if L.valeur > L.suivant.valeur:\n        return False\n    return croissante_rec(L.suivant)\n\nL = Node(1, Node(6, Node(6, Node(42, Node(73)))))\nprint(croissante_iter(L))  # True\nL = Node(1, Node(6, Node(0, Node(42))))\nprint(croissante_iter(L))  # False\n\nTrue\nFalse"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html#itérative-2",
    "href": "posts/informatique/algo avancee activite 3.html#itérative-2",
    "title": "Algorithmique avancée : activité 3",
    "section": "4.1 Itérative",
    "text": "4.1 Itérative\n\nÉcrire une fonction itérative removeAll(L, elem) qui prend en argument une liste chaînée L et une valeur elem et retourne la liste privée de ses éléments elem.\n\n\ndef remove_all_iter(L: Node, elem) -> Node:\n    if L is None: return None\n    # on cherche la première valeur\n    while L.valeur == elem:\n        L = L.suivant\n        # si on a passé toutes les valeurs, c'est que la liste ne contient que\n        # des valeurs à supprimer :\n        if L is None: return None\n    res = Node(L.valeur)\n    res_tl = res\n    while L is not None:\n        if L.valeur != elem:\n            res_tl.suivant = Node(L.valeur)\n            res_tl = res_tl.suivant\n        L = L.suivant\n    return res\n\nprint(\"Liste vide :\", remove_all_iter(None, 9))\n\nL = Node(42, Node(42, Node(42, Node(42, Node(42, Node(42, Node(42)))))))\nprint(\"Liste à supprimer complètement :\",\n      Liste(remove_all_iter(L, 42)))\n\nL = Node(73, Node(73, Node(73, Node(42, Node(42)))))\nprint(\"Liste qui commmence par les éléments à supprimer :\",\n      Liste(remove_all_iter(L, 73)))\n\nL = Node(1, Node(1, Node(1, Node(8, Node(1, Node(3, Node(3)))))))\nprint(\"Liste mixte :\",\n      Liste(remove_all_iter(L, 1)))\n\nListe vide : None\nListe à supprimer complètement : ()\nListe qui commmence par les éléments à supprimer : (42,42,42)\nListe mixte : (8,8,3,3)"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html#récursive-2",
    "href": "posts/informatique/algo avancee activite 3.html#récursive-2",
    "title": "Algorithmique avancée : activité 3",
    "section": "4.2 Récursive",
    "text": "4.2 Récursive\n\nProposer une solution récursive à ce problème. Indications : pensez à différencier les cas suivants :\n\n\nla liste est vide initialement,\nla liste ne contient que l’élément à supprimer,\nla liste commence par les éléments à supprimer,\nla liste est mixte : composée pour une part de l’élément à supprimer et pour une autre part d’autres éléments à conserver.\n\n\ndef remove_all(L: Node, elem) -> Node:\n    if L is None: return None\n    if L.valeur == elem:\n        return remove_all(L.suivant, elem)\n    return Node(L.valeur, remove_all(L.suivant, elem))\n\nprint(\"Liste vide :\", remove_all_iter(None, 9))\n\nL = Node(42, Node(42, Node(42, Node(42, Node(42, Node(42, Node(42)))))))\nprint(\"Liste à supprimer complètement :\",\n      Liste(remove_all_iter(L, 42)))\n\nL = Node(73, Node(73, Node(73, Node(42, Node(42)))))\nprint(\"Liste qui commmence par les éléments à supprimer :\",\n      Liste(remove_all_iter(L, 73)))\n\nL = Node(1, Node(1, Node(1, Node(8, Node(1, Node(3, Node(3)))))))\nprint(\"Liste mixte :\",\n      Liste(remove_all_iter(L, 1)))\n\nListe vide : None\nListe à supprimer complètement : ()\nListe qui commmence par les éléments à supprimer : (42,42,42)\nListe mixte : (8,8,3,3)"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html#itérative-3",
    "href": "posts/informatique/algo avancee activite 3.html#itérative-3",
    "title": "Algorithmique avancée : activité 3",
    "section": "5.1 Itérative",
    "text": "5.1 Itérative\n\nÉcrire la définition de la fonction itérative fibonacci(n) qui, étant donné un entier naturel n renvoie la liste \\((f_n, f_{n−1}, f_{n−2}, \\ldots, f_1, f_0)\\) où les fi sont les termes de la suite de Fibonacci.\n\nPar exemple :\nfibonacci(0) = (1)\nfibonacci(1) = (1, 1)\nfibonacci(4) = (1, 1, 2, 3, 5)\nfibonacci(5) = (1, 1, 2, 3, 5, 8)\n\ndef fibonacci(n: int) -> Node:\n    if n == 0:\n        return Node(1)\n    res = Node(1, Node(1))\n    # on a déjà fait la 1ère étape en définissant res, donc on peut diminuer n\n    n -= 1\n    # _ est un nom de variable que l'on utilise quand on sait que l'on ne va\n    # pas utiliser cette variable.\n    for _ in range(n):\n        # somme de la dernière et l'avant dernière valeur\n        res = Node(res.valeur + res.suivant.valeur, res)\n    return res\n\nfor n in range(10):\n    print(f\"fibonacci({n}) = {Liste(fibonacci(n))}\")\n\nfibonacci(0) = (1)\nfibonacci(1) = (1,1)\nfibonacci(2) = (2,1,1)\nfibonacci(3) = (3,2,1,1)\nfibonacci(4) = (5,3,2,1,1)\nfibonacci(5) = (8,5,3,2,1,1)\nfibonacci(6) = (13,8,5,3,2,1,1)\nfibonacci(7) = (21,13,8,5,3,2,1,1)\nfibonacci(8) = (34,21,13,8,5,3,2,1,1)\nfibonacci(9) = (55,34,21,13,8,5,3,2,1,1)\n\n\n\n\n\n\n\n\nLes f-string en python\n\n\n\n\n\nLes “f-strings” sont des chaînes de caractères (strings) devant lesquelles on met un f.\nCela permet de mettre du code à l’intérieur, qui sera évalué et intégré dans la chaîne.\nPar exemple :\n\nfor i in range(5):\n    print(f\"{i*10}km à pied, ça use les souliers.\")\n\n0km à pied, ça use les souliers.\n10km à pied, ça use les souliers.\n20km à pied, ça use les souliers.\n30km à pied, ça use les souliers.\n40km à pied, ça use les souliers.\n\n\nIci, on voit que c’est l’expression entourée par des accolades {...} qui est évaluée. Elle est bien intégrée dans le reste de la chaîne de caractères.\nBien sûr, il est possible de mettre plusieurs expressions dans une même f-string :\n\nfor i in range(5):\n    print(f\"{i} au carré donne {i**2}\")\n\n0 au carré donne 0\n1 au carré donne 1\n2 au carré donne 4\n3 au carré donne 9\n4 au carré donne 16\n\n\nEt on peut même imaginer ce genre d’exemples :\n\nfor i in range(5):\n    print(f\"{i} est un nombre {'impair' if i%2 else 'pair'} et {'non'*(0 != i%3)} divisible par 3.\")\n\n0 est un nombre pair et  divisible par 3.\n1 est un nombre impair et non divisible par 3.\n2 est un nombre pair et non divisible par 3.\n3 est un nombre impair et  divisible par 3.\n4 est un nombre pair et non divisible par 3.\n\n\nLes f-strings sont plus rapides et plus lisibles que d’autres techniques pour créer des listes contenant des résultats. Il vaut donc mieux utiliser des f-string plutôt que faire des concaténations de listes avec +."
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html#récursive-3",
    "href": "posts/informatique/algo avancee activite 3.html#récursive-3",
    "title": "Algorithmique avancée : activité 3",
    "section": "5.2 Récursive",
    "text": "5.2 Récursive\n\nProduire une version récursive de cette fonction\n\n\ndef fibonacci_rec(n: int) -> Node:\n    if n == 0:\n        return Node(1)\n    if n == 1:\n        return Node(1, Node(1))\n    recursion = fibonacci_rec(n - 1)\n    return Node(recursion.valeur + recursion.suivant.valeur,\n                recursion)\n\nfor n in range(10):\n    print(f\"fibonacci({n}) = {Liste(fibonacci(n))}\")\n\nfibonacci(0) = (1)\nfibonacci(1) = (1,1)\nfibonacci(2) = (2,1,1)\nfibonacci(3) = (3,2,1,1)\nfibonacci(4) = (5,3,2,1,1)\nfibonacci(5) = (8,5,3,2,1,1)\nfibonacci(6) = (13,8,5,3,2,1,1)\nfibonacci(7) = (21,13,8,5,3,2,1,1)\nfibonacci(8) = (34,21,13,8,5,3,2,1,1)\nfibonacci(9) = (55,34,21,13,8,5,3,2,1,1)"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html#interclassement-strict",
    "href": "posts/informatique/algo avancee activite 3.html#interclassement-strict",
    "title": "Algorithmique avancée : activité 3",
    "section": "6.1 Interclassement strict",
    "text": "6.1 Interclassement strict\n\nOn s’intéresse tout d’abord à un interclassement strict qui insère alternativement un élément de la première liste puis un élément de la seconde liste. Dans le cas où une liste est plus courte que l’autre, les éléments restants de la plus longue sont insérés à la fin de la liste résultat sans interclassement. Plus précisément, si une liste est vide dès le début, la seconde est retournée. Si les deux listes sont vides, alors la liste vide (None) est retournée. Par exemple :\n\nOn commence par créer une fonction qui permet de copier une liste chaînée (créer une nouvelle liste qui contien les mêmes valeurs).\n\ndef copy(L: Node) -> Node:\n    \"\"\"Créer une copie d'une liste chaînée.\"\"\"\n    if L is None: return None\n    return Node(L.valeur, copy(L.suivant))\n\n\n\n\n\n\n\nVersion itérative de copy\n\n\n\n\n\nLa version itérative nécessite de garder à la fois un pointeur vers la position dans la liste originale et vers la fin de la nouvelle liste.\n\ndef copy_iter(L: Node) -> Node:\n    \"\"\"Créer une copie d'une liste chaînée.\"\"\"\n    if L is None: return None\n    res = Node(L.valeur)\n    p = res\n    q = L.suivant\n    while q is not None:\n        p.suivant = Node(q.valeur)\n        p = p.suivant\n        q = q.suivant\n    return res\n\n\n\n\n\n6.1.1 Itératif\n\ndef inter_strict_iter(L1: Node, L2: Node) -> Node:\n    if L1 is None: return copy(L2)\n    if L2 is None: return copy(L1)\n    res = Node(L1.valeur, Node(L2.valeur))\n    L1_p = L1.suivant\n    L2_p = L2.suivant\n    res_tail = res.suivant\n    while L1_p is not None and L2_p is not None:\n        res_tail.suivant = Node(L1_p.valeur, Node(L2_p.valeur))\n        res_tail = res_tail.suivant.suivant\n        L1_p = L1_p.suivant\n        L2_p = L2_p.suivant\n    if L1_p is None: res_tail.suivant = copy(L2_p)\n    if L2_p is None: res_tail.suivant = copy(L1_p)\n    return res\n\nL1 = Node(2, Node(6, Node(42, Node(73, Node(1237)))))\nL2 = Node(0, Node(1, Node(0)))\nprint(Liste(inter_strict_iter(L1, L2)))\n\n(2,0,6,1,42,0,73,1237)\n\n\n\n\n6.1.2 Récursif\n\ndef inter_strict_rec(L1: Node, L2: Node) -> Node:\n    if L1 is None or L2 is None: return None\n    return Node(L1.valeur, Node(L2.valeur,\n                inter_strict_rec(L1.suivant, L2.suivant)))\n\nL1 = Node('A', Node('B', Node('C', Node('D', Node('E')))))\nL2 = Node(0, Node(1, Node(2)))\nprint(Liste(inter_strict_iter(L1, L2)))\n\n(A,0,B,1,C,2,D,E)\n\n\n\n\n\n\n\n\nAvec match\n\n\n\n\n\nLe mot clef match de python permet de faire du “pattern matching”, un peu comme en ocaml. Cette syntaxe (avec match et case) peut être plus lisible que des if dans certains cas.\nIci, on profite du fait d’avoir deux cas symétrique : si L1 est None et si L2 est Non. Dans chaque cas, il faut retourner une copie de l’autre liste.\nL’expression (L, None) | (None, L) va matcher tous les cas où l’une des deux listes (L1, L2) est vide. Alors, L sera l’autre liste, exactement ce qu’il faut pour faire un return copy(L) !\n\ndef inter_strict_rec(L1: Node, L2: Node) -> Node:\n    match (L1, L2):\n        case (L, None) | (None, L): return copy(L)\n    return Node(L1.valeur, Node(L2.valeur,\n                inter_strict_rec(L1.suivant, L2.suivant)))\n\nL1 = Node('A', Node('B', Node('C', Node('D', Node('E')))))\nL2 = Node(0, Node(1, Node(2)))\nprint(Liste(inter_strict_iter(L1, L2)))\n\n(A,0,B,1,C,2,D,E)\n\n\nComme on fait un return copy(L), on a pas besoin de préciser que le return récursif ne doit pas être exécuté dans tous les cas. Mais si on ne fait pas de return, on peut utiliser le cas case other:, qui correspondra à un else : il sera atteint seulement si aucun des autres cas ne sont trouvés.\n\nfor a in range(8):\n    match a:\n        case 0:\n            print(a, \"un nombre nul\")\n        case 1:\n            print(a, \"premier nombre, mais pas un nombre premier\")\n        case 2:\n            print(a, \"est le premier nombre premier\")\n        case 3:\n            print(a, \"est un autre nombre premier\")\n        case 4:\n            print(a, \"est le premier nombre pas premier\")\n        case 5:\n            print(a, \"est encore un nombre premier\")\n        case other:\n            print(a, \"est trop grand pour moi\")\n    # sera exécuté à chaque fois, quel que soit le match\n    print(\"--------------------------------------------\")\n\n0 un nombre nul\n--------------------------------------------\n1 premier nombre, mais pas un nombre premier\n--------------------------------------------\n2 est le premier nombre premier\n--------------------------------------------\n3 est un autre nombre premier\n--------------------------------------------\n4 est le premier nombre pas premier\n--------------------------------------------\n5 est encore un nombre premier\n--------------------------------------------\n6 est trop grand pour moi\n--------------------------------------------\n7 est trop grand pour moi\n--------------------------------------------"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html#interclassement-croissant",
    "href": "posts/informatique/algo avancee activite 3.html#interclassement-croissant",
    "title": "Algorithmique avancée : activité 3",
    "section": "6.2 Interclassement croissant",
    "text": "6.2 Interclassement croissant\n\nOn considère maintenant deux listes de nombres L1 et L2 qui sont triées par ordre croissant. Écrire une fonction d’interclassement interCroissant(L1, L2) qui insère à chaque itération l’élément le plus petit qui se trouve en tête de liste soit de L1 soit de L2. Un tel interclassement produit une liste fusionnée elle-même triée par ordre croissant. Proposer une solution itérative puis une solution récursive à ce problème.\n\n\n6.2.1 Itératif\n\ndef inter_croissant_iter(L1: Node, L2: Node) -> Node:\n    if L1 is None: return copy(L2)\n    if L2 is None: return copy(L1)\n    L1_p = L1\n    L2_p = L2\n    # init 1ère valeur\n    res = None\n    if L1_p.valeur < L2_p.valeur:\n        res = Node(L1_p.valeur)\n        L1_p = L1_p.suivant\n    else:\n        res = Node(L2_p.valeur)\n        L2_p = L2_p.suivant\n    res_tail = res\n    while L1_p is not None and L2_p is not None:\n        if L1_p.valeur < L2_p.valeur:\n            res_tail.suivant = Node(L1_p.valeur)\n            res_tail = res_tail.suivant\n            L1_p = L1_p.suivant\n        else:\n            res_tail.suivant = Node(L2_p.valeur)\n            res_tail = res_tail.suivant\n            L2_p = L2_p.suivant\n    if L1_p is None:\n        res_tail.suivant = copy(L2_p)\n    elif L2_p is None:\n        res_tail.suivant = copy(L1_p)\n    return res\n\nL1 = Node(1, Node(6, Node(42, Node(73, Node(1237)))))\nL2 = Node(0, Node(12, Node(37, Node(67, Node(68)))))\nprint(Liste(inter_croissant_iter(L1, L2)))\n\n(0,1,6,12,37,42,67,68,73,1237)\n\n\n\n\n6.2.2 Récursif\n\ndef inter_croissant_rec(L1: Node, L2: Node) -> Node:\n    match (L1, L2):\n        case (L, None) | (None, L): return copy(L)\n        case (L1, L2) if L1.valeur < L2.valeur:\n            return Node(L1.valeur,\n                        inter_croissant_rec(L1.suivant, L2))\n        case other:\n            return Node(L2.valeur,\n                        inter_croissant_rec(L1, L2.suivant))\n\nL1 = Node(1, Node(6, Node(42, Node(73, Node(1237)))))\nL2 = Node(0, Node(12, Node(37, Node(67, Node(68)))))\nprint(Liste(inter_croissant_iter(L1, L2)))\n\n(0,1,6,12,37,42,67,68,73,1237)"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html#notation-postfixée",
    "href": "posts/informatique/algo avancee activite 3.html#notation-postfixée",
    "title": "Algorithmique avancée : activité 3",
    "section": "7.1 Notation postfixée",
    "text": "7.1 Notation postfixée\nIndiquer la traduction en notation postfixée des expressions suivantes exprimées en notation infixée (les parenthèses ne sont là que pour vous aider à comprendre la priorité des opérations) :\n\n(2 + 4) * n 5\n\n2 4 + 5 n * ou bien 5 n 2 4 + *\n\n9 / (3.5 + 6)\n\n9 3.5 6 + /\n\n(3 - 5) / (3 + 5)\n\n3 5 - 3 5 + /"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 3.html#caculatrice",
    "href": "posts/informatique/algo avancee activite 3.html#caculatrice",
    "title": "Algorithmique avancée : activité 3",
    "section": "7.2 Caculatrice",
    "text": "7.2 Caculatrice\n\nImplémenter une calculatrice simple en notation postfixée sur la base d’une pile gérée par votre barrière d’abstraction.\n\n\n7.2.1 Pile\n\n\n\n\n\n\nNotes sur l’implémentation\n\n\n\n\n\n\nLe dessus de la pile (la tête de la pile) sera la tête de liste (le premier élément de la liste), pour minimiser la complexité des opérations de base.\nLes opérations sur les piles seront faîtes en-place (“in place”), c’est-à-dire que les listes seront modifiées (une nouvelle liste ne sera pas créée à chaque fois)\nOn peut alors avoir un push et un pop en \\(O(1)\\)\n\n\n\n\n\n7.2.1.1 Push\n\ndef push(L: Node, valeur) -> Node:\n    return Node(valeur, L)\n\nA = Node(1, Node(2))\nA = push(A, 42)\nprint(Liste(A))\n\n(42,1,2)\n\n\n\n\n7.2.1.2 Get\n\ndef get(L: Node) -> Node:\n    if L is None:\n        return None\n    return L.valeur\n\nprint(Liste(A))\nprint(get(A))\n\n(42,1,2)\n42\n\n\n\n\n7.2.1.3 Pop\n\ndef pop(L: Node) -> Node:\n    if L is None:\n        raise ValueError(\"pop from empty stack.\")\n    return L.suivant\n\nprint(Liste(A))\nA = pop(A)\nprint(Liste(A))\n\n(42,1,2)\n(1,2)\n\n\n\n\n7.2.1.4 Is empty\n\ndef is_empty(L: Node) -> bool:\n    return L is None\n\nprint(is_empty(None))\nprint(is_empty(Node(1, Node(2))))\n\nTrue\nFalse\n\n\n\n\n7.2.1.5 Height\n\ndef height(L: Node) -> int:\n    if is_empty(L):\n        return 0\n    return 1 + height(L.suivant)\n\nL = Node(1, Node(2, Node(3, Node(42))))\nprint(height(L))\n\n4\n\n\n\n\n\n7.2.2 Abstraction de la calculatrice\nOn créée d’abord une fonction qui permet d’appliquer un opérateur binaire à une pile (sur les deux premiers éléments).\n\ndef appliquer(bin_operator, L: Node) -> Node:\n    \"\"\"Appliquer `bin_operator` sur les deux premières valeurs de la pile.\n\n    Le premier paramètre donné à `bin_operator` est le dessus de la pile, et le\n    second est le second élément de la pile.\n    \"\"\"\n    if L is None:\n        raise ValueError(\"applying operator on empty stack\")\n    if L.suivant is None:\n        raise ValueError(\"applying operator on stack with only one element\")\n    return Node(bin_operator(L.valeur, L.suivant.valeur), L.suivant.suivant)\n    first = get(L)\n    L = pop(L)\n    second = get(L)\n    L = pop(L)\n    result = bin_operator(first, second)\n    return push(result, L)\n\nA = Node(3, Node(2, Node(4, Node(1, Node(5)))))\nadd = lambda x, y: x+y\ndiv = lambda x, y: y / x\nA = appliquer(add, A)\nprint(Liste(A))\nA = appliquer(div, A)\nprint(Liste(A))\n\n(5,4,1,5)\n(0.8,1,5)\n\n\n\n7.2.2.1 Opérateurs de base\n\ndef add(L: Node) -> Node:\n    return appliquer(lambda x, y: x+y, L)\n\ndef sub(L: Node) -> Node:\n    return appliquer(lambda x, y: y - x, L)\n\ndef mult(L: Node) -> Node:\n    return appliquer(lambda x, y: x * y, L)\n\ndef div(L: Node) -> Node:\n    return appliquer(lambda x, y: y / x, L)\n\nA = Node(3, Node(2, Node(1, Node(1, Node(5)))))\nprint(Liste(A))\nA = add(A)\nprint(Liste(A))\nA = sub(A)\nprint(Liste(A))\nA = div(A)\nprint(Liste(A))\nA = mult(A)\nprint(Liste(A))\n\n(3,2,1,1,5)\n(5,1,1,5)\n(-4,1,5)\n(-0.25,5)\n(-1.25)\n\n\n\n\n7.2.2.2 Opérations unaires\nLes opérations unaires sont des opérations qui modifient uniquement le premier élément de la pile.\n\ndef appliquer_unaire(operation, L: Node) -> Node:\n    if L is None:\n        raise ValueError(\"cannot apply unary function to an empty stack\")\n    val = get(L)\n    L = pop(L)\n    return push(operation(val), L)\n\nVoici quelques opérations unaires utiles :\ndef neg(L: Node) -> Node:\n    \"\"\"Négation : transformer la première valeur de la pile en son opposé.\n    \"\"\"\n    return appliquer_unaire(lambda x: -x, L)\n\ndef inv(L: Node) -> Node:\n    \"\"\"Inversion : inverser le premier élément de la pile (l'inverse de x est 1/x).\n    \"\"\"\n    return appliquer_unaire(lambda x: 1/x, L)\n\nprint(Liste(A))\nA = neg(A)\nprint(Liste(A))\nA = inv(A)\nprint(Liste(A))\n\n\n7.2.2.3 Affichage d’une pile\nOn veut afficher la pile avec la tête en base, pour que les nombres les plus récents soient plus près de l’entrée utilisateur.\ndef stack_to_list(L: Node) -> list:\n    if L is None: return []\n    return [L.valeur] + stack_to_list(L.suivant)\n\ndef show_stack(L: Node) -> None:\n    # pour afficher la liste la tête en bas, on retourne la liste\n    print(*reversed(stack_to_list(L)), sep='\\n')\n\nL = Node(1, Node(2, Node(3, Node(4, Node(5)))))\nshow_stack(L)\n\n\n7.2.2.4 Traduction des commandes\nOn veut créer une fonction qui transforme une liste selon une chaîne de caractères donnée, qui représente l’opération voulue.\nOn pourrait utiliser des structures if ... elif ... elif ... else, ainsi que des clauses or pour tester les différentes commandes, mais la structure match (apparue dans la version 3.10 de python) permet une syntaxe plus claire, et des expressions plus riches.\nfrom math import *\nFUNCS = (\"exp\" | \"log\" | \"sqrt\" | \"ceil\" | \"floor\" | \"cos\" | \"sin\" | \"tan\" | \"cosh\" | \"sinh\" | \"tanh\" | \"acos\" | \"asin\" | \"atan\")\ndef appliquer_str(op_str: str, L: Node) -> Node:\n    \"\"\"Appliquer l'opération désignée par `op_str` sur `L`.\n    Exemples :\n    >>> appliquer_str(\"+\", Node(1, Node(2))) # donne Node(3)\n    >>> appliquer_str(\"/\", Node(5, Node(2))) # donne Node(0.4)\n    \"\"\"\n    match op_str:\n        case \"+\" | \"add\":\n            return add(L)\n        case \"-\" | \"sub\" | \"subs\":\n            return sub(L)\n        case \"*\" | \"mul\" | \"mult\" | \"times\":\n            return mult(L)\n        case \"/\" | \"÷\" | \"div\" | \"divide\":\n            return div(L)\n        case \"-\" | \"neg\" | \"negate\" | \"oppose\" | \"opposite\":\n            return neg(L)\n        case \"inv\" | \"invs\" | \"inverse\":\n            return inv(L)\n        case \"pop\" | \"del\":\n            return pop(L)\n        case (\"pi\" | \"e\") as constant:\n            # eval transforme la chaîne de caractère en la valeur de la variable\n            # en fait, eval évalue un code python\n            return push(eval(constant), L)\n        case FUNCS as fonction:\n            # ici, eval transforme la chaîne de caractère en fonction\n            return appliquer_unaire(eval(fonction), L)\n        case \"ln\":\n            return appliquer_unaire(log, L)\n        # aucune opération n'est donnée : on ne fait rien\n        case \"\":\n            return L\n        # tout autre valeur n'est pas une opération connue\n        case _:\n            print(\"opération inconnue !\")\n            # on ne modifie pas L\n            return L"
  },
  {
    "objectID": "posts/informatique/>>informatique.html",
    "href": "posts/informatique/>>informatique.html",
    "title": "Informatique",
    "section": "",
    "text": "structures de données\n\nstructures statiques\n\ntableaux\n\nstructures dynamiques\n\nlistes chaînées\n\nstructures récursives\n\nlistes chaînées\n\n\n\n\n\n\n\n\n\n\npython\n\ntransformer des listes python en tables markdown\n\nAPL (A Programming Language)\n\n\n\n\n\nbtop : voir les processus en cours\nVim\n\nla touche leader\nautocorriger les erreurs d’orthographe"
  },
  {
    "objectID": "posts/informatique/algo avancee listes chainees.html",
    "href": "posts/informatique/algo avancee listes chainees.html",
    "title": "Listes chaînées",
    "section": "",
    "text": "Définition\n\n\n\nReprésentation d’une liste de façon récursive. - les éléments sont rangés linéairement -\nLa liste est un bloc, puis un lien vers la suite de la liste (le bloc suivant).\n\nUne liste chaînée est donc un bloc contenant : - une valeur - un pointeur vers le premier bloc de la suite - Cette “suite” est aussi une liste chaînée"
  },
  {
    "objectID": "posts/informatique/algo avancee listes chainees.html#fonctions-sur-des-node",
    "href": "posts/informatique/algo avancee listes chainees.html#fonctions-sur-des-node",
    "title": "Listes chaînées",
    "section": "Fonctions sur des Node",
    "text": "Fonctions sur des Node\n\nAfficher les éléments\n\ndef affichage(L: Node) -> str:\n    chaine = \"\"\n    while L is not None:\n        chaine += \"<\" + str(L.valeur) + \"> \"\n        L = L.suivant\n    return chaine\n\nmylist = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nprint(affichage(mylist))\n\n<3> <1> <4> <1> <5> <9> \n\n\nOu bien, dans une version récursive :\n\ndef affichageRec(L: Node) -> str:\n    if L is None:\n        return \"\"\n    return \"<\" + str(L.valeur) + \"> \"\n\nmylist = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nprint(affichage(mylist))\n\n<3> <1> <4> <1> <5> <9> \n\n\nEt on peut utiliser la méthode magique __str__ de la classe LinkedList :\n\nclass LinkedList:\n    def __init__(self, head: Node =None):\n        \"\"\"Initialize a linked list\"\"\"\n        self.head : Node = head\n\n    def __str__(self) -> str:\n        L = self.head\n        res = \"\"\n        while L is not None:\n            res += \"<\" + str(L.valeur) + \"> \"\n            L = L.suivant\n        return res\n\nmylinkedlist = LinkedList(mylist)\n\n# __str__ permet de définir le résultat de str(mylinkedlist)\n# print appelle toujours la fonction str, donc pas beson de l'ajouter\nprint(mylinkedlist)\n\n<3> <1> <4> <1> <5> <9> \n\n\n\n\nCalculer la longueur\nOn peut à nouveau le faire de plusieurs façons. Pour pouvoir utiliser la fonction len sur l’objet, on ajoute la méthode __len__ sur la classe LinkedList\n\nclass LinkedList:\n    def __init__(self, head: Node =None):\n        \"\"\"Initialize a linked list\"\"\"\n        self.head : Node = head\n\n    def __len__(self) -> int:\n        L = self.head\n        length = 0\n        while L is not None:\n            length += 1\n            L = L.suivant\n        return length\n\n# on re-créée l'objet pour que la nouvelle fonction soit mise à jour\nmylinkedlist = LinkedList(mylist)\nprint(len(mylinkedlist))\n\n6"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html",
    "href": "posts/informatique/algo avancee activite 1.html",
    "title": "Algorithmique avancée - activité 1",
    "section": "",
    "text": "Correction détaillée de l’activité 1 d’algorithmique avancée."
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#temps-dexécution-de-la-première-méthode-de-génération",
    "href": "posts/informatique/algo avancee activite 1.html#temps-dexécution-de-la-première-méthode-de-génération",
    "title": "Algorithmique avancée - activité 1",
    "section": "Temps d’exécution de la première méthode de génération",
    "text": "Temps d’exécution de la première méthode de génération\nVoici donc le code :\n\nfrom time import time\n\n# liste des nombres d'éléments dans la liste que l'on veut tester\n# on peut aussi utiliser range(10, 10000, 10) par exemple\nLIST_NUMBER_OF_ELEMENTS = [10, 100, 1000, 10000]\n\nfor number_of_elements in LIST_NUMBER_OF_ELEMENTS:\n    # on stocke le moment de début de la génération\n    start = time()\n\n    # on génère des nombres aléatoires\n    foo = generation(number_of_elements, 42, 73)\n\n    # on stocke le moment de fin de la génération\n    end = time()\n\n    # la durée d'exécution est la différence entre le moment de début et de fin\n    # Attention : si on inverse end et start, on obtient un nombre négatif\n    duration = end - start\n\n    # on arrondi la durée, pour que le tout soit plus lisible\n    duration = round(duration, 5)\n\n    # affichage du résultat\n    print(f\"générer {number_of_elements} à mis {duration} secondes\")\n\ngénérer 10 à mis 1e-05 secondes\ngénérer 100 à mis 5e-05 secondes\ngénérer 1000 à mis 0.00043 secondes\ngénérer 10000 à mis 0.00397 secondes"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#temps-dexécution-avec-des-list-comprehension",
    "href": "posts/informatique/algo avancee activite 1.html#temps-dexécution-avec-des-list-comprehension",
    "title": "Algorithmique avancée - activité 1",
    "section": "Temps d’exécution avec des list comprehension",
    "text": "Temps d’exécution avec des list comprehension\nOn utilise exactement le même code, mais avec la fonction generation_comprehension au lieu de generation :\n\nLIST_NUMBER_OF_ELEMENTS = [10, 100, 1000, 10000]\n\nfor number_of_elements in LIST_NUMBER_OF_ELEMENTS:\n    start = time()\n    foo = generation_comprehension(number_of_elements, 42, 73)\n    end = time()\n\n    duration = end - start\n    duration = round(duration, 5)\n    print(f\"générer {number_of_elements} à mis {duration} secondes\")\n\ngénérer 10 à mis 2e-05 secondes\ngénérer 100 à mis 5e-05 secondes\ngénérer 1000 à mis 0.00038 secondes\ngénérer 10000 à mis 0.0038 secondes\n\n\nOn remarque que le code avec des list comprehension est effectivement plus rapide."
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#pour-aller-plus-loin",
    "href": "posts/informatique/algo avancee activite 1.html#pour-aller-plus-loin",
    "title": "Algorithmique avancée - activité 1",
    "section": "Pour aller plus loin",
    "text": "Pour aller plus loin\n\n\n\n\n\n\nPour aller plus loin\n\n\n\n\n\nOn peut, par exemple, définir une fonction qui mesure le temps d’exécution d’une autre fonction.\nPour cela, il faut que cette nouvelle fonction (appelons-la temps_execution), prenne en argument la fonction dont on mesure le temps d’exécution.\nOn obtient donc quelque chose comme ça :\n\ndef temps_execution(fonction_a_tester, number_of_elements: int) -> float:\n    # ici, on mesure le temps d'exécution\n    start = time()\n    foo = fonction_a_tester(number_of_elements, 42, 73)\n    end = time()\n    # l'idéal est de retourner le temps d'exécution plutôt\n    # que de mettre un print à l'intérieur d'une fonction\n    # (ce qui est à # éviter en général)\n    return end - start\n\nprint(temps_execution(generation,               1000))\nprint(temps_execution(generation_comprehension, 1000))\n\n0.0003991127014160156\n0.0003972053527832031"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#avec-une-boucle-et-une-nouvelle-liste",
    "href": "posts/informatique/algo avancee activite 1.html#avec-une-boucle-et-une-nouvelle-liste",
    "title": "Algorithmique avancée - activité 1",
    "section": "Avec une boucle et une nouvelle liste",
    "text": "Avec une boucle et une nouvelle liste\nOn peut utiliser une approche classique : créer la nouvelle liste au fur-et-à-mesure, en parcourant la liste de départ.\n\nAvec une condition sur les indices\n\ndef un_sur_n_indices(n: int, liste: list) -> list:\n    \"\"\"Sélectionne un élément sur `n` dans `liste`\"\"\"\n    new_list = []\n    for i in range(len(liste)):\n        # si i est divisible par n (une fois sur n)\n        if 0 == i % n:\n            # on ajoute l'élément à l'indice actuel dans la\n            # nouvelle liste\n            new_list.append(liste[i])\n    return new_list\n\nprint(un_sur_n_indices(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n\n[2, 8, 1]\n\n\n\n\nEn utilisant un pas sur range\nUne technique plus simple (et plus efficace) est, plutôt que de tester pour tous les indices, d’utiliser un range dans lequel on met un pas de n.\nCela permet de n’avoir dans la boucle que les indices qui nous intéressent.\n\ndef un_sur_n_range(n: int, liste: list) -> list:\n    new_list = []\n    # on met un 0 pour que n soit bien le 3ème argument\n    for i in range(0, len(liste), n):\n        new_list.append(liste[i])\n    return new_list\n\nprint(un_sur_n_range(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n\n[2, 8, 1]"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#avec-une-list-comprehension",
    "href": "posts/informatique/algo avancee activite 1.html#avec-une-list-comprehension",
    "title": "Algorithmique avancée - activité 1",
    "section": "Avec une list comprehension",
    "text": "Avec une list comprehension\nPour être encore plus efficace, on peut simplement utiliser un list comprehension, en conjonction avec les techniques citées plus haut.\nLe code est en fait équivalent, mais permet de créer la liste de façon plus efficace.\n\nAvec une condition sur les indices\n\ndef un_sur_n_comprehension_indices(n: int, liste: list) -> list:\n    return [liste[i] for i in range(len(liste)) if 0 == i%n]\n\nprint(un_sur_n_comprehension_indices(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n\n[2, 8, 1]\n\n\n\n\n\n\n\n\nRetours à la ligne pour plus de clarté\n\n\n\n\n\nPour rendre le code plus clair, on peut mettre un retour à la ligne avant le for et le if :\n\ndef un_sur_n_comprehension_indices(n: int, liste: list) -> list:\n    return [liste[i]\n            for i in range(len(liste))\n            if 0 == i%n]\n\nCela est très utile quand on construit des expressions complexes, par exemple avec des list comprehension à l’intérieur de list comprehension.\n\n\n\n\n\nEn utilisant un pas sur range\nOn peut à nouveau utiliser un pas sur le range pour ne pas avoir à tester toutes les itérations.\n\ndef un_sur_n_comprehension_range(n: int, liste: list) -> list:\n    return [liste[i] for i in range(0, len(liste), n)]\n\nprint(un_sur_n_comprehension_range(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n\n[2, 8, 1]"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#en-parcourant-les-indices-des-deux-tableaux",
    "href": "posts/informatique/algo avancee activite 1.html#en-parcourant-les-indices-des-deux-tableaux",
    "title": "Algorithmique avancée - activité 1",
    "section": "En parcourant les indices des deux tableaux",
    "text": "En parcourant les indices des deux tableaux\nL’approche classique est de parcourir les indices i des deux tableaux (que l’on suppose de même taille), et de calculer le maximum pour chaque indice, que l’on mettra dans une nouvelle liste.\n\ndef max_des_2_indices(tab1: list[int], tab2: list[int]) -> list[int]:\n    new_list: list[int] = []\n    # on parcoure les indices des deux tableaux en même\n    # temps avec i\n    for i in range(len(tab1)):\n        # la fonction max calcul le maximum de ses arguments\n        # ici, les arguments sont les valeurs des deux\n        # tableaux pour un même indice i\n        new_list.append(max(tab1[i], tab2[i]))\n    return new_list\n\nprint(max_des_2_indices([1, 4, 5], [2, 2, 3]))\n\n[2, 4, 5]"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#en-utilisant-la-fonction-zip",
    "href": "posts/informatique/algo avancee activite 1.html#en-utilisant-la-fonction-zip",
    "title": "Algorithmique avancée - activité 1",
    "section": "En utilisant la fonction zip",
    "text": "En utilisant la fonction zip\nLa fonction zip va permettre de regrouper les éléments exactement comme on le souhaite. En effet, si on essaie de l’appliquer :\n\nz = zip([3, 1, 4, 1, 5, 9, 2, 6], [2, 7, 1, 8, 2, 8, 1, 8])\nprint(list(z))  # on utilise list pour que le contenu soit bien affiché\n\n[(3, 2), (1, 7), (4, 1), (1, 8), (5, 2), (9, 8), (2, 1), (6, 8)]\n\n\nOn observe que le résultat contient les paires d’éléments dont on veut faire le maximum : les deux premiers de chaque tableau, plus les deux deuxièmes, les deux troisièmes etc…\nOn peut alors proposer la solution suivante :\n\ndef max_des_2_zip(tab1: list[int], tab2: list[int]) -> list[int]:\n    new_list: list[int] = []\n    for couple in zip(tab1, tab2):\n        # on note que la fonction `max` peut s'appliquer sur\n        # une liste d'élément (ici `couple`)\n        new_list.append(max(couple))\n    return new_list\n\nprint(max_des_2_zip([1, 4, 5], [2, 2, 3]))\n\n[2, 4, 5]"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#avec-zip-et-map",
    "href": "posts/informatique/algo avancee activite 1.html#avec-zip-et-map",
    "title": "Algorithmique avancée - activité 1",
    "section": "Avec zip et map",
    "text": "Avec zip et map\nOn remarque dans cet exercice une structure que l’on a déjà vue dans les exercices suivants : on veut appliquer une fonction particulière sur chaque élément d’une liste, puis récupérer le résultat.\nL’approche classique consiste à parcourir la liste, et à créer au fur-et-à-mesure une nouvelle liste.\nCependant, une des fonctions de base de python, la fonction map, permet directement d’appliquer une fonction sur tous les éléments d’une liste, et de récupérer le résultat.\nOn peut donc tout simplement écrire :\n\ndef max_des_2_map(tab1: list[int], tab2: list[int]) -> list[int]:\n    # on utilise list pour bien récupérer une liste\n    # on applique la fonction max sur le résultat du zip\n    return list(\n        map(max, zip(tab1, tab2))\n    )\n\nprint(max_des_2_map([1, 4, 5], [2, 2, 3]))\n\n[2, 4, 5]\n\n\nCette approche est une approche fonctionnelle du problème, puisque la solution est créée en composant des fonctions existantes (map, max, zip…) et sans structures de contrôles comme des boucles ou des conditions."
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#en-parcourant-les-indices-des-deux-listes",
    "href": "posts/informatique/algo avancee activite 1.html#en-parcourant-les-indices-des-deux-listes",
    "title": "Algorithmique avancée - activité 1",
    "section": "En parcourant les indices des deux listes",
    "text": "En parcourant les indices des deux listes\n\ndef myzip_indices(tab1: list[int], tab2: list[int]) -> list[int]:\n    zipped_list: list[int] = []\n    for idx in range(len(tab1)):\n        # on ajoute le couple (tab1[idx], tab2[idx]) à la\n        # liste de résultat. On a bien un couple d'éléments\n        # aux mêmes indices\n        zipped_list.append((tab1[idx], tab2[idx]))\n    return zipped_list\n\nprint(myzip_indices([1, 4, 5], [2, 2, 3]))\n\n[(1, 2), (4, 2), (5, 3)]"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#si-les-deux-listes-ne-font-pas-la-même-taille",
    "href": "posts/informatique/algo avancee activite 1.html#si-les-deux-listes-ne-font-pas-la-même-taille",
    "title": "Algorithmique avancée - activité 1",
    "section": "Si les deux listes ne font pas la même taille",
    "text": "Si les deux listes ne font pas la même taille\nSi les deux listes ne font pas la même taille, il faut s’arrêter quand la première liste est arrivée au bout. On peut donc simplement parcourir les indices de 1 à min(len(tab1), len(tab2)).\n\ndef myzip_indices(tab1: list[int], tab2: list[int]) -> list[int]:\n    zipped_list: list[int] = []\n    for idx in range(min(len(tab1), len(tab2))):\n        # on ajoute le couple (tab1[idx], tab2[idx]) à la\n        # liste de résultat. On a bien un couple d'éléments\n        # aux mêmes indices\n        zipped_list.append((tab1[idx], tab2[idx]))\n    return zipped_list\n\nprint(myzip_indices([1, 4, 5], [2, 2, 3, 99, 0]))\nprint(myzip_indices([1, 4, 5, 7, 13, 4], [2, 2, 3, 99]))\n\n[(1, 2), (4, 2), (5, 3)]\n[(1, 2), (4, 2), (5, 3), (7, 99)]"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#avec-des-list-comprehension",
    "href": "posts/informatique/algo avancee activite 1.html#avec-des-list-comprehension",
    "title": "Algorithmique avancée - activité 1",
    "section": "Avec des list comprehension",
    "text": "Avec des list comprehension\n\ndef genMat(row: int, col: int, mini: int, maxi: int) -> list[list[int]]:\n    \"\"\"Initialiser une matrice aléatoire de taille (row, col), avec des valeurs dans [mini, maxi].\n    \"\"\"\n    return [[randint(mini, maxi) for i in range(col)] for j in range(row)]\n\nprint(genMat(3, 3, 0, 10))\n\n[[5, 3, 8], [1, 1, 0], [1, 6, 2]]"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#en-créant-la-liste-au-fur-et-à-mesure",
    "href": "posts/informatique/algo avancee activite 1.html#en-créant-la-liste-au-fur-et-à-mesure",
    "title": "Algorithmique avancée - activité 1",
    "section": "En créant la liste au fur-et-à-mesure",
    "text": "En créant la liste au fur-et-à-mesure\nLes list comprehension sont plus rapides, plus courtes et beaucoup plus simples à utiliser. Cet exemple est simplement là pour montrer d’autres techniques de programmation.\n\ndef genMat(row: int, col: int, mini: int, maxi: int) -> list[list[int]]:\n    \"\"\"Initialiser une matrice aléatoire de taille (row, col), avec des valeurs dans [mini, maxi].\n    \"\"\"\n    mat = []\n    for i in range(row):\n        line = []\n        for j in range(col):\n            line.append(randint(mini, maxi))\n        mat.append(line)\n    return mat\n\n\nprint(genMat(3, 3, 0, 10))\n\n[[10, 10, 8], [6, 8, 4], [8, 3, 3]]"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#avec-des-list-comprehension-1",
    "href": "posts/informatique/algo avancee activite 1.html#avec-des-list-comprehension-1",
    "title": "Algorithmique avancée - activité 1",
    "section": "Avec des list comprehension",
    "text": "Avec des list comprehension\n\ndef diagonale(mat: list[list[float]]) -> list[float]:\n    \"\"\"Diagonale d'une matrice.\n    Args:\n        mat (list[list[float]]): Une matrice qui doit être carrée\n                                 (sinon la diagonale n'existe pas).\n    Returns:\n        list[float]: La liste des coefficients diagonaux de mat.\n    \"\"\"\n    return [mat[i][i] for i in range(len(mat))]\n\nprint(diagonale(M))\n\n[1, 0, 8]"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#pour-aller-plus-loin-2",
    "href": "posts/informatique/algo avancee activite 1.html#pour-aller-plus-loin-2",
    "title": "Algorithmique avancée - activité 1",
    "section": "Pour aller plus loin",
    "text": "Pour aller plus loin\n\n\n\n\n\n\nLever une erreur si la matrice n’est pas carrée\n\n\n\n\n\nPour bien faire, il faudrait lever une erreur si la matrice n’est pas carrée. Pour cela, on utilise le mot clef raise, ainsi qu’une erreur classique de python. Ici, on utilisera ValueError (on pourrait également créer une classe d’erreurs nous-même, puisque les erreurs sont simplement des objets particuliers).\n\ndef diagonale(mat: list[list[float]]) -> list[float]:\n    \"\"\"Diagonale d'une matrice.\n    Args:\n        mat (list[list[float]]): Une matrice qui doit être carrée\n                                 (sinon la diagonale n'existe pas).\n    Returns:\n        list[float]: La liste des coefficients diagonaux de mat.\n    Raises:\n        ValueError: Si la matrice donnêé en entrée n'est pas carrée.\n    \"\"\"\n    # si la matrice n'est pas carrée\n    if not all(len(mat) == len(ligne) for ligne in mat):\n        # on lève une exception.\n        raise ValueError(\"La matrice n'est pas carrée.\")\n    return [mat[i][i] for i in range(len(mat))]\n\nprint(diagonale(M))\n\n[1, 0, 8]"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#avec-une-list-comprehension-et-la-fonction-sum",
    "href": "posts/informatique/algo avancee activite 1.html#avec-une-list-comprehension-et-la-fonction-sum",
    "title": "Algorithmique avancée - activité 1",
    "section": "Avec une list comprehension et la fonction sum",
    "text": "Avec une list comprehension et la fonction sum\n\ndef trace(mat: list[list[float]]) -> float:\n    return sum([mat[i][i] for i in range(len(mat))])\n\nprint(trace(M))\n\n6"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#en-réutilisant-la-fonction-diagonale",
    "href": "posts/informatique/algo avancee activite 1.html#en-réutilisant-la-fonction-diagonale",
    "title": "Algorithmique avancée - activité 1",
    "section": "En réutilisant la fonction diagonale",
    "text": "En réutilisant la fonction diagonale\nComme on a déjà programmé la fonction diagonale, on peut l’utiliser, car la trace d’une matrice est la somme de ses coefficients diagonaux.\n\ndef trace(mat: list[list[float]]) -> float:\n    return sum(diagonale(mat))\n\nprint(trace(M))\n\n6\n\n\nCela rend le code moins redondant et plus clair. C’est l’intérêt d’utiliser des fonctions."
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#avec-une-list-comprehension-1",
    "href": "posts/informatique/algo avancee activite 1.html#avec-une-list-comprehension-1",
    "title": "Algorithmique avancée - activité 1",
    "section": "Avec une list comprehension",
    "text": "Avec une list comprehension\n\ndef somme(mat1: list[list[float]], mat2: list[list[float]]) -> list[list[float]]:\n    \"\"\"Somme de deux matrices que l'on suppose de même taille.\n    \"\"\"\n    # nombre de lignes et de colonnes de mat1 (on la prends comme référence)\n    rows = len(mat1)\n    cols = len(mat1[0])\n    return [[mat1[i][j] + mat2[i][j] for j in range(cols)] for i in range(rows)]\n\nprint(somme(A, B))\n\n[[0, 2, 2, 4], [1, 1, 3, 3], [2, 5, 6, 9]]"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#avec-des-zip-et-des-map",
    "href": "posts/informatique/algo avancee activite 1.html#avec-des-zip-et-des-map",
    "title": "Algorithmique avancée - activité 1",
    "section": "Avec des zip et des map",
    "text": "Avec des zip et des map\nCette solution est plus complexe, mais elle peut avoir des avantages.\nPar exemple, si on retire les fonctions list du code, la fonction va retourner un objet map, qui est une structure paresseuse (“lazy”). Cela veut dire qu’un élément donné ne sera calculé que lorsque l’on en aura besoin (lorsque l’on parcourra la matrice, par exemple).\nCe mécanisme est utile si, quand une fonction est longue à calculer, vous ne voulez pas être obligé d’attendre que toutes les valeurs soient passées par cette fonction avant de pouvoir passer à l’étape suivante : la fonction ne sera exécutée que sur les valeurs nécessaires, au fur-et-à-mesure.\n\ndef somme(mat1: list[list[float]], mat2: list[list[float]]) -> list[list[float]]:\n    \"\"\"Somme de deux matrices que l'on suppose de même taille.\n    \"\"\"\n    return list(map(lambda x: list(map(sum, zip(*x))), zip(mat1, mat2)))\n\nprint(somme(A, B))\n\n[[0, 2, 2, 4], [1, 1, 3, 3], [2, 5, 6, 9]]"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#avec-des-list-comprehension-2",
    "href": "posts/informatique/algo avancee activite 1.html#avec-des-list-comprehension-2",
    "title": "Algorithmique avancée - activité 1",
    "section": "Avec des list comprehension",
    "text": "Avec des list comprehension\nEn utilisant presque directement la formule de définition du produit de matrices, on obtient cette fonction :\n\ndef produit(mat1: list[list[float]], mat2: list[list[float]]) -> list[list[float]]:\n    \"\"\"Produit matriciel mat1 * mat2.\n    On suppose que les matrices sont de la bonne taille, c'est-à-dire que la largeur de mat1 est égale à la longueur de mat2.\n    \"\"\"\n    # largeur et hauteur de la matrice résultat\n    width = len(mat1)\n    height = len(mat2[0])\n    common_length = len(mat2)\n    # on applique la formule :\n    return [[sum(mat1[j][l] * mat2[l][i] for l in range(common_length)) for i in range(height)] for j in range(width)]\n\nprint(produit(A, B))\n\n[[2, 6, 5, 6], [9, 8, 8, 8], [22, 19, 9, 19], [0, 0, 0, 0]]"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#avec-le-module-numpy",
    "href": "posts/informatique/algo avancee activite 1.html#avec-le-module-numpy",
    "title": "Algorithmique avancée - activité 1",
    "section": "Avec le module numpy",
    "text": "Avec le module numpy\nLe module numpy (qui n’est pas un module standard, il faudra donc l’installer avec pip3 --install numpy) possède des fonctions pour l’algèbre linéaire et pour les tableaux en général.\nUn objet matrix est implémenté, et il permet de faire des multiplications de matrices… Avec l’opérateur * ! (Attention : si on utilise l’objet array de numpy plutôt que l’objet matrix, la multiplication sera une multiplication élément-par-élément plutôt qu’une vraie multiplication matricielle).\n\nimport numpy as np\n\nmA = np.matrix(A)\nmB = np.matrix(B)\n\nprint(mA * mB)\n\n[[ 2  6  5  6]\n [ 9  8  8  8]\n [22 19  9 19]\n [ 0  0  0  0]]\n\n\nNote : Avec cette méthode, le résultat n’est pas une liste de listes, mais une matrice."
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#récursion-simple",
    "href": "posts/informatique/algo avancee activite 1.html#récursion-simple",
    "title": "Algorithmique avancée - activité 1",
    "section": "Récursion simple",
    "text": "Récursion simple\nOn va simplement utiliser cette propriété : n divise m si et seulement si n divise m - n : \\(\\forall (m, n) \\in \\mathbb{Z}^{2}, \\quad n \\mid n \\iff n \\mid m-n\\)\nOn utilise aussi le fait que n divise m si et seulement si la valeur absolue de n divise la valeur absolue de m.\n\ndef estDivisible(n: int, m: int) -> bool:\n    if m == 0:\n        return True\n    if m < 0:\n        return False\n    return estDivisible(abs(n), abs(m) - abs(n))\n\nprint(estDivisible(3, 6))    # True\nprint(estDivisible(-3, 12))  # True\nprint(estDivisible(-3, 11))  # False\n\nTrue\nTrue\nFalse"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#récursion-classique",
    "href": "posts/informatique/algo avancee activite 1.html#récursion-classique",
    "title": "Algorithmique avancée - activité 1",
    "section": "Récursion classique",
    "text": "Récursion classique\n\ndef longueur(n: int) -> int:\n    n = abs(n)\n    if n < 10:\n        return 1\n    return 1 + longueur(n / 10)\n\nprint(longueur(314159265358))\nprint(longueur(73))\nprint(longueur(1732))\n\n12\n2\n4"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#récursion-terminale",
    "href": "posts/informatique/algo avancee activite 1.html#récursion-terminale",
    "title": "Algorithmique avancée - activité 1",
    "section": "Récursion terminale",
    "text": "Récursion terminale\n\n\n\n\n\n\nDétails sur la récursion terminale\n\n\n\n\n\nLa récursion terminale est un récursion dans laquelle la dernière opération est l’appel récursif. Cela veut dire que le return qui contient l’appel récursif ne contient pas d’autre opération.\nPar exemple, la définition précédente de longueur n’est pas terminale, car on doit ajouter 1 après l’appel récursif (la ligne de l’appel récursif est return 1 + longueur(n / 10)).\nLa récursion terminale à plusieurs avantages :\n\ndans certains langages, elle est optimisée (l’optimisation de pile d’appel) et rend l’exécution plus rapide et moins coûteuse en mémoire\nElle peut être très facilement convertie en une boucle (la variable de boucle est l’accumulateur de la récursion terminale)\n\nDans certains livres, comme SICP, on voit que la récursion terminale est appelée “itérative”\n\n\n\n\n\nIci, on a aussi optimisé le programme en travaillant uniquement sur des entiers, ce qui permet d’éviter des calculs de division de flottants, qui sont inutiles.\n\ndef longueur(n: int, acc: int =0) -> int:\n    n = int(abs(n))\n    if n < 10:\n        return acc + 1\n    return longueur(n // 10, acc + 1)\n\nprint(longueur(314159265358))\nprint(longueur(73))\nprint(longueur(1732))\n\n12\n2\n4"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#récursion-classique-1",
    "href": "posts/informatique/algo avancee activite 1.html#récursion-classique-1",
    "title": "Algorithmique avancée - activité 1",
    "section": "Récursion classique",
    "text": "Récursion classique\n\ndef combienInf4(n: int) -> int:\n    # si le dernier chiffre de n est un 4\n    if n % 10 < 4:\n        # si n est un chiffre\n        if n < 10:\n            # le résultat est 1\n            return 1\n        # on ajoute 1 à la récursion car n finit par 4\n        return 1 + combienInf4(n // 10)\n    # si n ne finit pas par 4 :\n    # si n est un chiffre\n    if n < 10:\n        # aucun 4 dans n\n        return 0\n    # on ajoute rien à la récursion car n ne finit pas par 4\n    return combienInf4(n // 10)\n\nprint(combienInf4(123456))\nprint(combienInf4(314159265358))\nprint(combienInf4(789456))\n\n3\n5\n0"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#avec-des-conversions-de-types",
    "href": "posts/informatique/algo avancee activite 1.html#avec-des-conversions-de-types",
    "title": "Algorithmique avancée - activité 1",
    "section": "Avec des conversions de types",
    "text": "Avec des conversions de types\nPour rendre le code plus simple (et plus lisible pour un programmeur averti), on utilise le fait que la fonction int puisse convertir des booléens en entiers.\n\ndef combienInf4(n: int) -> int:\n    if n < 10:\n        # (n < 4) est un booléen\n        # int(True) vaut 1, et int(False) vaut 0\n        return int(n < 4)\n    # on ajoute 1 à la récursion si le dernier chiffre de n est 4\n    return int(n % 10 < 4) + combienInf4(n // 10)\n\nprint(combienInf4(123456))\nprint(combienInf4(314159265358))\nprint(combienInf4(789456))\n\n3\n5\n0"
  },
  {
    "objectID": "posts/informatique/algo avancee activite 1.html#récursion-terminale-1",
    "href": "posts/informatique/algo avancee activite 1.html#récursion-terminale-1",
    "title": "Algorithmique avancée - activité 1",
    "section": "Récursion terminale",
    "text": "Récursion terminale\n\ndef combienInf4(n: int, acc: int =0) -> int:\n    if n < 10:\n        return int(n < 4) + acc\n    return combienInf4(n // 10, acc + int(n % 10 < 4))\n\n\nprint(combienInf4(123456))\nprint(combienInf4(314159265358))\nprint(combienInf4(789456))\n\n3\n5\n0"
  },
  {
    "objectID": "posts/informatique/vim tips leader.html",
    "href": "posts/informatique/vim tips leader.html",
    "title": "vim tips - leader",
    "section": "",
    "text": "Dans Vim, on peut changer les raccourcis pour absolument toutes les touches.\nJustement, un des raccourcis que l’on peut changer, c’est <leader>.\nQuand il s’agit de <space> (touche espace), <tab>, <cr> (carriage return, pour la touche entrée), on arrive à deviner. Mais pour <leader>, c’est plus difficile.\nEn fait, <leader> peut être n’importe quel raccourci que vous choisissez ! Quand vous créez un raccourci, <leader> sera remplacé par la valeur dans la variable g:mapleader.\nCela peut être intéressant :"
  },
  {
    "objectID": "posts/informatique/vim tips leader.html#changer-la-touche-assignée",
    "href": "posts/informatique/vim tips leader.html#changer-la-touche-assignée",
    "title": "vim tips - leader",
    "section": "Changer la touche assignée",
    "text": "Changer la touche assignée\nComme je l’ai dit plus haut, <leader> est défini par la variable g:mapleader\nPar exemple, si on souhaite utiliser la touche , pour leader :\nlet g:mapleader = \",\"\nSi on souhaite utiliser une touche qui est représentée entre <...>, comme la touche espace (<space>), il ne faut pas oublier le \\ avant le nom de la touche :\nlet g:mapleader = \"\\<space>\"\nSi vous oubliez le \\, il faudra taper toutes les touches : <, s, p, a, c, e, > pour déclancher <leader>"
  },
  {
    "objectID": "posts/informatique/vim tips leader.html#cas-dutilisation",
    "href": "posts/informatique/vim tips leader.html#cas-dutilisation",
    "title": "vim tips - leader",
    "section": "Cas d’utilisation",
    "text": "Cas d’utilisation\nUn des usages principaux de <leader> est comme préfixe (d’où le nom, leader, en anglais).\nPar préfixe, je veux dire une touche qui est au début de plein de raccourcis. C’est utile car Vim assigne déjà beaucoup de raccourcis, et donc ne laisse pas beaucoup de place pour que l’utilisateur définisse les siens. C’est pour cette raison que <leader> est utile : vous pouvez faire commencer plein de vos raccourcis par leader. Par exemple, j’ai défini les raccourcis <leader>j, <leader>k, <leader>m, <leader>ul…\n\nExemples d’utilisation\nVoici quelques exemples d’utilisation :\n\n<leader>m pour :make<cr>, si vous utilisez des makefiles\n<leader>k pour sauvegarder (c’est bizarre mais c’est ce que j’utilise)\n<leader>w ou bien <leader>q pour <c-w>, afin d’éviter la touche contrôle quand on manipule les fenêtres\n<leader>t pour :tabnew<cr> (créer un nouvel onglet)\n<leader>! pour :term ++curwin (ouvrir un terminal dans la fenêtre actuelle)\n\n     \n\nMon .vimrc est disponible ici : github.com/OsKaR31415/config avec le reste de ma configuration."
  },
  {
    "objectID": "posts/informatique/algo avancee structures de donnees.html",
    "href": "posts/informatique/algo avancee structures de donnees.html",
    "title": "Structures de données",
    "section": "",
    "text": "structures dynamiques\nstructures récursives"
  },
  {
    "objectID": "posts/informatique/algo avancee structures recursives.html",
    "href": "posts/informatique/algo avancee structures recursives.html",
    "title": "Structures de données récursives",
    "section": "",
    "text": "Définition\n\n\n\nUne structure récursive (ou auto-référente) est une structure qui fait référence à une structure du même type dans sa définition."
  },
  {
    "objectID": "posts/informatique/algo avancee structures recursives.html#exemples",
    "href": "posts/informatique/algo avancee structures recursives.html#exemples",
    "title": "Structures de données récursives",
    "section": "Exemples",
    "text": "Exemples\n\nlistes chaînées"
  },
  {
    "objectID": "posts/informatique/Le langage APL.html",
    "href": "posts/informatique/Le langage APL.html",
    "title": "Le langage APL",
    "section": "",
    "text": "APL est mon langage de programmation préféré, parce qu’il est assez mathématique, très agréable à utiliser, et qu’il change vraiment votre façon d’approcher les problèmes (comme Alan Perlis l’a dit : “A language that doesn’t affect the way you think about programming, is not worth knowing.”). Ce langage à apporté beaucoup de concepts en programmation qui sont très intéressants. Notamment, son créateur, Kenneth Iverson, à obtenu le prix Turing en 1979, pour ses travaux sur la notation mathématique, qui ont mené a la création du langage APL, pour l’utilisation éducative d’APL, et pour sa recherche sur la théorie et la pratique des langages.\nAPL signifie “A Programming Language”, et il à été créé en 1962 (ou un peu plus tard selon comment on compte), c’est-à-dire avant le C, et 4 ans après le LISP. Pourtant, même les premières versions intègrent des concepts qui sont toujours novateurs et très intéressants (et, bien sûr, de nombreux dialectes et dérivés ont émergés depuis).\nLa plupart des langages ou librairies qui manipulent des tableaux généralisés sont très inspirés par APL (on les appelle parfois des “Iverson ghosts”), notamment numpy (on retrouve par exemple iota dans beaucoup de langages, pour générer les nombres de 1 à n).\nLes principaux avantages d’APL sont :\n\nle paradigme “programmation array”\n\nles opérations sont généralisées le plus possible sur les tableaux (donc faire une addition de tableaux est comme faire une addition de nombres)\n\nla programmation avec des primitives\n\ncela permet de combiner des fonctions de façon très riche, et assez facilement\nc’est une façon de penser que j’adore : on a beaucoup moins de travail de traduction pour l’ordinateur à faire : pas de boucles, rarement des conditions explicites, et plutôt des opération que l’on applique de différentes manières sur des listes ou tableaux\n\nEncore une fois, commme Alan Perlis l’a dit : “A programming language is low level when its programs require attention to the irrelevant.”\n\n\nL’utilisation de symboles\n\nchaque primitive est représentée par un symbole, ce qui évite d’avoir du code illisible comme quand on utilise numpy\n\nLes Dfns\n\nAPL permet de définir des fonction anonymes assez puissantes\nelles incluent la possibilité de faire de la récursion anonyme, ce qui est incroyable\n\nLa concision\n\nAPL est très concis (par exemple, voici le code pour le jeu de la vie : life ← {⊃1 ⍵ ∨.∧ 3 4 = +/ +/ ¯1 0 1 ∘.⊖ ¯1 0 1 ⌽¨ ⊂⍵})\n\nla facilité d’apprentissage\n\ncomme les primitives sont assez simples à apprendre, et pourtant très riches, on arrive rapidement à faire beaucoup de choses\nil n’y a qu’un nombre assez petit de primitives, plus quelques variables et fonctions système\n\nla notation comme outils pour la pensée\n\nIverson à notamment créé un concept (et écrit un papier pour l’expliciter en APL) : “Notation as a tool of thought” (https://www.eecg.utoronto.ca/~jzhu/csc326/readings/iverson.pdf)\nCela inclut notamment des “design patterns for a programming language” :\n\nEase of expressing constructs arising in problems.\n\nprimitives plutôt que boucles ou concepts bas niveau\nsymboles pour les écrire facilement\n\nSuggestivity\n\ncomme “serendipity”, le fait de permettre la découverte de nouvelles choses en les suggérant\nles symboles et les façons riches de les combiner permettent des manipulations symboliques qui font que l’on découvre de nouvelles façons d’exprimer la même chose assez facilement\ncela fait que golfer un code APL (le rendre le plus court possible) revient souvent à le simplifier (contrairement à beaucoup d’autres langages où il est très facile de trop golfer, et que tout devienne illisible).\n\nAbility to subordinate detail\n\nne surtout pas confondre avec “ability to hide detail” : les fonctions font cela dans tous les langages\nplutôt que de cacher les détails dans une fonction à un autre endroit, il est plus pratique de mettre les détails à un endroit du programme où on les voit mais où on comprends qu’ils sont subordonnés\nLa syntaxe APL (qui fonctionne de droite à gauche) permet de faire cela très facilement\npar exemple, le calcul de la moyenne d’une liste est +/÷≢. Il est plus pratique d’intégrer ce morceau de code directement dans notre code plus grand, plutôt que de définir une fonction mean ou average, qu’il faudra de toute façon consulter pour connaître les détails de son fonctionnement\n\nEconomy\n\nles primitives sont représentées par un seul symbole, et les symboles sont même souvent polysémiques selon leur nombre d’arguments\npar exemple, ⌈ est le plafond quand ses arguments sont seulement à droite, et le maximum de ses deux arguments quand l’un est à droite, l’autre à gauche (ce qui fait que la réduction par ⌈, notée ⌈/ donne le maximum d’une liste)\n\nAmenability to formal proofs\n\naujourd’hui, on je cherche plus nécessairement à avoir des programmes dont on démontre formellement qu’ils fonctionnent (on utilise plutôt une approche empirique, avec des tests), mais le fait qu’APL soit proche de la notation mathématique fait que les démonstrations se font assez bien.\n\n\n\n\nDe nombreux dialectes d’APL sont apparus depuis sa création, notamment le J, qui n’utilise que des symboles ASCII (mais parfois deux symboles pour une seule primitive), et qui à apporté les combinateurs (des fonctions qui combine des fonctions de façon assez riches) et les trains (ce qui permet d’écrire la moyenne littéralement comme “somme divisée par longueur” : +/ ÷ ≢). Plus récemment, le BQN est apparu, qui est plus fonctionnel, et qui apporte des primitives différentes, ainsi que des symboles parfois un peu mieux choisis.\nAPL est vraiment un langage très particulier, la quasi totalité des gens qui l’apprennent adorent programmer avec, car il est très agréable à utiliser, mais il faut vraiment sortir de la façon “habituelle” de coder : il faut accepter que les symboles sont plus lisibles que des noms, que faire une longue ligne est plus lisible que de séparer le code en fonctions etc…\n\n\n\n\n\n\nIntroduction au langage APL\n\n\n\nJ’ai filmé 4 vidéos qui présentent quelques bases du langage APL sur un exemple simple : comment calculer des triplets pythagoriciens.\nVoir a playlist complète\n\nVidéo 1\nVidéo 2\nVidéo 3\nVidéo 4"
  },
  {
    "objectID": "posts/informatique/terminal btop.html",
    "href": "posts/informatique/terminal btop.html",
    "title": "terminal - btop : statistiques des processus",
    "section": "",
    "text": "btop est un utilitaire pour visualiser les processus actifs sur votre ordinateur, et les statistiques comme la quantité d’entrée/sortie en mémoire ou réseau.\nDépôt github de btop : aristocratos/btop"
  },
  {
    "objectID": "posts/informatique/terminal btop.html#htop",
    "href": "posts/informatique/terminal btop.html#htop",
    "title": "terminal - btop : statistiques des processus",
    "section": "htop",
    "text": "htop\nUn autre utilitaire très connu est htop, qui est une version plus jolie et utilisable de top, qui permet de chercher et filtrer les processus selon leur nom.\nhtop est beaucoup plus agréable à utiliser que top, avec des raccourcis plus intuitifs, des boutons cliquables (oui, c’est possible sur un terminal), et une interface plus agréable.\nVoici à quoi ressemble htop :"
  },
  {
    "objectID": "posts/informatique/terminal btop.html#btop",
    "href": "posts/informatique/terminal btop.html#btop",
    "title": "terminal - btop : statistiques des processus",
    "section": "btop",
    "text": "btop\nbtop est un autre utilitaire du même type, mais il a quelques avantages :\n\nil est plus intuitif\n\nles raccourcis clavier sont affichés\nle menu d’options est bien fait (plus simple à utiliser que celui de htop)\n\nil est plus joli\nil permet de voir plus de statistiques\n\n\nLes raccourcis claviers sont montrés par la lettre en rouge dans leur nom (comme m pour aller dans le menu), et chaque fenêtre peut être affichée/masquée en appuyant sur le chiffre qui lui correspond (de 1 à 4)."
  },
  {
    "objectID": "posts/informatique/python convertir une liste en table markdown.html",
    "href": "posts/informatique/python convertir une liste en table markdown.html",
    "title": "convertir des listes python en tables markdown",
    "section": "",
    "text": "La syntaxe markdown est très pratique, car elle est légère, lisible, et qu’elle peut être facilement exportée dans de nombreux autre formats (notamment via pandoc).\nCertains dialectes du markdown (des flavours) intègrent la possibilité de faire des tableaux. Cela permet donc d’intégrer des données dans un document.\nCe script vous permet de transformer des listes python en tables markdown, pour intégrer les résultats d’un calcul dans un document markdown :"
  },
  {
    "objectID": "posts/informatique/python convertir une liste en table markdown.html#exemples",
    "href": "posts/informatique/python convertir une liste en table markdown.html#exemples",
    "title": "convertir des listes python en tables markdown",
    "section": "Exemples",
    "text": "Exemples\n\nfrom math import pi\n\nT = [[\"colonne\", \"colonne 2\", \"colonne avec un nom super long\"],\n     [1, 42, \"contenu\"],\n     [\"super\", \"cool\", 73],\n     [\"contenu assez long\", pi, \"valeur\"]]\n\nprint(make_markdown_table(T))\n\nprint(\"\\nAlignée à gauche\")\nprint(make_markdown_table(T, alignement='gauche'))\n\nprint(\"\\nAlignée au centre\")\nprint(make_markdown_table(T, alignement='centre'))\n\nprint(\"\\nAlignée à droite\")\nprint(make_markdown_table(T, alignement='droite'))\n\n|      colonne       |     colonne 2     | colonne avec un nom super long |\n| ------------------ | ----------------- | ------------------------------ |\n|         1          |         42        |            contenu             |\n|       super        |        cool       |               73               |\n| contenu assez long | 3.141592653589793 |             valeur             |\n\nAlignée à gauche\n|      colonne       |     colonne 2     | colonne avec un nom super long |\n|:------------------ |:----------------- |:------------------------------ |\n|         1          |         42        |            contenu             |\n|       super        |        cool       |               73               |\n| contenu assez long | 3.141592653589793 |             valeur             |\n\nAlignée au centre\n|      colonne       |     colonne 2     | colonne avec un nom super long |\n|:------------------:|:-----------------:|:------------------------------:|\n|         1          |         42        |            contenu             |\n|       super        |        cool       |               73               |\n| contenu assez long | 3.141592653589793 |             valeur             |\n\nAlignée à droite\n|      colonne       |     colonne 2     | colonne avec un nom super long |\n| ------------------:| -----------------:| ------------------------------:|\n|         1          |         42        |            contenu             |\n|       super        |        cool       |               73               |\n| contenu assez long | 3.141592653589793 |             valeur             |"
  },
  {
    "objectID": "posts/informatique/algo avancee correction controle 1.html",
    "href": "posts/informatique/algo avancee correction controle 1.html",
    "title": "algo avancee correction controle",
    "section": "",
    "text": "Implémentation d’une liste chaînée\n\n\n\n\n\n\nclass Node:\n    def __init__ (self, value, next=None):\n        self.valeur = value\n        self.suivant = next\n\n    def __str__ (self):\n        return f\"({', '.join(map(str, self.to_list()))})\"\n\n    def to_list(self) -> list:\n        if self.suivant is None:\n            return [self.valeur]\n        return [self.valeur] + self.suivant.to_list()"
  },
  {
    "objectID": "posts/informatique/algo avancee correction controle 1.html#genalea",
    "href": "posts/informatique/algo avancee correction controle 1.html#genalea",
    "title": "algo avancee correction controle",
    "section": "1. genAlea",
    "text": "1. genAlea\n\nfrom random import randint\n\ndef genAlea(nb_val: int) -> Node:\n    \"\"\"Retourner une liste chaînée de nbVal entiers aléatoires entre 1 et 100.\n    Args:\n        nb_val (int): Le nombre d'entiers à générer\n    Returns:\n        Node: La liste de nb_val\n    \"\"\"\n    res = None\n    for _ in range(nb_val):\n        res = Node(randint(1, 100), res)\n    return res\n\nprint(\"12 nombres aléatoires :\", genAlea(12))\n\n12 nombres aléatoires : (18, 65, 41, 49, 7, 26, 75, 64, 25, 53, 46, 1)"
  },
  {
    "objectID": "posts/informatique/algo avancee correction controle 1.html#comptesup",
    "href": "posts/informatique/algo avancee correction controle 1.html#comptesup",
    "title": "algo avancee correction controle",
    "section": "2. compteSup",
    "text": "2. compteSup\n\ndef compteSup(L: Node, seuil) -> int:\n    \"\"\"Retourne le nombre de valeurs de L strictement supérieures à seuil.\n    Args:\n        L (Node): La liste chaînée.\n        seuil (comparable): La valeur de seuil (on compte les valeurs strictement supérieures au seuil).\n    Returns:\n        int: Le nombre de valeurs strictement supérieurs au seuil.\n    \"\"\"\n    nb_vals_sup = 0\n    while L is not None:\n        if L.valeur > seuil:\n            nb_vals_sup += 1\n        L = L.suivant\n    return nb_vals_sup\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9, Node(2)))))))\nseuil = 4\nprint(L, \"contient\", compteSup(L, seuil), \"valeurs strictement supérieures à\", seuil)\n\n(3, 1, 4, 1, 5, 9, 2) contient 2 valeurs strictement supérieures à 4"
  },
  {
    "objectID": "posts/informatique/algo avancee correction controle 1.html#dansintervalle-récursivement",
    "href": "posts/informatique/algo avancee correction controle 1.html#dansintervalle-récursivement",
    "title": "algo avancee correction controle",
    "section": "3. dansIntervalle récursivement",
    "text": "3. dansIntervalle récursivement\n\ndef dansIntervalle(L: Node, a, b) -> Node:\n    \"\"\"Créer une nouvelle liste à partir de L en ne gardant que les éléments dans l'intervalle [a, b].\n    Args:\n        L (Node): La liste chaînée de départ.\n        a (comparable): Le minimum de l'intervalle\n        b (comparable): Le maximum de l'intervalle\n    Returns:\n        Node: Une nouvelle liste pour laquelle on a gardé seulement les élément qui sont dans l'intervalle [a, b].\n    \"\"\"\n    if a > b:\n        raise ValueError(\"a doit être inférieur ou égal à b.\")\n    ##### ajouter/enlever un # devant la ligne suivante pour changer d'implémentation #####\n    if L is None: return None\n    if a <= L.valeur <= b:\n        # on garde le node actuel\n        return Node(L.valeur, dansIntervalle(L.suivant, a, b))\n    return dansIntervalle(L.suivant, a, b)\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9, Node(2, Node(6, Node(5, Node(3, Node(5, Node(8, Node(9, Node(7, Node(9, Node(3, Node(2, Node(3))))))))))))))))))\nprint(dansIntervalle(L, 2, 4))\n\n(3, 4, 2, 3, 3, 2, 3)"
  },
  {
    "objectID": "posts/informatique/algo avancee correction controle 1.html#dansintervalle-avec-un-itérateur-fonctionnel",
    "href": "posts/informatique/algo avancee correction controle 1.html#dansintervalle-avec-un-itérateur-fonctionnel",
    "title": "algo avancee correction controle",
    "section": "4. dansIntervalle avec un itérateur fonctionnel",
    "text": "4. dansIntervalle avec un itérateur fonctionnel\n\n\n\n\n\n\nImplémentation de Lfilter\n\n\n\n\n\n\ndef Lfilter(L : Node, f):\n    \"\"\"Filtrer les valeurs de L selon le prédicat f.\n    On garde seulement les valeurs de les pour lesquelles\n    f(valeur) == True.\n    Args:\n        L (Node): La liste de départ.\n        f (fonction): Le prédicat (fonction qui renvoie True\n                      ou False).\n    Returns:\n        Node: La nouvelle liste contenant seulement les\n              valeurs de L pour lesquelles f(valeur) == True\n              (on conserve l'ordre).\n    \"\"\"\n    if L is None:\n        return None\n    p = L\n    while p is not None and not f(p.valeur):\n        p = p.suivant\n    if p is None:\n        return None\n\n    res = Node(p.valeur)\n    w = res\n    while p.suivant is not None:\n        p = p.suivant\n        if f(p.valeur):\n            w.suivant = Node(p.valeur)\n            w = w.suivant\n    return res\n\n\n\n\n\ndef dansIntervalle(L: Node, a, b) -> Node:\n    \"\"\"Créer une nouvelle liste à partir de L en ne gardant que les éléments dans l'intervalle [a, b].\n    Args:\n        L (Node): La liste chaînée de départ.\n        a (comparable): Le minimum de l'intervalle\n        b (comparable): Le maximum de l'intervalle\n    Returns:\n        Node: Une nouvelle liste pour laquelle on a gardé seulement les élément qui sont dans l'intervalle [a, b].\n    \"\"\"\n    if a > b:\n        raise ValueError(\"a doit être inférieur ou égal à b.\")\n    # avec un itérateur fonctionnel\n    return Lfilter(L, lambda x: a <= x <= b)\n\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9, Node(2, Node(6, Node(5, Node(3, Node(5, Node(8, Node(9, Node(7, Node(9, Node(3, Node(2, Node(3))))))))))))))))))\nprint(dansIntervalle(L, 2, 4))\n\n(3, 4, 2, 3, 3, 2, 3)"
  },
  {
    "objectID": "posts/informatique/algo avancee correction controle 1.html#genrandom",
    "href": "posts/informatique/algo avancee correction controle 1.html#genrandom",
    "title": "algo avancee correction controle",
    "section": "1. genRandom",
    "text": "1. genRandom\n\ndef genRandom(nbVal: int) -> Node:\n    \"\"\"Créer une liste de nbVal nombres aléatoires entre 0 et 20\n    Args:\n        nbVal (int): Le nombre de nombres aléatoires à générer.\n    Returns:\n        Node: Une liste chaînée qui contient `nbVal` nombre\n              aléatoires entre 0 et 20.\n    \"\"\"\n    if nbVal <= 0:\n        return None\n    return Node(randint(0, 20), genRandom(nbVal - 1))\n\nL = genRandom(10)\nprint(L)\n\n(18, 3, 20, 5, 11, 14, 14, 15, 16, 6)"
  },
  {
    "objectID": "posts/informatique/algo avancee correction controle 1.html#compteinf",
    "href": "posts/informatique/algo avancee correction controle 1.html#compteinf",
    "title": "algo avancee correction controle",
    "section": "2. compteInf",
    "text": "2. compteInf\n\ndef compteInf(L: Node, seuil) -> int:\n    \"\"\"Compter le nombre de valeurs strictement inférieures à `seuil` dans L.\n    Args:\n        L (Node): La liste dans laquelle on compte.\n        seuil: La valeur utilisée pour les comparaisons.\n    Returns:\n        int: Le nombre de valeurs dans `L` qui sont\n             strictement inférieures à `seuil`.\n    \"\"\"\n    res = 0\n    while L is not None:\n        if L.valeur < seuil:\n            res += 1\n        L = L.suivant\n    return res\n\nprint(compteInf(L, 10))\n\n3"
  },
  {
    "objectID": "posts/informatique/algo avancee correction controle 1.html#horsintervalle-récursivement",
    "href": "posts/informatique/algo avancee correction controle 1.html#horsintervalle-récursivement",
    "title": "algo avancee correction controle",
    "section": "3. horsIntervalle récursivement",
    "text": "3. horsIntervalle récursivement\n\ndef horsIntervalle(L: Node, a, b) -> Node:\n    \"\"\"Retirer les éléments de L qui sont dans [a, b].\n    Args:\n        L (Node): La liste que l'on veut filtrer.\n        a: La valeur minimale de l'intervalle exclue.\n        b: La valeur maximale de l'intervalle exclue.\n    Returns:\n        Node: Une nouvelle liste qui est L sans les élément\n              de L qui sont compris entre a et b inclus.\n    \"\"\"\n    if a > b or L is None:\n        return None\n    # Si la valeur dépasse en dessous de a ou au dessus de b\n    if L.valeur < a or L.valeur > b :\n        # on garde la valeur dan la nouvelle liste\n        return Node(L.valeur, horsIntervalle(L.suivant, a, b))\n    # sinon on no garde pas la valeur\n    return horsIntervalle(L.suivant, a, b)\n\nprint(horsIntervalle(L, 5, 10))\n\n(18, 3, 20, 11, 14, 14, 15, 16)"
  },
  {
    "objectID": "posts/informatique/algo avancee correction controle 1.html#horsintervallefonc-avec-un-itérateur-fonctionnel",
    "href": "posts/informatique/algo avancee correction controle 1.html#horsintervallefonc-avec-un-itérateur-fonctionnel",
    "title": "algo avancee correction controle",
    "section": "4. horsIntervalleFonc avec un itérateur fonctionnel",
    "text": "4. horsIntervalleFonc avec un itérateur fonctionnel\n\ndef horsIntervalleFonc(L: Node, a, b) -> Node:\n    \"\"\"Retirer les éléments de L qui sont dans [a, b].\n    Args:\n        L (Node): La liste que l'on veut filtrer.\n        a: La valeur minimale de l'intervalle exclue.\n        b: La valeur maximale de l'intervalle exclue.\n    Returns:\n        Node: Une nouvelle liste qui est L sans les élément\n              de L qui sont compris entre a et b inclus.\n    \"\"\"\n    if a > b:\n        raise ValueError(\"a doit être inférieur ou égal à b.\")\n    return Lfilter(L, lambda x: x < a or x > b)\n\nprint(horsIntervalleFonc(L, 5, 10))\n\n(18, 3, 20, 11, 14, 14, 15, 16)"
  },
  {
    "objectID": "posts/informatique/algo avancee structures dynamiques.html",
    "href": "posts/informatique/algo avancee structures dynamiques.html",
    "title": "Algorithmique : Structures dynamiques",
    "section": "",
    "text": "on a besoin de représenter des objets de taille inconnue, de taille variable\n\n\n\n\nlistes chaînées"
  },
  {
    "objectID": "posts/welcome/bienvenue sur mon blog.html",
    "href": "posts/welcome/bienvenue sur mon blog.html",
    "title": "Bienvenue sur mon blog",
    "section": "",
    "text": "J’ai enfin pris le temps de créer mon blog !\nIl est fait avec quarto, qui permet de générer des pages à partir de markdown, et avec des inclusions de code (style jupyter notebook) exécutées quand on recharge le blog.\nBien sûr, il y à aussi toutes les fonctionnalités de base du markdown (sections, références, \\(\\LaTeX\\)…) et quelques fonctionnalités supplémentaires intéressantes."
  },
  {
    "objectID": "posts/welcome/Pourquoi ce blog.html",
    "href": "posts/welcome/Pourquoi ce blog.html",
    "title": "Pourquoi ce blog ?",
    "section": "",
    "text": "Ce blog me permettra de partager des explications sur certains sujets, et des idées personnelles.\n\nDes explications sur divers concepts de mathématiques ou d’informatique (pour aider les gens que je connais)\nDes réflexions que je souhaite partager\nN’importe quoi que j’ai découvert et que je trouve intéressant\n\n\nLe nom du blog\nLe Blog s’appelle OSK42, à la fois en référence au nombre 42, la réponse à la “grande question sur la vie, l’univers et le reste”, et car OSK42 est une écriture de OSKAR (mon pseudo) en leet speak"
  },
  {
    "objectID": "posts/maths/arrangements avec répétitions.html",
    "href": "posts/maths/arrangements avec répétitions.html",
    "title": "arrangements avec répétitions",
    "section": "",
    "text": "Définition\n\n\n\n\\(\\mathcal{A}_{n}^{k} = n^{k}\\)\nLes arrangements avec répétitions dans \\(n\\) de \\(k\\) sont le nombre de \\(k\\)-uplets d’éléments d’un ensemble à \\(n\\) éléments.\nC’est donc le nombre de possibilités de mettre \\(n\\) types d’objets dans \\(k\\) emplacements.\n\n\n\nInterprétation\n\n\n\n\n\n\nExemples\n\n\n\n\n\nVoici quelques questions dont la réponse passe par un arrangement avec répétitions :\n\nle langage toki pona possède 120 mots. Combien peut-on faire de phrases de 5 mots en toki pona ?\n\n\\(\\mathcal{A}_{120}^{5} = 120^{5} = 24\\,883\\,200\\,000\\), soit ving-quatre milliards huit-cent quatre-vingt-trois millions deux-cent mille phrases différents\n\nCombien de codes PIN à 4 chiffres peut-on faire ?\n\nArrangements avec répétitions de 4 chiffres parmi les 10 existants, soit \\(\\mathcal{A}_{10}^{4} = 10^{4} = 10\\,000\\) codes possibles\n\nNote : cela veut dire que, avec un ordinateur actuel, craquer un code à 4 chiffres est instantané (donc si vous vous faîtes voler un ordinateur avec un tel code, il ne sera pas protégé)\n\n\n\n\n\n\n\n\nFormule\nOn peut mettre l’un des \\(n\\) objets dans les \\(k\\) positions :\n\n\\(n\\) possibilités dans la \\(1^{ère}\\) position\n\\(n\\) possibilités dans la \\(2^{ème}\\)\n\\(\\vdots\\)\n\\(n\\) possibilités dans la \\(k^{ème}\\) position\n\nDonc, en tout, \\(\\underbrace{n\\times n\\times \\cdots \\times n}_{k \\text{ répétitions}} = n^{k}\\)\nOn a donc bien : \\(\\mathcal{A}_{n}^{k} = n^{k}\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html",
    "href": "posts/maths/formulaire d'analyse.html",
    "title": "formulaire d’analyse",
    "section": "",
    "text": "Voici une liste des formules importantes en analyse"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#identités-remarquables",
    "href": "posts/maths/formulaire d'analyse.html#identités-remarquables",
    "title": "formulaire d’analyse",
    "section": "0.1 Identités remarquables",
    "text": "0.1 Identités remarquables\n\\((a + b)^{2} = a^{2} + 2ab + b^{2}\\)\n\\((a - b)^{2} = a^{2} - 2ab + b^{2}\\)\n\\((a + b)(a - b) = a^{2} - b^{2}\\)\n\\((a + b)^{3} = a^{3} + 3a^{2}b + 3ab^{2} + b^{3}\\)\n\\((a - b)^{3} = a^{3} - 3a^{2}b + 3ab^{2} - b^{3}\\)\n\\(a^{3} - b^{3} = (a - b)\\left( a^{2} + ab + b^{2} \\right)\\)\n\\(a^{3} + b^{3} = (a + b)\\left( a^{2} - ab + b^{2} \\right)\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#suites-arithmétiques",
    "href": "posts/maths/formulaire d'analyse.html#suites-arithmétiques",
    "title": "formulaire d’analyse",
    "section": "1.1 Suites arithmétiques",
    "text": "1.1 Suites arithmétiques\nTermes de la suite (\\(r\\) désigne la raison):\n\\(u_{n+1} - u_{n} = r\\)\n\\(u_{n} = u_{0} + nr\\)\n\\(u_{n} = u_{p} + (n-p)r\\)\nSomme des termes :\n\\(\\displaystyle S_{n} = \\sum_{k=0}^{n}u_{k} = \\dfrac{(n+1)(u_{0}+u_{n})}{2}\\)\nCas général avec \\(n_{1} \\leq n_{2}\\) :\n\\(\\displaystyle S' = \\sum_{k = n_{1}}^{n_{2}}u_{k} = \\frac{(nombre\\ de\\ termes)(premier\\ terme + dernier\\ terme)}{2}\\)\nCas particulier :\n\\(\\displaystyle 1 + 2 + 3\\ \\cdots + (n - 1) + n = \\frac{n(n + 1)}{2}\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#suites-géométriques",
    "href": "posts/maths/formulaire d'analyse.html#suites-géométriques",
    "title": "formulaire d’analyse",
    "section": "1.2 Suites géométriques",
    "text": "1.2 Suites géométriques\nOn suppose que la suite est non nulle. Termes de la suite ((q) désigne la raison) :\n\\(\\dfrac{u_{n+1}}{u_{n}} = q\\)\n\\(u_{n} = u_{0} \\times q^{n}\\)\n\\(u_{n} = u_{p}\\times q^{n-p}\\)\nSomme des termes :\n\\(S_{n} = \\sum\\limits_{k=0}^{n}u_{k}\\)\n\nSi \\(q \\neq 1\\) : \\(S_{n} = u_{0}\\times \\frac{1-q^{n+1}}{1-q}\\)\nSi \\(q=1\\) : \\(S_{n}=u_{0}(n+1)\\)\n\nCas général avec \\(n_{1} \\leq n_{2}\\) : \\(S'_{n} = \\sum\\limits_{k=0}^{n}u_{k}\\)\n\nSi \\(q \\neq 1\\) : \\(\\displaystyle S'_{n} = (\\text{premier terme}) \\times \\frac{1- \\left( q^{\\text{nombre de termes}} \\right)}{1-q}\\)\nSi \\(q \\neq 1\\) : \\(\\displaystyle S'_{n} = (\\text{premier terme}) \\times \\frac{1- q ^{(\\text{nombre de termes})}}{1-q} = u_0 \\times \\frac{1-q^{n+1}}{1-q}\\)\nSi \\(q = 1\\) : \\(S'_{n} = (\\text{nombre de termes}) \\times (\\text{premier terme})\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#formules-générales",
    "href": "posts/maths/formulaire d'analyse.html#formules-générales",
    "title": "formulaire d’analyse",
    "section": "2.1 Formules générales",
    "text": "2.1 Formules générales\nDans ce qui suit, \\(u\\) et \\(v\\) désignent deus fonctions d’une variable réelle \\(x\\), et \\(k\\) une constante réelle.\n\\((u+v)' = u' + v'\\)\n\\((ku)' = ku'\\)\n\\((uv)' = u'v + uv'\\)\n\\(\\left( \\dfrac{u}{v} \\right)' = \\dfrac{u'v - uv'}{v^{2}}\\)\n\\((v\\circ u)' = u' \\times (v'\\circ u)\\)\n\\(\\displaystyle(u^{-1})' = \\dfrac{1}{u' \\circ u^{-1}}\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#fonctions-usuelles",
    "href": "posts/maths/formulaire d'analyse.html#fonctions-usuelles",
    "title": "formulaire d’analyse",
    "section": "2.2 Fonctions usuelles",
    "text": "2.2 Fonctions usuelles\n\n2.2.1 fonctions non composées\n\n\n\n\n\n\n\n\n\nFonction \\(f\\)\n\\(\\mathscr{D}_{f}\\)\nFonction dérivée \\(f'\\)\n\\(\\mathscr{D}_{f'}\\)\n\n\n\n\n\\(k\\)\n\\(\\mathbb{R}\\)\n0\n\\(\\mathbb{R}\\)\n\n\n\\(x\\)\n\\(\\mathbb{R}\\)\n\\(1\\)\n\\(\\mathbb{R}\\)\n\n\n\\(\\dfrac{1}{x}\\)\n\\(\\mathbb{R}^{*}\\)\n\\(-\\dfrac{1}{x^{2}}\\)\n\\(\\mathbb{R}^{*}\\)\n\n\n\\(\\sqrt{ x }\\)\n\\(\\mathbb{R}^{+}\\)\n\\(\\frac{1}{2\\sqrt{ x }}\\)\n\\(\\mathbb{R}^{+*}\\)\n\n\n\\(x^{n}\\) avec \\(n \\in\\mathbb{Z}\\)\n\\(\\mathbb{R}\\)\n\\(nx^{n-1}\\)\n\\(\\mathbb{R} \\text{ si } n \\geq 0, \\quad \\mathbb{R}^{*} \\text{ si } n < 0\\)\n\n\n\\(x^{\\alpha}\\) avec \\(\\alpha \\in\\mathbb{R}\\)\n\\(\\mathbb{R}^{+} \\text{ si } \\alpha \\geq 0, \\quad \\mathbb{R}^{+*} \\text{ si } \\alpha<0\\)\n\\(\\alpha x^{\\alpha-1}\\)\n\\(\\mathbb{R} \\text{ si } n \\geq 0, \\quad \\mathbb{R}^{*} \\text{ si } \\alpha < 1\\)\n\n\n\\(\\ln \\mid x \\mid\\)\n\\(\\mathbb{R}^{+*}\\)\n\\(\\dfrac{1}{x}\\)\n\\(\\mathbb{R}^{+*}\\)\n\n\n\\(\\exp x\\)\n\\(\\mathbb{R}\\)\n\\(\\exp x\\)\n\\(\\mathbb{R}\\)\n\n\n\\(\\sin x\\)\n\\(\\mathbb{R}\\)\n\\(\\cos x\\)\n\\(\\mathbb{R}\\)\n\n\n\\(\\cos x\\)\n\\(\\mathbb{R}\\)\n\\(-\\sin x\\)\n\\(\\mathbb{R}\\)\n\n\n\\(\\tan x\\)\n\\(\\mathbb{R} \\setminus \\left\\lbrace \\dfrac{\\pi}{2} + k\\pi \\right\\rbrace\\)\n\\(1+\\tan^2 x = \\dfrac{1}{\\cos^2 x}\\)\n\\(\\mathbb{R} \\setminus \\left\\lbrace \\dfrac{\\pi}{2} + k\\pi \\right\\rbrace\\)\n\n\n\\(\\mathrm{sh} x\\)\n\\(\\mathbb{R}\\)\n\\(\\mathrm{ch} x\\)\n\\(\\mathbb{R}\\)\n\n\n\\(\\mathrm{ch} x\\)\n\\(\\mathbb{R}\\)\n\\(\\mathrm{sh} x\\)\n\\(\\mathbb{R}\\)\n\n\n\\(\\mathrm{th} x\\)\n\\(\\mathbb{R}\\)\n\\(1-\\mathrm{th}^2 x = \\dfrac{1}{\\mathrm{ch}^2 x}\\)\n\\(\\mathbb{R}\\)\n\n\n\nLes dérivées des fonctions réciproques des fonctions trigonométriques et hyperboliques figurent dans la section “trigonométrie réciproque\n\n\n2.2.2 Fonctions composées\n\n\n\n\n\n\n\nforme de la fonction\nforme de la dérivée\n\n\n\n\n\\(\\dfrac{1}{u}\\)\n\\(-\\dfrac{u'}{u^2}\\)\n\n\n\\(\\sqrt{u}\\)\n\\(\\dfrac{u'}{2 \\sqrt{u}}\\)\n\n\n\\(u^{\\alpha}\\)\n\\(\\alpha u' u^{\\alpha - 1}\\)\n\n\n$u $\n\\(\\dfrac{u'}{u}\\)\n\n\n\\(\\exp u\\)\n\\(u' \\times \\exp u\\)\n\n\n\\(\\sin u\\)\n\\(u'\\times \\cos u\\)\n\n\n\\(\\cos u\\)\n\\(-u' \\times \\sin u\\)\n\n\n\\(\\tan u\\)\n\\(u' \\times (1+\\tan^2 u) = \\dfrac{u'}{\\cos^2 u}\\)\n\n\n\\(\\mathrm{sh} u\\)\n\\(u' \\times \\mathrm{ch} u\\)\n\n\n\\(\\mathrm{ch} u\\)\n\\(u' \\times \\mathrm{sh} u\\)\n\n\n\\(\\mathrm{th} u\\)\n\\(u' \\times (1-\\mathrm{th}^2 u) = \\dfrac{u'}{\\mathrm{ch}^2 u}\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#fonctions-trigonométriques",
    "href": "posts/maths/formulaire d'analyse.html#fonctions-trigonométriques",
    "title": "formulaire d’analyse",
    "section": "3.1 Fonctions trigonométriques",
    "text": "3.1 Fonctions trigonométriques\n\\(\\cos^2 x + \\sin^2 x = 1\\)\n\\(\\cos(a+b) = \\cos a \\cos b - \\sin a \\sin b\\)\n\\(\\cos(a-b) = \\cos a \\cos b + \\sin a \\sin b\\)\n\\(\\sin(a+b) = \\sin a\\cos b + \\sin b \\cos a\\)\n\\(\\sin(a-b) = \\sin a \\cos b - \\sin b \\cos a\\)\n\\(\\tan(a+b) = \\dfrac{\\tan a + \\tan b}{1-\\tan a \\tan b}\\)\n\\(\\tan(a-b) = \\dfrac{\\tan a - \\tan b}{1+\\tan a \\tan b}\\)\n\\(\\cos a \\cos b = \\dfrac{1}{2} \\big( \\cos(a+b)+\\cos(a-b) \\big)\\)\n\\(\\sin a\\sin b = \\dfrac{1}{2} \\big( \\cos(a-b) - \\cos(a+b) \\big)\\)\n\\(\\sin a \\cos b = \\dfrac12 \\big( \\sin(a+b) + \\sin(a-b) \\big)\\)\n\\(\\cos a + \\cos b = 2\\cos \\dfrac{(a+b)}{2}\\cos\\dfrac{(a-b)}{2}\\)\n\\(\\cos a - \\cos b = -2\\sin\\dfrac{a+b}{2}\\sin\\dfrac{a-b}{2}\\)\n\\(\\sin a + \\sin b = 2\\sin\\dfrac{a+b}{2}\\cos\\dfrac{a-b}{2}\\)\n\\(\\sin a - \\sin b = 2\\sin\\dfrac{a-b}{2} \\cos\\dfrac{a+b}{2}\\)\n\\(\\cos(2x) =\\cos ^{2}x-\\sin ^{2}x \\quad= 2\\cos ^{2}x-1 \\quad= 1-2\\sin ^{2}x \\quad= \\frac{1-\\tan ^{2}x}{1+\\tan ^{2}x}\\)\n\\(\\cos^2 x = \\dfrac{1+\\cos(2x)}{2}\\)\n\\(\\sin^2 x = \\dfrac{1-\\cos(2x)}{2}\\)\n\\(\\tan^2 x = \\dfrac{1-\\cos(2x)}{1+\\cos(2x)}\\)\n\\(\\sin(2x) = 2\\sin x\\cos x \\quad= 1+\\tan ^{2}x\\)\n\\(\\tan(2x) = \\dfrac{2\\tan x}{1 - \\tan^2 x}\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#fonctions-hyperboliques",
    "href": "posts/maths/formulaire d'analyse.html#fonctions-hyperboliques",
    "title": "formulaire d’analyse",
    "section": "3.2 Fonctions hyperboliques",
    "text": "3.2 Fonctions hyperboliques\n\\(\\mathrm{ch}^2 x - \\mathrm{sh}^2 x = 1\\)\n\\(\\mathrm{ch}(a+b) = \\mathrm{ch} (a) \\;\\mathrm{ch} (a) + \\mathrm{sh} a \\mathrm{sh} b\\)\n\\(\\mathrm{ch}(a-b) = \\mathrm{ch} (a)\\; \\mathrm{ch} (b) - \\mathrm{sh} a \\mathrm{sh} b\\)\n\\(\\mathrm{sh}(a+b) = \\mathrm{sh} (a)\\; \\mathrm{ch} (b) + \\mathrm{sh} (b)\\; \\mathrm{ch} (a)\\)\n\\(\\mathrm{sh}(a-b) = \\mathrm{sh} (a); \\mathrm{ch} (b) - \\mathrm{sh} (b) \\mathrm{ch} (a)\\)\n\\(\\mathrm{th}(a+b) = \\dfrac{\\mathrm{th} a + \\mathrm{th} b}{1 + \\mathrm{th} (a) \\mathrm{th} (b)}\\)\n\\(\\mathrm{th}(a-b) = \\dfrac{\\mathrm{th} a - \\mathrm{th} b}{1 - \\mathrm{th} (a) \\mathrm{th} (b)}\\)\n\\(\\mathrm{ch} (a) \\;\\mathrm{ch} (b) = \\dfrac12 \\big( \\mathrm{ch}(a+b) + \\mathrm{ch}(a-b) \\big)\\)\n\\(\\mathrm{sh} (a)\\; \\mathrm{sh} (b) = \\dfrac12 \\big( \\mathrm{ch}(a+b) - \\mathrm{ch}(a-b) \\big)\\)\n\\(\\mathrm{sh} (a)\\; \\mathrm{ch} (b) = \\dfrac12 \\big( \\mathrm{sh}(a+b) + \\mathrm{sh}(a-b) \\big)\\)\n\\(\\mathrm{ch} (a) + \\mathrm{ch} (b) = 2\\mathrm{ch} \\dfrac{a+b}{2} \\mathrm{ch} \\dfrac{a-b}{2}\\)\n\\(\\mathrm{ch} (a) - \\mathrm{ch} (a) = 2\\mathrm{sh} \\dfrac{a+b}{2}\\mathrm{sh}\\dfrac{a-b}{2}\\)\n\\(\\mathrm{sh} (a) + \\mathrm{sh} (b) = 2\\mathrm{sh} \\dfrac{a+b}{2}\\mathrm{ch}\\dfrac{a-b}{2}\\)\n\\(\\mathrm{sh} (a) - \\mathrm{sh} (b) = 2\\mathrm{sh}\\dfrac{a-b}{2} \\mathrm{ch}\\dfrac{a+b}{2}\\)\n\\(\\mathrm{ch}(2x) = \\mathrm{ch} ^{2}x + \\mathrm{sh} ^{2}x \\quad= 2\\mathrm{ch} ^{2}x - 1 \\quad= 1+2\\mathrm{sh} ^{2}x \\quad=\\frac{1+\\mathrm{th} ^{2}x}{1-\\mathrm{th} ^{2}x}\\)\n\\(\\mathrm{ch}^2 x = \\dfrac{1+\\mathrm{ch}(2x)}{2}\\)\n\\(\\mathrm{sh}^2 x = \\dfrac{\\mathrm{ch}(2x) - 1}{2}\\)\n\\(\\mathrm{th}^2 x = \\dfrac{\\mathrm{ch}(2x) - 1}{\\mathrm{ch}(2x) + 1}\\)\n\\(\\mathrm{sh}(2x) = 2\\mathrm{sh}(x) \\mathrm{ch}(x) \\quad= \\frac{2\\mathrm{th}(x)}{1-\\mathrm{th}^{2}(x)}\\)\n\\(\\mathrm{th}(2x) = \\dfrac{2\\mathrm{th} x}{1+\\mathrm{th}^2 x}\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#points-sur-le-cercle-trigonométrique",
    "href": "posts/maths/formulaire d'analyse.html#points-sur-le-cercle-trigonométrique",
    "title": "formulaire d’analyse",
    "section": "3.3 Points sur le cercle trigonométrique",
    "text": "3.3 Points sur le cercle trigonométrique\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(-x\\)\n\\(\\frac{\\pi}{2}+x\\)\n\\(\\frac{\\pi}{2}-x\\)\n\\(\\pi+x\\)\n\\(\\pi-x\\)\n\\(0\\)\n\\(\\frac{\\pi}{6}\\)\n\\(\\frac{\\pi}{4}\\)\n\\(\\frac{\\pi}{3}\\)\n\\(\\frac{\\pi}{2}\\)\n\n\n\n\n\\(\\sin\\)\n\\(-\\sin x\\)\n\\(\\cos x\\)\n\\(\\cos x\\)\n\\(-\\sin x\\)\n\\(\\sin x\\)\n\\(0\\)\n\\(\\frac{1}{2}\\)\n\\(\\frac{\\sqrt{ 2 }}{2}\\)\n\\(\\frac{\\sqrt{ 3 }}{2}\\)\n1\n\n\n\\(\\cos\\)\n\\(\\cos x\\)\n\\(-\\sin x\\)\n\\(\\sin x\\)\n\\(-\\cos x\\)\n\\(-\\cos x\\)\n\\(1\\)\n\\(\\frac{\\sqrt{ 3 }}{2}\\)\n\\(\\frac{\\sqrt{ 2 }}{2}\\)\n\\(\\frac{1}{2}\\)\n0\n\n\n\\(\\tan\\)\n\\(-\\tan x\\)\n\\(-\\frac{1}{\\tan x}\\)\n\\(\\frac{1}{\\tan x}\\)\n\\(\\tan x\\)\n\\(-\\tan x\\)\n\\(0\\)\n\\(\\frac{\\sqrt{ 3 }}{2}\\)\n\\(1\\)\n\\(\\sqrt{ 3 }\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#trigonométrie-réciproque",
    "href": "posts/maths/formulaire d'analyse.html#trigonométrie-réciproque",
    "title": "formulaire d’analyse",
    "section": "3.4 Trigonométrie réciproque",
    "text": "3.4 Trigonométrie réciproque\n\\(\\arcsin x + \\arccos x = \\dfrac{\\pi}{2}\\)\n\\(\\arctan x + \\arctan \\dfrac{1}{x} = \\text{sg}(x) \\times \\dfrac{\\pi}{2}\\) avec \\(\\mathrm{sg}(x) = 1 \\text{ si } x>0\\) et \\(\\mathrm{sg}(x) = -1 \\text{ si } x < 0\\)\n\\((\\arcsin x)' = \\dfrac{1}{\\sqrt{1-x^2}}\\)\n\\((\\arccos x)' = -\\dfrac{1}{\\sqrt{1-x^2}}\\)\n\\((\\arctan x)' = \\dfrac{1}{1+x^2}\\)\n\\((\\arcsin u)' = \\dfrac{u'}{\\sqrt{1-u^2}}\\)\n\\((\\arccos u)' = -\\dfrac{u'}{\\sqrt{1-u^2}}\\)\n\\((\\arctan u)' = \\dfrac{u'}{1+u^2}\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#trigonométrie-hyperbolique-réciproque",
    "href": "posts/maths/formulaire d'analyse.html#trigonométrie-hyperbolique-réciproque",
    "title": "formulaire d’analyse",
    "section": "3.5 Trigonométrie hyperbolique réciproque",
    "text": "3.5 Trigonométrie hyperbolique réciproque\n\\(\\arg\\mathrm{sh} x = \\ln \\left( x + \\sqrt{ 1+x^2 } \\right)\\)\n\\(\\arg\\mathrm{ch} x = \\ln \\left( x + \\sqrt{ 1 - x^2 } \\right)\\)\n\\(\\arg\\mathrm{th} x = \\dfrac12 \\ln \\left( \\dfrac{1+x}{1-x} \\right)\\)\n\\((\\arg\\mathrm{sh} x)' = \\dfrac{1}{\\sqrt{ x^2 + 1 }}\\)\n\\((\\arg\\mathrm{ch} x)' = \\dfrac{1}{\\sqrt{x^2 - 1}}\\)\n\\((\\arg\\mathrm{th} x)' = \\dfrac{1}{1-x^2}\\)\n\\((\\arg\\mathrm{sh} u)' = \\dfrac{u'}{\\sqrt{ u^2 + 1 }}\\)\n\\((\\arg\\mathrm{ch} u)' = \\dfrac{u'}{\\sqrt{ u^2 - 1}}\\)\n\\((\\arg\\mathrm{th} u)' = \\dfrac{u'}{1 - u^2}\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#comportement-à-linfini",
    "href": "posts/maths/formulaire d'analyse.html#comportement-à-linfini",
    "title": "formulaire d’analyse",
    "section": "4.1 Comportement à l’infini",
    "text": "4.1 Comportement à l’infini\n\\(\\displaystyle\\lim_{x\\to+\\infty} \\ln x = +\\infty\\)\n\\(\\displaystyle\\lim_{x\\to+\\infty}\\exp x = +\\infty\\)\n\\(\\displaystyle\\lim_{x\\to-\\infty}\\exp x = 0\\)\nSi \\(\\alpha > 0\\), \\(\\displaystyle\\lim_{x\\to+\\infty}x^{\\alpha} = +\\infty\\)\nSi \\(\\alpha < 0\\), \\(\\displaystyle\\lim_{x\\to+\\infty}x^{\\alpha} = 0\\)\nSi \\(\\alpha > 0\\), \\(\\displaystyle\\lim_{x\\to+\\infty}\\dfrac{\\exp x}{x^\\alpha} = \\lim_{x\\to+\\infty}\\dfrac{e^x}{x^\\alpha} = +\\infty\\)\nSi \\(\\alpha > 0\\), \\(\\displaystyle\\lim_{x\\to+\\infty}x^\\alpha\\times\\exp(-x) = \\lim_{x\\to+\\infty}x^\\alpha e^{-x} = 0\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#comportement-à-lorigine",
    "href": "posts/maths/formulaire d'analyse.html#comportement-à-lorigine",
    "title": "formulaire d’analyse",
    "section": "4.2 Comportement à l’origine",
    "text": "4.2 Comportement à l’origine\n\\(\\displaystyle\\lim_{x \\rightarrow 0} \\ln x = + \\infty\\)\nSi \\(\\alpha > 0\\), \\(\\displaystyle\\lim_{x \\rightarrow 0^+} x^\\alpha = +\\infty\\)\nSi \\(\\alpha < 0\\), \\(\\displaystyle\\lim_{x \\rightarrow 0^+} x^\\alpha = +\\infty\\)\nSi \\(\\alpha > 0\\), \\(\\displaystyle\\lim_{x \\rightarrow 0^+} \\left( x^\\alpha \\ln x \\right) = 0\\) propriété de croissance comparée\n\\(\\displaystyle \\lim_{x \\rightarrow 0} \\dfrac{\\ln (1+x)}{x} = 1\\)\n\\(\\displaystyle \\lim_{x \\to 0} \\dfrac{e^x - 1}{x} = 1\\)\n\\(\\displaystyle \\lim_{x \\rightarrow 0} \\dfrac{\\sin x}x = 1\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#intégration-par-parties",
    "href": "posts/maths/formulaire d'analyse.html#intégration-par-parties",
    "title": "formulaire d’analyse",
    "section": "5.1 Intégration par parties",
    "text": "5.1 Intégration par parties\n\\(\\displaystyle \\int_{a}^{b} f(x)g'(x) \\, dx = \\big[ f(x)g(x) \\big]_{a}^{b} - \\int_{a}^{b} f'(x)g(x) \\, dx\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#primitives-usuelles",
    "href": "posts/maths/formulaire d'analyse.html#primitives-usuelles",
    "title": "formulaire d’analyse",
    "section": "5.2 Primitives usuelles",
    "text": "5.2 Primitives usuelles\nSi \\(\\alpha \\neq -1\\), \\(\\displaystyle \\int x^\\alpha \\mathrm{d} x = \\dfrac{1}{\\alpha + 1}x^{\\alpha +1} + \\text{cte}\\)\n\\(\\displaystyle\\int \\dfrac{1}x \\mathrm{d} x = \\ln |x|+\\text{cte}\\)\n\\(\\displaystyle\\int \\dfrac{1}{x+\\alpha }\\mathrm{d} x = \\ln |x+\\alpha |+\\text{cte}\\)\n\\(\\displaystyle\\int e^x \\mathrm{d} x = e^x + \\text{cte}\\)\nSi \\(\\alpha > 0\\) et \\(\\alpha \\neq 1\\), \\(\\displaystyle\\int \\alpha^x \\mathrm{d} x= \\dfrac{1}{\\ln \\alpha }\\times \\alpha^x + \\text{cte}\\)\n\\(\\displaystyle\\int \\cos x \\mathrm{d} x = \\sin x + \\text{cte}\\)\n\\(\\displaystyle\\int \\sin x \\mathrm{d} x = -\\cos x + \\text{cte}\\)\nSi \\(\\alpha \\neq 0\\), \\(\\displaystyle\\int \\cos \\alpha x \\mathrm{d} x = \\dfrac{1}{\\alpha} \\sin \\alpha x + \\text{cte}\\)\nSi \\(\\alpha \\neq 0\\), \\(\\displaystyle\\int \\sin \\alpha x \\mathrm{d} x = \\dfrac{1}{\\alpha} \\cos \\alpha x + \\text{cte}\\)\n\\(\\displaystyle \\int \\dfrac{1}{\\cos ^2 x} \\mathrm{d} x = \\tan x + \\text{cte}\\)\n\\(\\displaystyle\\int 1 + \\tan ^2 x \\mathrm{d} x = \\tan x + \\text{cte}\\)\n\\(\\displaystyle\\int \\dfrac{1}{\\sin ^2 x} \\mathrm{d} x = -\\mathrm{cotan} x + \\text{cte} \\quad= -\\dfrac{1}{\\tan x} + \\text{cte}\\)\n\\(\\displaystyle\\int \\dfrac{1}{1+x^2} \\mathrm{d} x = \\arctan x + \\text{cte}\\)\n\\(\\displaystyle\\int \\mathrm{ch} x \\mathrm{d} x = \\mathrm{sh} x + \\text{cte}\\)\n\\(\\displaystyle\\int \\mathrm{sh} x \\mathrm{d} x = \\mathrm{ch} x + \\text{cte}\\)\n\\(\\displaystyle\\int \\dfrac{1}{\\mathrm{ch}^2 x} \\mathrm{d} x = \\mathrm{th} x + \\text{cte}\\)\n\\(\\displaystyle\\int \\dfrac{1}{\\mathrm{sh}^2 x} \\mathrm{d} x = \\dfrac{1}{\\mathrm{th} x} + \\text{cte}\\)"
  },
  {
    "objectID": "posts/maths/formulaire d'analyse.html#primitives-de-fonctions-composées",
    "href": "posts/maths/formulaire d'analyse.html#primitives-de-fonctions-composées",
    "title": "formulaire d’analyse",
    "section": "5.3 Primitives de fonctions composées",
    "text": "5.3 Primitives de fonctions composées\n\\(\\displaystyle\\int \\frac{u'(x)}{u(x)} \\, dx = \\ln(u) + \\text{cte}\\)"
  },
  {
    "objectID": "posts/maths/>>mathematiques.html",
    "href": "posts/maths/>>mathematiques.html",
    "title": "Mathématiques",
    "section": "",
    "text": "formulaire (liste de formules de base)"
  },
  {
    "objectID": "posts/maths/>>mathematiques.html#combinatoire",
    "href": "posts/maths/>>mathematiques.html#combinatoire",
    "title": "Mathématiques",
    "section": "Combinatoire",
    "text": "Combinatoire\n\n\\(\\mathscr{P}(E)\\) ensemble des parties d’un ensemble\n\\(A_{n}^{k}\\) arrangements\n\\(A_{n}^{k}\\) arrangements avec répétitions\n\\(\\displaystyle \\binom{k}{n}\\) combinaisons\n\\(\\Gamma _{n}^{k}\\) combinaisons avec répétitions"
  },
  {
    "objectID": "posts/maths/arrangements.html",
    "href": "posts/maths/arrangements.html",
    "title": "arrangements",
    "section": "",
    "text": "Définition\n\n\n\nOn définit \\(A_{n}^{k}\\) (lire “\\(A\\), \\(n\\), \\(k\\)”), les arrangements de \\(k\\) objets d’un ensemble de \\(n\\) objets, comme le nombre de \\(k-uplets\\) d’éléments d’un ensemble à \\(n\\) éléments.\nOn a : \\(\\displaystyle A_{n}^{k} = \\frac{n!}{(n-k)!}\\)\nNote : on dit aussi parfois “arrangements dans \\(n\\) de \\(k\\) éléments” pour \\(A_{n}^{k}\\)\nC’est le nombre de \\(k\\)-uplets d’éléments d’un ensemble à \\(n\\) éléments\n\n\n\nInterprétation\nOn peut interpréter \\(A_{n}^{k}\\) comme le nombre de façons de choisir \\(k\\) éléments dans un ensemble de \\(n\\) éléments, si l’ordre des éléments compte.\n\n\n\n\n\n\nExemples\n\n\n\n\n\nVoici quelques questions de combinatoire dont la réponse passe par des arrangements :\n\nCombien y a-t-il de nombres avec 3 chiffres distincts ?\n\nautrement dit : combien de façons de choisir 3 chiffres parmi les 10 qui existent (si l’ordre est important) ?\n\\(A_{10}^{3} = 720\\)\n\n\n\n\n\n\n\nFormule\nSi on choisit \\(k\\) éléments, et que l’ordre compte, alors :\n\npour le premier élément, on a \\(n\\) possibilités\npour le deuxième élément, on a \\(n - 1\\) possibilités, car on ne peut pas choisir deux fois le premier élément\npour le troisième, \\(n - 2\\) possibilités\npour le \\(4^{\\text{ème}}\\), \\(n-3\\) possibilités\n\\(\\vdots\\)\npour le \\(k-1^{\\text{ème}}\\), \\(n-k + 2\\) possibilités\npour le \\(k^{ème}\\) élément, \\(n - k + 1\\) possibilités\n\nDonc, en tout, on a \\(n \\times (n-1) \\times (n-2) \\times \\cdots \\times (n-k+1)\\) possibilités.\nOn peut exprimer cela comme le produit des nombres de \\(n-k+1\\) jusqu’à \\(n\\) : \\(\\prod\\limits_{i = n-k+1}^{n} i\\).\nPuisqu’on veut le produit jusqu’à \\(n\\) (donc \\(n!\\)), mais sans les nombres de \\(1\\) à \\(n-k\\) inclus (donc \\((n-k)!\\)), comme \\(\\dfrac{n!}{(n-k)!}\\)\nOn a donc bien la formule : \\(\\boxed{A_{n}^{k} = \\frac{n!}{(n-k)!}}\\)"
  },
  {
    "objectID": "posts/maths/probabilites TD1.html",
    "href": "posts/maths/probabilites TD1.html",
    "title": "Correction du TD 1 de probabilités (combinatoire)",
    "section": "",
    "text": "Un ascenseur dessert les 12 étages d’un immeuble. Au rez-de-chaussée, l’ascenseur est vide et 10 personnes y entrent. On suppose que personne ne monte dans l’ascenseur aux différents étages atteints. Déterminer de combien de façons les 10 personnes qui ont pris cet ascenseur peuvent s’être réparties entre les étages."
  },
  {
    "objectID": "posts/maths/probabilites TD1.html#un-chiffre-apparaissant-4-fois-les-autres-1-fois",
    "href": "posts/maths/probabilites TD1.html#un-chiffre-apparaissant-4-fois-les-autres-1-fois",
    "title": "Correction du TD 1 de probabilités (combinatoire)",
    "section": "5) un chiffre apparaissant 4 fois, les autres 1 fois",
    "text": "5) un chiffre apparaissant 4 fois, les autres 1 fois"
  },
  {
    "objectID": "posts/maths/probabilites TD1.html#chiffres-formant-une-suite-strictement-croissante",
    "href": "posts/maths/probabilites TD1.html#chiffres-formant-une-suite-strictement-croissante",
    "title": "Correction du TD 1 de probabilités (combinatoire)",
    "section": "6) 8 chiffres formant une suite strictement croissante",
    "text": "6) 8 chiffres formant une suite strictement croissante\nPour former une suite strictement croissante de 8 chiffres, il faut prendre la suite \\((0, 1, 2, 3, 4, 5, 6, 7, 9)\\), et sélectionner 8 chiffres dans cette liste (l’ordre étant forcément croissant, on a pas besoin de considérer l’ordre).\nDonc, il y à \\(\\dbinom{10}{8}=45\\) possibilités"
  },
  {
    "objectID": "posts/maths/probabilites TD1.html#chiffres-formant-une-suite-croissante",
    "href": "posts/maths/probabilites TD1.html#chiffres-formant-une-suite-croissante",
    "title": "Correction du TD 1 de probabilités (combinatoire)",
    "section": "7) 8 chiffres formant une suite croissante",
    "text": "7) 8 chiffres formant une suite croissante\nPour former une suite croissante (non strictement) de 8 chiffres, il faut considérer que l’on peut répéter le même élément. A nouveau, l’ordre est fixé, donc on ne le compte pas.\nDonc, il y à \\(K_{10}^{8} = \\begin{pmatrix}\\!\\!\\dbinom{10}{8}\\!\\!\\end{pmatrix} = \\dbinom{10}{3} = 120\\)"
  },
  {
    "objectID": "posts/maths/transposition.html",
    "href": "posts/maths/transposition.html",
    "title": "transposition",
    "section": "",
    "text": "Définition\n\n\n\nUne transposition est une permutation qui n’échange que \\(2\\) éléments.\nUne transposition est donc un 2-cycle\nFormellement, une permutation \\(\\sigma \\in\\mathfrak{S}_{n}\\) est une transposition si et seulement si :\n\nil existe \\(2\\) éléments distincts \\(a\\) et \\(b\\) tels que \\(\\sigma(a)=b\\) et \\(\\sigma(b)=a\\)\n\\(\\forall i \\notin \\{ a; b \\}, \\quad \\sigma(i)=i\\) (tous les autres éléments sont invariants par \\(\\sigma\\))\n\n\n\n\n\n\n\n\n\nExemples\n\n\n\n\n\n\\(\\sigma = \\begin{pmatrix}1&2&3\\\\1&3&2\\end{pmatrix}\\) est une transposition\n\\(\\sigma=\\begin{pmatrix}1&2&3&4\\\\3&2&1&4\\end{pmatrix}\\) est une transposition\n\\(\\sigma=\\begin{pmatrix}1&2&3&4&5\\\\2&4&1&5&3\\end{pmatrix}\\) n’est pas une transposition\nVoici la visualisation d’une transposition :\n\n    \n        (\n        \n            \n                1\n                2\n                3\n                4\n                5\n            \n            \n                1\n                2\n                3\n                4\n                5\n            \n        \n        )"
  },
  {
    "objectID": "posts/maths/maths divisibilité.html",
    "href": "posts/maths/maths divisibilité.html",
    "title": "Dibisibilité",
    "section": "",
    "text": "Définitions\n\n\n\nSoient \\(a\\) et \\(b\\) deux entiers relatifs (dans \\(\\mathbb{Z}\\)) \\(a\\) est un diviseur de \\(b\\) s’il existe un entier relatif \\(k\\) tel que \\(\\boxed{b = ka}\\)\nOn dit alors que : - \\(a\\mid b\\) soit “\\(a\\) divise \\(b\\)” - \\(b\\) est un multiple de \\(a\\)"
  },
  {
    "objectID": "posts/maths/maths divisibilité.html#propriétés",
    "href": "posts/maths/maths divisibilité.html#propriétés",
    "title": "Dibisibilité",
    "section": "Propriétés",
    "text": "Propriétés\n\n\n\n\n\n\navec \\(0\\)\n\n\n\n\n\\(0\\) ne divise aucun nombre (on ne peut pas diviser par \\(0\\))\ntous les nombres divisent \\(0\\) (voir la définition, avec \\(k=0\\))\n\n\n\n\n\n\n\n\n\nNombres négatifs\n\n\n\nSi \\(a \\mid b\\), on sait que : - \\(-a \\mid b\\) - \\(a \\mid -b\\) - \\(-a \\mid -b\\)\nEn fait, le signe n’est pas important pour la divisibilité (on le voir en reprenant la définition : \\(k\\) peut être positif ou négatif).\n\n\n\n\n\n\n\n\nDiviseur d’un diviseur\n\n\n\nsi \\(a \\mid b\\) et \\(b \\mid c\\), alors on sait que \\(a \\mid c\\)\n\nExemples\n\n\\(6 \\mid 24\\), or \\(3 \\mid 6\\), donc \\(3 \\mid 24\\)\n\\(4 \\mid 12\\), or \\(24\\) est multiple de \\(12\\), donc \\(4 \\mid 12\\)\n\n\n\n\n\n\n\n\n\n\nPropriété des diviseurs\n\n\n\nTout nombre relatif \\(b\\) possède nombre fini de diviseurs.\nTous les diviseurs de \\(b\\) sont compris entre \\(-b\\) est \\(b\\)\n\nC’est logique, puisqu’un nombre plus grand que \\(b\\) (en valeur absolue) ne peut pas diviser \\(b\\).\n\n\n\n\n\n\n\n\nCombinaison linéaire\n\n\n\nSoient \\(a\\), \\(b\\) et \\(d\\) des nombres relatifs, avec \\(d \\mid a\\) et \\(d \\mid b\\) (\\(d\\) divise \\(a\\) et \\(b\\))\nOn sait que, quels que soient les entiers relatifs \\(u\\) et \\(v\\) :\n\\(\\boxed{d \\mid au + bv}\\)\n(on appelle \\(au + bv\\) une “combinaison linéaire” de \\(a\\) et de \\(b\\))\n\nExplication\nPuisque \\(d \\mid a\\), on sait que \\(d \\mid au\\) (car \\(au\\) est évidemment un multiple de \\(a\\))\nDe même, \\(d \\mid b\\), donc \\(d \\mid bv\\)\nAlors, puisque \\(d\\) divise \\(au\\) et \\(bv\\), on sait que\n\n\n\n\n\n\n\n\n\nLien avec la division euclidienne et la congruence\n\n\n\nSoient \\(a\\) et \\(b\\) deux entiers relatifs\n\\(a\\) divise \\(b\\) si et seulement si le reste de la division euclidienne de \\(b\\) par \\(a\\) est 0.\n\\(a\\) divise \\(b\\) si et seulement si \\(a \\equiv 0 [n]\\)"
  },
  {
    "objectID": "posts/maths/combinaisons_avec_repetitions.html",
    "href": "posts/maths/combinaisons_avec_repetitions.html",
    "title": "combinaisons avec répétitions",
    "section": "",
    "text": "Définition\n\n\n\n\\(K _{n}^{k} = \\dbinom{n+k-1}{k}\\)\nOn note \\(K{n}^{k}\\) les combinaisons avec répétitions dans \\(n\\) de \\(k\\).\nC’est le nombre de sacs à \\(k\\) éléments inclus dans un ensemble à \\(n\\) éléments - on utilise des sacs car on autorise la répétition mais que l’ordre n’est pas important\n\n\n\n\n\n\n\n\nAutres notations\n\n\n\n\n\nLes combinaisons avec répétitions sont aussi notées \\(\\Gamma _{n}^{k}\\).\nUne notation que j’apprécie particulièrement est \\(\\begin{pmatrix}\\begin{pmatrix}k\\\\n\\end{pmatrix}\\end{pmatrix}\\), car c’est une notion similaire aux combinaisons, mais avec des sacs plutôt que des ensembles (et que les sacs sont notés avec des doubles accolades : \\(\\{\\!\\!\\{ a, a, a, b, \\dots \\}\\!\\!\\}\\))\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nDéfinition\n\\(K_{n}^{k}\\) est le nombre de sacs de cardinal \\(k\\) distincts dont le support est inclus dans un ensemble de cardinal \\(n\\)\n\n\n\n\nFormule\nOn peut représenter un sac (ou multi-ensemble) par une liste de points cercles par des barres.\nPar exemple, le sac \\(\\{\\!\\!\\{ a; a; c; c; c; d \\}\\!\\!\\}\\) avec des éléments pris dans \\(\\{ a; b; c; d \\}\\) est représenté comme \\(\\bigcirc \\bigcirc \\mid \\; \\mid \\bigcirc \\bigcirc \\bigcirc \\mid \\bigcirc\\) (avec un espace vide, car il n’y à aucun \\(b\\)).\nSi on part d’un ensemble avec \\(n\\) éléments, et qu’on forme des sacs de taille \\(k\\). Dans la liste équivalente, on sait alors qu’il y aura \\(k + n - 1\\) emplacements : \\(k\\) cercles \\(+\\) \\(n - 1\\) barres. Alors, le nombre de sacs que l’on peut former ainsi correspond au nombres de façon de placer les \\(k\\) cercles parmi les \\(k + n - 1\\) emplacements, soit \\(\\dbinom{k+n-1}{k}\\).\nOr, on sait que le nombre de sacs à \\(k\\) éléments pris dans un ensemble à \\(n\\) éléments est justement \\(K _{n}^{k}\\) (Voir définition). Donc, on a démontré la formule :\n\\(\\boxed{K _{n}^{k} = \\dbinom{n + k - 1}{k}}\\)"
  },
  {
    "objectID": "posts/maths/maths congruence.html",
    "href": "posts/maths/maths congruence.html",
    "title": "Congruence",
    "section": "",
    "text": "Définition\n\n\n\nSoient \\(a\\) et \\(b\\) deux entiers relatifs  Soit \\(n\\) un entier naturel non nul\nOn dit que \\(a\\) est congru à \\(b\\) modulo \\(n\\), et on note \\(a \\equiv b [n]\\) si et seulement si \\(n \\mid a - b\\)\nCela peut être interprété comme le fait que \\(a\\) et \\(b\\) ont le même reste pour la division euclidienne par \\(n\\) (c’est une autre définition).\nUne dernière définition est que \\(a \\equiv b [n]\\) si et seulement si il existe un entier relatif \\(k\\) tel que \\(a - b = kn\\) (si \\(a-b\\) est un multiple de \\(n\\)). Cette définition est équivalente à \\(a - b \\mid n\\) (voir la définition de la divisibilité)\n\n\n\non sait que \\(13 \\equiv 28 [5]\\) car \\(13\\) et \\(28\\) ont tous les deux un même reste de \\(3\\) dans la division par \\(5\\)\non sait que \\(15 \\equiv 2 [6]\\) car \\(15 - 2 = 12\\) et car \\(12\\) est multiple de \\(6\\)"
  },
  {
    "objectID": "posts/maths/maths congruence.html#comprendre-la-congruence",
    "href": "posts/maths/maths congruence.html#comprendre-la-congruence",
    "title": "Congruence",
    "section": "Comprendre la congruence",
    "text": "Comprendre la congruence\nOn sait que les nombres de \\(\\mathbb{Z}\\) peuvent être représentés sur une droite :\n\nDe la même manière, on peut représenter les entier modulo \\(n\\)… sur un cercle !\nOn va “enrouler” la droite sur elle-même, en mettant au même endroit les nombres qui sont congrus modulo \\(n\\).\nPar exemple, voici le cercle des entiers modulo \\(8\\) :\n\nLes nombres dans chaque groupe en bleu sont ceux qui sont congrus modulo \\(8\\). En quelque sorte, ce sont les mêmes nombre dans ce système : on peut les utiliser de la même manière dans une addition, multiplication etc., et le résultat sera le même modulo 8.\nQuand on travaille modulo \\(n\\), la congruence joue le même rôle que l’égalité."
  },
  {
    "objectID": "posts/maths/maths congruence.html#propriétés",
    "href": "posts/maths/maths congruence.html#propriétés",
    "title": "Congruence",
    "section": "Propriétés",
    "text": "Propriétés\n\n\n\n\n\n\nCongruence à \\(0\\)\n\n\n\nSoit \\(a \\in \\mathbb{Z}\\)\n\\(a \\equiv 0 [n]\\) si et seulement si \\(n \\mid a\\) (\\(a\\) est divisible par \\(n\\))\n\n\n\n\n\n\n\n\nCongruence à lui-même\n\n\n\nComme avec l’égalité classique,\n\n\n\n\n\n\n\n\nTransitivité de la congruence\n\n\n\nSoit \\(n\\) un entier strictement positif  Soient \\(a\\), \\(b\\) et \\(c\\) des entiers relatifs\nSi \\(a \\equiv b [n]\\) et \\(b \\equiv c [n]\\), alors : \\(a \\equiv b [n]\\)\nOn connaît cette propriété pour l’égalité : si \\(a = b\\) et \\(b = c\\), alors \\(a = c\\).\n\n\n\n\n\n\n\n\nOpérations dans des congruences\n\n\n\nSoit \\(n\\) un entier strictement positif  Soient \\(a\\), \\(A\\), \\(b\\), \\(B\\) et \\(k\\) des entiers relatifs  avec \\(a \\equiv A[n]\\) et \\(b \\equiv B[n]\\)\nOn a :\n\n\\(a + b \\equiv A + B [n]\\)\n\nDonc \\(a + k \\equiv A + k [n]\\)\n\n\\(a - b \\equiv A - B [n]\\)\n\nDonc \\(a - k \\equiv A - k[n]\\)\n\n\\(ab \\equiv AB [n]\\)\n\nDonc \\(ak \\equiv Ak [n]\\)\n\n\\(a^{p} \\equiv A^{p}[n]\\) (pour tout \\(p \\in \\mathbb{N}\\))\n\nEn fait, si on a commris que la congruence est une sorte d’égalité quand on est modulo \\(n\\), toutes ces propriétés sont évidentes."
  },
  {
    "objectID": "posts/maths/ensemble des parties dun ensemble.html",
    "href": "posts/maths/ensemble des parties dun ensemble.html",
    "title": "Ensemble des parties d’un ensemble",
    "section": "",
    "text": "Définition\n\n\n\nSoit \\(E\\) un ensemble\nOn note \\(\\mathscr{P}(E)\\) l’ensemble des parties de \\(E\\)\nC’est l’ensemble de tous les sous-ensembles de \\(E\\)\nSoit :\n\\(\\mathscr{P}(E) := \\{ F \\mid F \\subset E \\}\\)\n\n\n\nPropriétés\n\nComme \\(\\emptyset\\) est contenu dans tous les ensembles, \\(\\emptyset \\in \\mathscr{P}(E)\\) quelque soit \\(E\\)\n\nil ne faut pas oublier que \\(\\emptyset\\) est une partie de tout ensemble\n\n\\(\\displaystyle \\text{card}(\\mathscr{P}(E)) = 2^{\\text{card}(E)}\\)"
  },
  {
    "objectID": "posts/maths/nombre de permutations.html",
    "href": "posts/maths/nombre de permutations.html",
    "title": "permutations (combinatoire)",
    "section": "",
    "text": "Définition\n\n\n\nOn définit \\(P_{n}\\) le nombre de permutations de \\(n\\) éléments.\nC’est donc le nombre d’éléments de \\(\\mathfrak{S}_{n}\\) : \\(P_{n} = \\text{card} (\\mathfrak{S}_{n})\\)\nMais surtout, on obtient la formule : \\(\\boxed{P_{n}= n!}\\)\n\n\n\nInterprétation\nL’interprétation du nombre de permutations est immédiate, puisque \\(P_{n}\\) compte le nombre de façons de “mélanger” (permuter) \\(n\\) objets.\n\n\n\n\n\n\nExemples\n\n\n\nVoici quelques questions de combinatoire dont la réponse passe par des permutations :\n\nCombien y a-t-il de mélanges différents d’un jeu de 54 cartes ?\n\n\\(P_{54} = 54! \\approx 2.3 \\cdot 10^{71}\\)\n\nCombien de phrases peut-on former avec 10 mots différents\n\npar exemple, avec “madame la marquise, vos beaux yeux me font mourir d’amour”\n\nqui peut être permuté en “vos beaux yeux d’amour mourir me font, madame la marquise”, ou bien “vos beaux yeux, madame la marquise, me font mourir d’amour” etc…\n\n\\(P_{10} = 10! = 3628800\\)\n\n\n\n\n\n\nFormule\nFaire une permutations de \\(n\\) éléments, c’est placer ces \\(n\\) éléments dans \\(n\\) emplacements.\nOn veut donc compter le nombre de façons de choisir ces placements\n\npour le \\(1^{\\text{er}}\\) élément, il y à \\(n\\) emplacements possibles (ils sont tous libres)\npour le \\(2^{\\text{ème}}\\) élément, il y à \\(n-1\\) emplacements possibles (un des emplacements est pris par le \\(1^{\\text{er}}\\) élément)\npour le \\(3^{\\text{ème}}\\) élément, il y à \\(n-2\\) emplacements possibles\n\\(\\vdots\\)\npour le \\(n-2^{\\text{ème}}\\) élément, \\(3\\) emplacements possibles\npour le \\(n-1^{\\text{ème}}\\), \\(2\\) emplacements possibles\npour le \\(n^{\\text{ème}}\\) (et dernier), \\(1\\) emplacement possible\n\nDonc, le nombre de façons de placer ces \\(n\\) éléments (le nombre de permutations de \\(n\\) éléments) est \\(n\\times (n-1)\\times(n-2)\\times\\cdots \\times 3 \\times2\\times 1 = n!\\)\nD’où la formule : \\(\\boxed{P_{n} = n!}\\)"
  },
  {
    "objectID": "posts/maths/inversion.html",
    "href": "posts/maths/inversion.html",
    "title": "inversion",
    "section": "",
    "text": "Définition"
  },
  {
    "objectID": "posts/maths/combinaisons.html",
    "href": "posts/maths/combinaisons.html",
    "title": "combinaisons",
    "section": "",
    "text": "Définition\n\n\n\n\\(\\displaystyle \\binom{n}{k} = \\frac{n!}{k!(n-k)!}\\) Le nombre de façons de choisir \\(k\\) éléments parmi un ensemble de \\(n\\) éléments (sans ordre)\nC’est le nombre d’ensembles à \\(k\\) éléments contenus dans un ensemble à \\(n\\) éléments. Autrement dit, c’est le nombre de sous-ensembles à \\(k\\) éléments d’un ensemble à \\(n\\) éléments - on utilise des ensembles car on a pas de répétitions d’un même élément, et que l’ordre n’est pas important\n\n\n\nInterprétation\nComme dit dans la définition, \\(\\displaystyle \\binom{n}{k}\\) est le nombre de façons de choisir \\(k\\) éléments dans un ensemble de \\(n\\) éléments.\n\n\n\n\n\n\nAttention\n\n\n\nLes combinaisons sont sans répétition, par opposition avec les combinaisons avec répétitions.\nCela veut dire que l’on ne peut choisir qu’une seule fois chaque élément.\n\n\n\n\n\n\n\n\nExemples\n\n\n\n\n\nVoici quelques questions de combinatoire dont la réponse passe par une combinaison :\n\nCombien de nouvelles couleurs peut-on faire en mélangeant 2 couleurs parmi 5 couleurs de base (cyan, magenta, jaune, noir, blanc)\n\n\\(\\displaystyle \\binom{5}{3} = 10\\)\n\nCombien de “mains” de 5 cartes peut-on former avec un jeu de 52 cartes ?\n\n\\(\\dbinom{52}{5} = 2\\,598\\,960\\)\n\ncombien de “livres” différents peut-on former en choisissant 50 pages dans un dictionnaire de \\(100\\) pages (sans considérer l’ordre de ces pages) ?\n\n\\(\\displaystyle \\binom{100}{50} = 100\\,891\\,344\\,545\\,564\\,193\\,334\\,812\\,497\\,256 \\approx 10^{30}\\) (beaucoup)\n\n\n\n\n\n\n\nFormule\nLa formule pour les combinaisons vient de celle pour les arrangements (\\(A_{n}^{k}\\)).\nPar définition, un arrangement considère l’ordre, quand une combinaison ne le considère pas (car l’un compte les \\(k\\)-uplets, quand l’autre compte les ensemble de cardinal \\(k\\)).\nOr, on sait qu’il y à \\(k!\\) façons d’arranger \\(k\\) éléments.\nDonc, on sait qu’il y à \\(k!\\) fois plus d’arrangements que de combinaisons pour des mêmes coefficients : \\(\\displaystyle \\binom{n}{k} = k! \\times A_{n}^{k}\\)\nOn en déduit : \\(\\displaystyle \\binom{n}{k} = k! \\times \\frac{n!}{(n - k)!}\\), soit :\n\\(\\boxed{\\binom{n}{k} = \\frac{n!}{k!(n-k)!}}\\)"
  },
  {
    "objectID": "posts/maths/sacs.html",
    "href": "posts/maths/sacs.html",
    "title": "sacs (multi-ensembles)",
    "section": "",
    "text": "Définition\n\n\n\nUn sac, ou multi-ensemble, est un ensemble dans lequel on autorise la répétition d’éléments.\nCela signifie que, contrairement aux ensembles, un élément peut être contenu plusieurs fois dans un sac.\nNotation : \\(\\{\\!\\!\\{ a, a, a, b, c, c, d, d, d, d \\}\\!\\!\\}\\)\n\n\n\n\n\n\n\n\nDéfinition formelle\n\n\n\n\n\nOn définit un sac \\(B\\) comme un couple \\((E, f)\\), où : - \\(E\\) est l’ensemble des éléments du sac (sans répétitions) - \\(E\\) est appelé le support de \\(B\\) - \\(f : E \\to \\mathbb{N}\\) est la fonction qui, à un élément de \\(E\\), associe son nombre de répétitions - \\(f\\) est appelée la multiplicité de \\(B\\)\nPar exemple, le sac \\(\\{\\!\\!\\{ a, a, a, b, c, c \\}\\!\\!\\}\\) Se définit avec : - \\(E = \\{ a, b, c \\}\\) - \\(f\\) telle que : - \\(f(a) = 3\\) - \\(f(b)=1\\) - \\(f(c)=2\\)\n\n\n\n\nPropriétés\nSoit \\(B\\) un sac\n\non appelle support de \\(B\\) l’ensemble des éléments de \\(B\\) (donc, sans répétition)\n\nPar exemple, le support de \\(\\{\\!\\!\\{ a, a, a, b, c, c, d, d, d, d \\}\\!\\!\\}\\) est \\(\\{ a, b, c, d \\}\\)\n\non appelle multiplicité de \\(B\\) la fonction qui, à un élément de \\(B\\), associe le nombre de répétitions de cet élément\n\nPar exemple, si \\(f\\) est la multiplicité de \\(\\{\\!\\!\\{ a, a, a, b, c, c, d, d, d, d \\}\\!\\!\\}\\), alors \\(f(a) = 3\\), \\(f(b) = 1\\), \\(f(c) = 2\\) et \\(f(d)=4\\)\n\n\n Si \\(E\\) et \\(f\\) sont le support et la multiplicité de \\(B\\)\n\n\\(\\text{card}(B) = \\sum\\limits_{x \\in E} f(x)\\)\n\nle cardinal est la somme des multiplicités de chaque valeur de \\(E\\)\nc’est évident, puisque la multiplicité est le nombre de répétitions de chaque élément\n\n\n\n\nUtilité\nEn combinatoire, les sacs permettent d’exprimer la possibilité de répéter un élément un certain nombre de fois."
  },
  {
    "objectID": "posts/autres/Le dimanche, il pleut généralement à l'extérieur.html",
    "href": "posts/autres/Le dimanche, il pleut généralement à l'extérieur.html",
    "title": "Le dimanche, il pleut généralement à l’extérieur",
    "section": "",
    "text": "Le dimanche, il pleut généralement à l’extérieur\n\n\n\n\n\n\n\n\nExplication\n\n\n\nLa phrase semble bizarre, parce qu’on a l’impression qu’elle sous-entend que, les autres jours, il pleut à l’intérieur (ou en tout cas, qu’il ne pleut pas à l’extérieur).\nCette phrase montre que, en français, quand on donne une condition, quand on limite un énoncé (ici “le dimanche”), on suppose souvent que ce qui est énoncé (ici “il pleut à l’extérieur”) est vrai seulement pour cette condition.\nOr, il est évident que, quel que soit le jour, il pleut généralement à l’extérieur.\nEt pourtant, on se rend compte que la phrase n’est pas pour autant fausse : effectivement, le dimanche (comme les autres jours), il pleut plutôt à l’extérieur.\nMais pourquoi interprétons-nous cette phrase différemment ? C’est parce que, dans la plupart des cas du quotidien, il est plus simple de ne dire qu’une phrase pour en dire deux. Par exemple : “je vais faire du sport tous les lundis” suppose aussi que “je ne vais pas faire de sport les autres jours”. C’est bien pratique pour communiquer !\nIl faut cependant faire attention, car cette supposition peut causer des erreurs de compréhension, lors d’un débat par exemple, où les arguments doivent être précis !"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "0SK42 - Tous les posts",
    "section": "",
    "text": "Le langage APL\n\n\n\n\n\n\n\ninformatique\n\n\n\n\n\n\n\n\n\n\n\nMar 23, 2023\n\n\n\n\n\n\n  \n\n\n\n\nconvertir des listes python en tables markdown\n\n\n\n\n\n\n\ninformatique\n\n\n\n\n\n\n\n\n\n\n\n\nMar 10, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nalgo avancee correction controle\n\n\n\n\n\n\n\ninformatique\n\n\n\n\n\n\n\n\n\n\n\nMar 2, 2023\n\n\n\n\n\n\n  \n\n\n\n\nterminal - btop : statistiques des processus\n\n\n\n\n\n\n\ninformatique\n\n\n\n\n\n\n\n\n\n\n\nFeb 20, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlgorithmique avancée : activité 3\n\n\n\n\n\n\n\ninformatique\n\n\n\n\n\n\n\n\n\n\n\nFeb 17, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCorrection du TD 1 de probabilités (combinatoire)\n\n\n\n\n\n\n\nmaths\n\n\n\n\n\n\n\n\n\n\n\nJan 20, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntransposition\n\n\n\n\n\n\n\nmaths\n\n\n\n\n\n\n\n\n\n\n\nJan 19, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npermutations (combinatoire)\n\n\n\n\n\n\n\nmaths\n\n\n\n\n\n\n\n\n\n\n\nJan 19, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ninversion\n\n\n\n\n\n\n\nmaths\n\n\n\n\n\n\n\n\n\n\n\nJan 19, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStructures de données\n\n\n\n\n\n\n\ninformatique\n\n\n\n\n\n\n\n\n\n\n\nJan 17, 2023\n\n\n\n\n\n\n  \n\n\n\n\nInformatique\n\n\n\n\n\n\n\ninformatique\n\n\nindex\n\n\n\n\nListe des notions d’Informatique\n\n\n\n\n\n\nJan 15, 2023\n\n\n\n\n\n\n  \n\n\n\n\nAlgorithmique avancée - activité 1\n\n\n\n\n\n\n\ninformatique\n\n\n\n\n\n\n\n\n\n\n\nJan 15, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStructure de données : tableau\n\n\n\n\n\n\n\ninformatique\n\n\n\n\n\n\n\n\n\n\n\n\nJan 13, 2023\n\n\n\n\n\n\n  \n\n\n\n\nListes chaînées\n\n\n\n\n\n\n\ninformatique\n\n\n\n\n\n\n\n\n\n\n\nJan 13, 2023\n\n\n\n\n\n\n  \n\n\n\n\nStructures de données récursives\n\n\n\n\n\n\n\ninformatique\n\n\n\n\n\n\n\n\n\n\n\nJan 13, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlgorithmique : Structures dynamiques\n\n\n\n\n\n\n\ninformatique\n\n\n\n\n\n\n\n\n\n\n\nJan 13, 2023\n\n\n\n\n\n\n  \n\n\n\n\nCongruence\n\n\n\n\n\n\n\nmaths\n\n\n\n\n\n\n\n\n\n\n\nJan 11, 2023\n\n\n\n\n\n\n  \n\n\n\n\nDibisibilité\n\n\n\n\n\n\n\nmaths\n\n\n\n\n\n\n\n\n\n\n\nJan 10, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLe dimanche, il pleut généralement à l’extérieur\n\n\n\n\n\n\n\naphorismes\n\n\nzététique\n\n\n\n\n\n\n\n\n\n\n\nJan 8, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\narrangements avec répétitions\n\n\n\n\n\n\n\nmaths\n\n\n\n\nnombre de sacs à k éléments inclus dans un ensemble à n éléments\n\n\n\n\n\n\nJan 6, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncombinaisons avec répétitions\n\n\n\n\n\n\n\nmaths\n\n\n\n\n\n\n\n\n\n\n\nJan 6, 2023\n\n\n\n\n\n\n  \n\n\n\n\nvim tips autocorriger les erreurs\n\n\n\n\n\n\n\nvim\n\n\ntips\n\n\n\n\nComment corriger rapidement des erreurs d’orthographe\n\n\n\n\n\n\nJan 5, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\narrangements\n\n\n\n\n\n\n\nmaths\n\n\n\n\n\n\n\n\n\n\n\nJan 5, 2023\n\n\n\n\n\n\n  \n\n\n\n\ncombinaisons\n\n\n\n\n\n\n\nmaths\n\n\n\n\n\n\n\n\n\n\n\nJan 5, 2023\n\n\n\n\n\n\n  \n\n\n\n\nMathématiques\n\n\n\n\n\n\n\nmaths\n\n\nindex\n\n\n\n\nListe des notions de Mathématiques\n\n\n\n\n\n\nJan 4, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEnsemble des parties d’un ensemble\n\n\n\n\n\n\n\nmaths\n\n\n\n\nensemble de tous les sous-ensembles\n\n\n\n\n\n\nJan 4, 2023\n\n\n\n\n\n\n  \n\n\n\n\nsacs (multi-ensembles)\n\n\n\n\n\n\n\nmaths\n\n\n\n\n\n\n\n\n\n\n\nJan 4, 2023\n\n\n\n\n\n\n  \n\n\n\n\nvim tips - leader\n\n\n\n\n\n\n\nvim\n\n\ntips\n\n\n\n\nprésentation du raccourci <leader> dans vim\n\n\n\n\n\n\nJan 3, 2023\n\n\n\n\n\n\n  \n\n\n\n\nformulaire d’analyse\n\n\n\n\n\n\n\nmaths\n\n\nindex\n\n\n\n\n\n\n\n\n\n\n\nJan 3, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPourquoi ce blog ?\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nJan 2, 2023\n\n\n\n\n\n\n  \n\n\n\n\nBienvenue sur mon blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nJan 1, 2023\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "A propos",
    "section": "",
    "text": "Je suis étudiant en licence d’informatique et de mathématiques, et passionné par ces deux sciences.\n\nContenu\nLe contenu de ce blog est principalement :\n\n\nDes explications de concepts d’informatique et de mathématiques\nDes réflexions sur divers sujets\nDes présentations de ce que je trouve intéressant\n\n\n\n\nLe nom du blog\nLe Blog s’appelle OSK42, à la fois en référence au nombre 42, la réponse à la “grande question sur la vie, l’univers et le reste”, et car OSK42 est une écriture de OSKAR (mon pseudo) en leet speak\n\n           \n\n\nCrédits\n\n\n\n\n\n\nCrédits des icônes\n\n\n\n\n\n\nAlgebra icons created by Freepik - Flaticon\nBackpack icons created by max.icons - Flaticon\nCoding icons created by juicy_fish - Flaticon\nHierarchy icons created by Becris - Flaticon\nLoop icons created by Pixelmeetup - Flaticon\nMath icons created by Freepik - Flaticon\nSpace suit icons created by surang - Flaticon\nUi icons created by Arafat Uddin - Flaticon"
  }
]