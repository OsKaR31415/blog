{"title":"Algorithmique avancée : activité 3","markdown":{"yaml":{"title":"Algorithmique avancée : activité 3","date":"2023-01-13","categories":["informatique"],"jupyter":"python3","toc":true,"number-sections":true,"draft":true},"headingText":"Définition d'une liste chaînée","containsRefs":false,"markdown":"\n\n::: {.callout-tip collapse=true}\n\n\n```{python}\n\nclass Node:\n    def __init__(self, valeur, suivant: 'Node' =None):\n        self.valeur = valeur\n        self.suivant = suivant\n\nclass Liste:\n    def __init__(self, head: Node):\n        self.head = head\n\n    def __str__(self) -> str:\n        return \"(\" + \",\".join(map(lambda e: str(Liste(e) if isinstance(e, Node) else e),\n                                  self.to_list())) + \")\"\n\n    def to_list(self) -> list:\n        if self.head is None:\n            return []\n        return [self.head.valeur] + self.cdr().to_list()\n\n    def __len__(self) -> int:\n        \"\"\"Longueur de la liste.\n        \"\"\"\n        if self.head is None:\n            return 0\n        return 1 + len(self.head.suivant)\n\n    def append(self, valeur) -> None:\n        \"\"\"Ajouter une valeur à la fin de la liste.\n        \"\"\"\n        # cas de base :\n        # on doit s'arrêter dès que la liste est terminer\n        if self.head.suivant is None:\n            # on créé un nouveau Node\n            self.head.suivant = Node(valeur)\n        # récursion pour atteindre la fin de la liste\n        self.cdr().append(valeur)\n\n    def car(self):\n        \"\"\"Récupérer la valeur en tête de liste\n        \"\"\"\n        return self.head.value\n\n    def cdr(self) -> 'Liste':\n        \"\"\"Récupérer la liste sans son premier élément.\n        \"\"\"\n        if self.head is None:\n            return None\n        return Liste(self.head.suivant)\n\n    def last(self):\n        \"\"\"Récupérer le dernier élément de la liste.\n        \"\"\"\n        if self.head.suivant is None:\n            return self.last(Liste(self.head.suivant))\n        return self.head.valeur\n```\n\n:::\n\n# Bégaie - De bégaie\n\n\n> On dit qu'une liste est “bégayée” lorsque chaque élément y\n> apparaît deux fois de suite. Le but de cet exercice est de\n> transformer une liste en une liste bégayée, et inversement\n> de “dé bégayer” une liste en supprimant un élément sur\n> deux.\n\n## Bégaie\n\n### Fonction itérative\n\n> écrire la fonction itérative `begaie` qui, étant donnée\n> une liste d’éléments, renvoie la liste où chaque élément\n> est répété. Par exemple : `begaie(1,2,3,1,4) =\n> (1,1,2,2,3,3,1,1,4,4)` et `begaie(None) = None`.\n\n```{python}\ndef begaie(L: Node) -> Node:\n    p = L\n    while p is not None:\n        # insérer un mode contenant la même valeur\n        tmp = Node(p.valeur, p.suivant)\n        p.suivant = tmp\n        # on passe au pointeur suivant\n        p = p.suivant.suivant\n    return L\n```\n\nOn peut tester :\n\n```{python}\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nprint(Liste(L))\nprint(Liste(begaie(L)))\n```\n\nEt on a bien :\n\n```{python}\nprint(begaie(None))\n```\n\n\n\n### Fonction récursive\n\n> Donner maintenant une fonction récursive `begaieRec` qui\n> effectue le même traitement que la fonction `begaie`\n> précédente\n\n```{python}\ndef begaieRec(L: Node) -> Node:\n    if L is None:\n        return None\n    return Node(L.valeur, Node(L.valeur, begaieRec(L.suivant)))\n```\n\nElle fonctionne également :\n\n```{python}\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nprint(Liste(L))\n# La fonction modifie la valeur de L, donc on pourrait\n# simplement appeler la fonction, sans modifier\n# explicitement L (sans mettre le `L = `)\nL = begaie(L)\n```\n\n## Dé bégaie\n\n\n### Fonction itérative\n\n> Écrire maintenant la fonction itérative `debegaie` qui\n> prend en argument une liste bégayée et retourne la liste\n> privée de ses doublons. La fonction de bégaie est telle que\n> `debegaie(begaie(L)) = L`\n\n```{python}\ndef debegaie(L: Node) -> Node:\n    if L is None:\n        return None\n    p = L\n    # on est obligé \n    while p.suivant.suivant is not None:\n        p.suivant = p.suivant.suivant\n        p = p.suivant\n    # on retire le dernier élément\n    # p.suivant = None\n    return L\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nL = begaie(L)\nprint(Liste(L))\nL = debegaie(L)\nprint(Liste(L))\n```\n\n\n### Fonction récursive\n\n> Écrire enfin la fonction récursive `debegaieRec` qui\n> réalise le même traitement que la fonction `debegaie`.\n\n\n\n```{python}\ndef debegaieRec(L: Node) -> Node:\n    # cas de base\n    if L is None:\n        return None\n    # on doit ajouter ce cas de base car on utilise\n    # L.suivant.suivant, donc L.suivant ne doit pas être None\n    if L.suivant is None:\n        return None\n    # On créée une nouvelle liste qui saute un élément\n    return Node(L.valeur, debegaieRec(L.suivant.suivant))\n\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nL = begaie(L)\nprint(Liste(L))\nL = debegaie(L)\nprint(Liste(L))\n```\n\n# Implémentation de la fonction `zip`\n\nDe très nombreux langages de programmations permettent de\ntravailler sur des structures de listes chaînées. Le langage\nPython notamment permet de travailler nativement avec les\nlistes et implémente la fonction `zip(l1, l2)` qui permet, à partir de 2 listes de même longueur de construire une liste contenant les couples de valeurs formés des éléments de même indice issu des 2 listes. Par exemple :\n\n```{python}\nZ = zip((1, 2, 3), (\"a\", \"b\", \"c\" ))\nprint(list(Z))\n```\n\n## Itérative\n\n 1. Écrire la fonction itérative zip(l1, l2) qui permet d’obtenir le résultat désiré en suivant le formalisme des listes chaînées étudiées en cours. On supposera les listes en argument de même taille et non vides.\n\n\n```{python}\ndef zip_iter(L1: Node, L2: Node) -> Node:\n    p = L1\n    q = L2\n    res = None\n    last = None\n    while p is not None and q is not None:\n        if res is None:\n            res = Node(Node(p.valeur, Node(q.valeur)))\n            last = res\n        else:\n            last.suivant = Node(Node(p.valeur, Node(q.valeur)))\n            last = last.suivant\n        p = p.suivant\n        q = q.suivant\n    return res\n\nL1 = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9, Node(2)))))))\nL2 = Node(1, Node(6, Node(1, Node(8, Node(0, Node(3, Node(3)))))))\nprint(Liste(zip_iter(L1, L2)))\nprint(Liste(L1), Liste(L2))\n```\n\n## Récursive\n\n 2. Produire une solution récursive équivalente.\n\n```{python}\ndef zip_rec(L1: Node, L2: Node) -> Node:\n    if L1 is None or L2 is None:\n        return None\n    return Node(Node(L1.valeur, Node(L2.valeur)),\n                zip_rec(L1.suivant, L2.suivant))\n\n\nL1 = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9, Node(2)))))))\nL2 = Node(1, Node(6, Node(1, Node(8, Node(0, Node(3, Node(3)))))))\nL3 = Node(1, Node(2, Node(3)))\nprint(Liste(zip_rec(L1, L2)))\nprint(Liste(zip_rec(L1, L3)))\n```\n\n\n# Liste croisante\n\nOn considère dans cet exercice une liste contenant des valeurs comparables grâce à l’opérateur `<=`.\n\n## Itérative\n\n 1. Écrire la fonction itérative `croissante(L)` qui prend en argument une telle liste et retourne `True` si et seulement si la liste est triée par ordre croissant au sens large.\n\nOn implémentera la fonction en considérant les cas de base suivants :\n - une liste vide est considérée comme triée par ordre croissant\n - une liste avec un seul élément est croissante également\n\n```{python}\ndef croissante_iter(L: Node) -> bool:\n    if L is None: return True\n    p = L\n    while p.suivant is not None:\n        # si deux éléments sont dans un ordre décroissant\n        if p.valeur > p.suivant.valeur:\n            # on sait que la liste n'est pas croissante\n            return False\n        p = p.suivant\n    # si on a trouvé aucune valeur décroissante dans la liste, on sait qu'elle\n    # est croissante\n    return True\n\nL = Node(1, Node(6, Node(6, Node(42, Node(73)))))\nprint(croissante_iter(L))  # True\nL = Node(1, Node(6, Node(0, Node(42))))\nprint(croissante_iter(L))  # False\n```\n\n## Récursive\n\n2. Proposer une solution récursive.\n\n```{python}\ndef croissante_rec(L: Node) -> bool:\n    if L is None: return True\n    if L.suivant is None: return True\n    # si les valeurs en tête sont décroissantes\n    if L.valeur > L.suivant.valeur:\n        return False\n    return croissante_rec(L.suivant)\n\nL = Node(1, Node(6, Node(6, Node(42, Node(73)))))\nprint(croissante_iter(L))  # True\nL = Node(1, Node(6, Node(0, Node(42))))\nprint(croissante_iter(L))  # False\n```\n\n# Suppression des occurrences d’un élément\n\nNous nous intéressons maintenant à la suppression d’un élément quelconque dans une liste chaînée.\n\n## Itérative\n\n 1. Écrire une fonction itérative `removeAll(L, elem)` qui prend en argument une liste chaînée `L` et une valeur `elem` et retourne la liste privée de ses éléments `elem`.\n\n```{python}\ndef remove_all_iter(L: Node, elem) -> Node:\n    if L is None: return None\n    # on cherche la première valeur\n    while L.valeur == elem:\n        L = L.suivant\n        # si on a passé toutes les valeurs, c'est que la liste ne contient que\n        # des valeurs à supprimer :\n        if L is None: return None\n    res = Node(L.valeur)\n    res_tl = res\n    while L is not None:\n        if L.valeur != elem:\n            res_tl.suivant = Node(L.valeur)\n            res_tl = res_tl.suivant\n        L = L.suivant\n    return res\n\nprint(\"Liste vide :\", remove_all_iter(None, 9))\n\nL = Node(42, Node(42, Node(42, Node(42, Node(42, Node(42, Node(42)))))))\nprint(\"Liste à supprimer complètement :\",\n      Liste(remove_all_iter(L, 42)))\n\nL = Node(73, Node(73, Node(73, Node(42, Node(42)))))\nprint(\"Liste qui commmence par les éléments à supprimer :\",\n      Liste(remove_all_iter(L, 73)))\n\nL = Node(1, Node(1, Node(1, Node(8, Node(1, Node(3, Node(3)))))))\nprint(\"Liste mixte :\",\n      Liste(remove_all_iter(L, 1)))\n```\n\n\n## Récursive\n\n 2. Proposer une solution récursive à ce problème.\nIndications : pensez à différencier les cas suivants :\n\n - la liste est vide initialement,\n - la liste ne contient que l’élément à supprimer,\n - la liste commence par les éléments à supprimer,\n - la liste est mixte : composée pour une part de l’élément à supprimer et pour une autre part d’autres éléments à conserver.\n\n\n```{python}\ndef remove_all(L: Node, elem) -> Node:\n    if L is None: return None\n    if L.valeur == elem:\n        return remove_all(L.suivant, elem)\n    return Node(L.valeur, remove_all(L.suivant, elem))\n\nprint(\"Liste vide :\", remove_all_iter(None, 9))\n\nL = Node(42, Node(42, Node(42, Node(42, Node(42, Node(42, Node(42)))))))\nprint(\"Liste à supprimer complètement :\",\n      Liste(remove_all_iter(L, 42)))\n\nL = Node(73, Node(73, Node(73, Node(42, Node(42)))))\nprint(\"Liste qui commmence par les éléments à supprimer :\",\n      Liste(remove_all_iter(L, 73)))\n\nL = Node(1, Node(1, Node(1, Node(8, Node(1, Node(3, Node(3)))))))\nprint(\"Liste mixte :\",\n      Liste(remove_all_iter(L, 1)))\n```\n\n\n# Suite de Fibonacci\n\nLa suite de Fibonacci est définie comme suit :\n\n - $f_0 = 1$\n - $f_1 = 1$\n - $f_n = f_{n-1} + f_{n-2}$ si $n > 1$\n\n\n## Itérative\n\n 1. Écrire la définition de la fonction itérative `fibonacci(n)` qui, étant donné un entier naturel `n` renvoie la liste $(f_n, f_{n−1}, f_{n−2}, \\ldots, f_1, f_0)$ où les fi sont les termes de la suite de Fibonacci.\n\nPar exemple :\n\n```python\nfibonacci(0) = (1)\nfibonacci(1) = (1, 1)\nfibonacci(4) = (1, 1, 2, 3, 5)\nfibonacci(5) = (1, 1, 2, 3, 5, 8)\n```\n\n```{python}\ndef fibonacci(n: int) -> Node:\n    if n == 0:\n        return Node(1)\n    res = Node(1, Node(1))\n    # on a déjà fait la 1ère étape en définissant res, donc on peut diminuer n\n    n -= 1\n    # _ est un nom de variable que l'on utilise quand on sait que l'on ne va\n    # pas utiliser cette variable.\n    for _ in range(n):\n        # somme de la dernière et l'avant dernière valeur\n        res = Node(res.valeur + res.suivant.valeur, res)\n    return res\n\nfor n in range(10):\n    print(f\"fibonacci({n}) = {Liste(fibonacci(n))}\")\n```\n\n::: {.callout-tip collapse=true}\n## Les f-string en python\n\nLes \"*f-strings*\" sont des chaînes de caractères (*strings*) devant lesquelles on met un `f`.\n\nCela permet de mettre du code à l'intérieur, qui sera évalué et intégré dans la chaîne.\n\nPar exemple :\n\n```{python}\nfor i in range(5):\n    print(f\"{i*10}km à pied, ça use les souliers.\")\n```\n\nIci, on voit que c'est l'expression entourée par des accolades `{...}` qui est évaluée. Elle est bien intégrée dans le reste de la chaîne de caractères.\n\nBien sûr, il est possible de mettre plusieurs expressions dans une même f-string :\n\n```{python}\nfor i in range(5):\n    print(f\"{i} au carré donne {i**2}\")\n```\n\nEt on peut même imaginer ce genre d'exemples :\n\n```{python}\nfor i in range(5):\n    print(f\"{i} est un nombre {'impair' if i%2 else 'pair'} et {'non'*(0 != i%3)} divisible par 3.\")\n```\n\nLes f-strings sont plus rapides et plus lisibles que d'autres techniques pour créer des listes contenant des résultats. Il vaut donc mieux utiliser des f-string plutôt que faire des concaténations de listes avec `+`.\n\n:::\n\n\n## Récursive\n\n 2. Produire une version récursive de cette fonction\n\n```{python}\ndef fibonacci_rec(n: int) -> Node:\n    if n == 0:\n        return Node(1)\n    if n == 1:\n        return Node(1, Node(1))\n    recursion = fibonacci_rec(n - 1)\n    return Node(recursion.valeur + recursion.suivant.valeur,\n                recursion)\n\nfor n in range(10):\n    print(f\"fibonacci({n}) = {Liste(fibonacci(n))}\")\n```\n\n\n# interclassement\n\nOn s’intéresse dans cet exercice à deux méthodes d’interclassement de listes. L’interclassement vise à parcourir deux listes en parallèle et, à chaque itération, à insérer un élément venant de l’une ou de l’autre liste, dans la liste résultat. Le critère utilisé pour choisir la liste qui fournit l’élément à insérer suivant définit le type d’interclassement.\n\n\n\n\n## Interclassement strict\n\n 1. On s’intéresse tout d’abord à un interclassement strict qui insère alternativement un élément de la première liste puis un élément de la seconde liste. Dans le cas où une liste est plus courte que l’autre, les éléments restants de la plus longue sont insérés à la fin de la liste résultat sans interclassement. Plus précisément, si une liste est vide dès le début, la seconde est retournée. Si les deux listes sont vides, alors la liste vide (None) est retournée. Par exemple :\n\n\nOn commence par créer une fonction qui permet de copier une liste chaînée (créer une nouvelle liste qui contien les mêmes valeurs).\n```{python}\ndef copy(L: Node) -> Node:\n    \"\"\"Créer une copie d'une liste chaînée.\"\"\"\n    if L is None: return None\n    return Node(L.valeur, copy(L.suivant))\n```\n\n::: {.callout-tip collapse=true}\n## Version itérative de `copy`\n\nLa version itérative nécessite de garder à la fois un pointeur vers la position dans la liste originale et vers la fin de la nouvelle liste.\n\n```{python}\ndef copy_iter(L: Node) -> Node:\n    \"\"\"Créer une copie d'une liste chaînée.\"\"\"\n    if L is None: return None\n    res = Node(L.valeur)\n    p = res\n    q = L.suivant\n    while q is not None:\n        p.suivant = Node(q.valeur)\n        p = p.suivant\n        q = q.suivant\n    return res\n```\n:::\n\n\n### Itératif\n\n```{python}\ndef inter_strict_iter(L1: Node, L2: Node) -> Node:\n    if L1 is None: return copy(L2)\n    if L2 is None: return copy(L1)\n    res = Node(L1.valeur, Node(L2.valeur))\n    L1_p = L1.suivant\n    L2_p = L2.suivant\n    res_tail = res.suivant\n    while L1_p is not None and L2_p is not None:\n        res_tail.suivant = Node(L1_p.valeur, Node(L2_p.valeur))\n        res_tail = res_tail.suivant.suivant\n        L1_p = L1_p.suivant\n        L2_p = L2_p.suivant\n    if L1_p is None: res_tail.suivant = copy(L2_p)\n    if L2_p is None: res_tail.suivant = copy(L1_p)\n    return res\n\nL1 = Node(2, Node(6, Node(42, Node(73, Node(1237)))))\nL2 = Node(0, Node(1, Node(0)))\nprint(Liste(inter_strict_iter(L1, L2)))\n```\n\n\n\n\n### Récursif\n\n```{python}\ndef inter_strict_rec(L1: Node, L2: Node) -> Node:\n    if L1 is None or L2 is None: return None\n    return Node(L1.valeur, Node(L2.valeur,\n                inter_strict_rec(L1.suivant, L2.suivant)))\n\nL1 = Node('A', Node('B', Node('C', Node('D', Node('E')))))\nL2 = Node(0, Node(1, Node(2)))\nprint(Liste(inter_strict_iter(L1, L2)))\n```\n\n\n\n\n::: {.callout-tip collapse=true}\n## Avec `match`\n\nLe mot clef `match` de python permet de faire du \"_pattern matching_\", un peu comme en ocaml. Cette syntaxe (avec `match` et `case`) peut être plus lisible que des `if` dans certains cas.\n\nIci, on profite du fait d'avoir deux cas symétrique : si `L1` est `None` et si `L2` est `Non`. Dans chaque cas, il faut retourner une copie de l'autre liste.\n\nL'expression `(L, None) | (None, L)` va _matcher_ tous les cas où l'une des deux listes `(L1, L2)` est vide. Alors, `L` sera l'autre liste, exactement ce qu'il faut pour faire un `return copy(L)` !\n\n\n```{python}\ndef inter_strict_rec(L1: Node, L2: Node) -> Node:\n    match (L1, L2):\n        case (L, None) | (None, L): return copy(L)\n    return Node(L1.valeur, Node(L2.valeur,\n                inter_strict_rec(L1.suivant, L2.suivant)))\n\nL1 = Node('A', Node('B', Node('C', Node('D', Node('E')))))\nL2 = Node(0, Node(1, Node(2)))\nprint(Liste(inter_strict_iter(L1, L2)))\n```\n\n\nComme on fait un `return copy(L)`, on a pas besoin de préciser que le `return` récursif ne doit pas être exécuté dans tous les cas. Mais si on ne fait pas de `return`, on peut utiliser le cas `case other:`, qui correspondra à un `else` : il sera atteint seulement si aucun des autres cas ne sont trouvés.\n\n\n```{python}\nfor a in range(8):\n    match a:\n        case 0:\n            print(a, \"un nombre nul\")\n        case 1:\n            print(a, \"premier nombre, mais pas un nombre premier\")\n        case 2:\n            print(a, \"est le premier nombre premier\")\n        case 3:\n            print(a, \"est un autre nombre premier\")\n        case 4:\n            print(a, \"est le premier nombre pas premier\")\n        case 5:\n            print(a, \"est encore un nombre premier\")\n        case other:\n            print(a, \"est trop grand pour moi\")\n    # sera exécuté à chaque fois, quel que soit le match\n    print(\"--------------------------------------------\")\n```\n\n:::\n\n\n## Interclassement croissant\n\n\n 2. On considère maintenant deux listes de nombres `L1` et `L2` qui sont triées par ordre croissant. Écrire une fonction d’interclassement `interCroissant(L1, L2)` qui insère à chaque itération l’élément le plus petit qui se trouve en tête de liste soit de `L1` soit de `L2`. Un tel interclassement produit une liste fusionnée elle-même triée par ordre croissant. Proposer une solution itérative puis une solution récursive à ce problème.\n\n\n\n\n### Itératif\n\n```{python}\ndef inter_croissant_iter(L1: Node, L2: Node) -> Node:\n    if L1 is None: return copy(L2)\n    if L2 is None: return copy(L1)\n    L1_p = L1\n    L2_p = L2\n    # init 1ère valeur\n    res = None\n    if L1_p.valeur < L2_p.valeur:\n        res = Node(L1_p.valeur)\n        L1_p = L1_p.suivant\n    else:\n        res = Node(L2_p.valeur)\n        L2_p = L2_p.suivant\n    res_tail = res\n    while L1_p is not None and L2_p is not None:\n        if L1_p.valeur < L2_p.valeur:\n            res_tail.suivant = Node(L1_p.valeur)\n            res_tail = res_tail.suivant\n            L1_p = L1_p.suivant\n        else:\n            res_tail.suivant = Node(L2_p.valeur)\n            res_tail = res_tail.suivant\n            L2_p = L2_p.suivant\n    if L1_p is None:\n        res_tail.suivant = copy(L2_p)\n    elif L2_p is None:\n        res_tail.suivant = copy(L1_p)\n    return res\n\nL1 = Node(1, Node(6, Node(42, Node(73, Node(1237)))))\nL2 = Node(0, Node(12, Node(37, Node(67, Node(68)))))\nprint(Liste(inter_croissant_iter(L1, L2)))\n```\n\n\n### Récursif\n\n\n\n```{python}\ndef inter_croissant_rec(L1: Node, L2: Node) -> Node:\n    match (L1, L2):\n        case (L, None) | (None, L): return copy(L)\n        case (L1, L2) if L1.valeur < L2.valeur:\n            return Node(L1.valeur,\n                        inter_croissant_rec(L1.suivant, L2))\n        case other:\n            return Node(L2.valeur,\n                        inter_croissant_rec(L1, L2.suivant))\n\nL1 = Node(1, Node(6, Node(42, Node(73, Node(1237)))))\nL2 = Node(0, Node(12, Node(37, Node(67, Node(68)))))\nprint(Liste(inter_croissant_iter(L1, L2)))\n```\n\n\n# Calculatrice\n\nNous nous intéressons à la conception d’une calculatrice qui repose sur une représentation des opérations à l’aide d’une **pile**. De façon à mener à bien ce programme, il va donc falloir\n - implémenter les fonctions de la barrière d’abstraction de la structure pile de données (push, pop),\n - comprendre la notation postfixée pour la saisie des opérations\n\n\nDe manière traditionnelle, les opérations sont notées de manière infixée avec, dans le cas d’un opérateur binaire, le placement de l’opérateur entre les 2 opérandes. On obtient la notation suivante :\nDe manière traditionnelle, les opérations sont notées de manière infixée avec, dans le cas d’un opérateur binaire, le placement de l’opérateur entre les 2 opérandes. On obtient la notation suivante :\n$$\\text{opérande}_1 \\text{opérateur} \\text{opérande}_2$$\n\ncomme par exemple : $3 + 4$, $2.5 / 3.14 \\ldots$\n\nEn notation postfixée, l’opérateur succède à son (dans le cas d’un opérateur unaire) ou ses (dans le cas d’un opérateur binaire) opérande(s).\n\nAinsi : “$3+4$” s’écrit en postfixe “$3 4 +$”.\n\nL’intérêt d’une telle représentation est de pouvoir ensuite utiliser une pile pour réaliser les calculs en suivant le schéma de résolution suivant :\n\n - si la pile ne contient qu’une valeur réelle, il s’agit du résultat du calcul,\n - sinon on empile les valeurs réelles lorsqu’elles sont lues en entrée,\n - si on lit un caractère correspondant à un opérateur binaire on dépile les deux dernières valeurs réelles, on effectue le calcul et on empile le résultat,\n - si on lit un caractère correspondant à un opérateur unaire, comme l’opérateur de négation, on dépile la dernière valeur, on applique l’opérateur et on empile le résultat.\n\nAttention : la division est une loi non commutative, c’est-à-dire que $x/y \\neq y/x$. Il faut donc garder à l’esprit qu’en écrivant “$x y /$” en postifixé, l’opération souhaitée est $\\frac{x}{y}$ mais que du fait de l’utilisation d’une pile, la valeur de $y$ sera dépilée avant celle de $x$ (pile = dernier arrivé, premier sorti).\n\nDans le cadre de notre programme, les opérateurs suivants doivent être reconnus :\n\n - `+` : addition,\n - `-` : soustraction,\n - `*` : multiplication,\n - `/` division\n - `n` : négation\n\nSimilairement, on veillera à bien gérer les erreurs :\n\n• soit de division par 0,\n• soit de dépilement de valeur inexistante : par exemple, essayer de dépiler les deux opérandes d’un opérateur `+` alors qu’il n’y en a qu’un seul dans la pile\n\n## Notation postfixée\n\nIndiquer la traduction en notation postfixée des expressions suivantes exprimées en notation infixée (les parenthèses ne sont là que pour vous aider à comprendre la priorité des opérations) :\n\n - `(2 + 4) * n 5`\n     - `2 4 + 5 n *` ou bien `5 n 2 4 + *`\n - `9 / (3.5 + 6)`\n     - `9 3.5 6 + /`\n - `(3 - 5) / (3 + 5)`\n     - `3 5 - 3 5 + /`\n\n\n\n## Caculatrice\n\n 2. Implémenter une calculatrice simple en notation postfixée sur la base d’une pile gérée par votre barrière d’abstraction.\n\n### Pile\n\n::: {.callout-note collapse=true}\n## Notes sur l'implémentation\n\n - Le dessus de la pile (la tête de la pile) sera la tête de liste (le premier élément de la liste), pour minimiser la complexité des opérations de base.\n - Les opérations sur les piles seront faîtes en-place (\"_in place_\"), c'est-à-dire que les listes seront modifiées (une nouvelle liste ne sera pas créée à chaque fois)\n - On peut alors avoir un `push` et un `pop` en $O(1)$\n\n:::\n\n#### Push\n\n```{python}\ndef push(L: Node, valeur) -> Node:\n    return Node(valeur, L)\n\nA = Node(1, Node(2))\nA = push(A, 42)\nprint(Liste(A))\n```\n\n#### Get\n\n```{python}\ndef get(L: Node) -> Node:\n    if L is None:\n        return None\n    return L.valeur\n\nprint(Liste(A))\nprint(get(A))\n```\n\n#### Del\n\n```{python}\ndef delete(L: Node) -> Node:\n    if L is None:\n        return None\n    return L.suivant\n```\n\n#### Pop\n\n```{python}\ndef pop(L: Node) -> (Node, object):\n    if L is None:\n        raise ValueError(\"pop from empty stack.\")\n    return delete(L), get(L)\n\nprint(Liste(A))\nval, A = pop(A)\nprint(val, A)\n```\n\n\n#### Is empty\n\n```{python}\ndef is_empty(L: Node) -> bool:\n    return L is None\n\nprint(is_empty(None))\nprint(is_empty(Node(1, Node(2))))\n```\n\n#### Height\n\n```{python}\ndef height(L: Node) -> int:\n    if is_empty(L):\n        return 0\n    return 1 + height(L.suivant)\n\nL = Node(1, Node(2, Node(3, Node(42))))\nprint(height(L))\n```\n\n\n\n### Abstraction de la calculatrice\n\n\nOn créée d'abord une fonction qui permet d'appliquer un opérateur binaire à une pile (sur les deux premiers éléments).\n\n```{python}\ndef appliquer(bin_operator, L: Node) -> Node:\n    \"\"\"Appliquer `bin_operator` sur les deux premières valeurs de la pile.\n\n    Le premier paramètre donné à `bin_operator` est le dessus de la pile, et le\n    second est le second élément de la pile.\n    \"\"\"\n    if L is None:\n        raise ValueError(\"applying operator on empty stack\")\n    if L.suivant is None:\n        raise ValueError(\"applying operator on stack with only one element\")\n    return Node(bin_operator(L.valeur, L.suivant.valeur), L.suivant.suivant)\n    L, first = pop(L)\n    L, second = pop(L)\n    result = bin_operator(first, second)\n    return push(result, L)\n\nA = Node(3, Node(2, Node(4, Node(1, Node(5)))))\nadd = lambda x, y: x+y\ndiv = lambda x, y: y / x\nA = appliquer(add, A)\nprint(Liste(A))\nA = appliquer(div, A)\nprint(Liste(A))\n```\n\n#### Opérateurs de base\n\n```{python}\ndef add(L: Node) -> Node:\n    return appliquer(lambda x, y: x+y, L)\n\ndef sub(L: Node) -> Node:\n    return appliquer(lambda x, y: y - x, L)\n\ndef mult(L: Node) -> Node:\n    return appliquer(lambda x, y: x * y, L)\n\ndef div(L: Node) -> Node:\n    return appliquer(lambda x, y: y / x, L)\n\nA = Node(3, Node(2, Node(1, Node(1, Node(5)))))\nprint(Liste(A))\nA = add(A)\nprint(Liste(A))\nA = sub(A)\nprint(Liste(A))\nA = div(A)\nprint(Liste(A))\nA = mult(A)\nprint(Liste(A))\n```\n\n\n#### Opérations unaires\n\nLes opérations unaires sont des opérations qui modifient uniquement le premier élément de la pile.\n\n```{python}\ndef appliquer_unaire(operation, L: Node) -> Node:\n    if L is None:\n        raise ValueError(\"cannot apply unary function to an empty stack\")\n    return Node(operation(L.valeur), L.suivant)\n```\n\nVoici quelques opérations unaires utiles :\n\n```{python}\ndef neg(L: Node) -> Node:\n    \"\"\"Négation : transformer la première valeur de la pile en son opposé.\n    \"\"\"\n    return appliquer_unaire(lambda x: -x, L)\n\ndef inv(L: Node) -> Node:\n    \"\"\"Inversion : inverser le premier élément de la pile (l'inverse de x est 1/x).\n    \"\"\"\n    return appliquer_unaire(lambda x: 1/x, L)\n\nprint(Liste(A))\nA = neg(A)\nprint(Liste(A))\nA = inv(A)\nprint(Liste(A))\n```\n\n\n\n#### Affichage d'une pile\n\nOn veut afficher la pile avec la tête en base, pour que les nombres les plus récents soient plus près de l'entrée utilisateur.\n\n```{python}\ndef stack_to_list(L: Node) -> list:\n    if L is None: return []\n    return [L.valeur] + stack_to_list(L.suivant)\n\ndef show_stack(L: Node) -> None:\n    # pour afficher la liste la tête en bas, on retourne la liste\n    print(*reversed(stack_to_list(L)), sep='\\n')\n\nL = Node(1, Node(2, Node(3, Node(4, Node(5)))))\nshow_stack(L)\n```\n\n#### Traduction des commandes\n\nOn veut créer une fonction qui transforme une liste selon une chaîne de caractères donnée, qui représente l'opération voulue.\n\nOn pourrait utiliser des structures `if ... elif ... elif ... else`, ainsi que des clauses `or` pour tester les différentes commandes, mais la structure `match` (apparue dans la version 3.10 de python) permet une syntaxe plus claire, et des expressions plus riches.\n\n```{python}\n\ndef appliquer_str(op_str: str, L: Node) -> Node:\n    \"\"\"Appliquer l'opération désignée par `op_str` sur `L`.\n    Exemples :\n    >>> appliquer_str(\"+\", Node(1, Node(2))) # donne Node(3)\n    >>> appliquer_str(\"/\", Node(5, Node(2))) # donne Node(0.4)\n    \"\"\"\n    match op_str:\n        case \"+\" | \"add\":\n            return add(L)\n        case \"-\" | \"sub\" | \"subs\":\n            return sub(L)\n        case \"*\" | \"mul\" | \"mult\" | \"times\":\n            return mult(L)\n        case \"/\" | \"÷\" | \"div\" | \"divide\":\n            return div(L)\n        case \"-\" | \"neg\" | \"negate\" | \"oppose\" | \"opposite\":\n            return neg(L)\n        case \"inv\" | \"invs\" | \"inverse\":\n            return inv(L)\n        case \"pop\" | \"del\":\n            return pop(L)\n\n\n```\n\n\n\n\n\n","srcMarkdownNoYaml":"\n\n::: {.callout-tip collapse=true}\n\n## Définition d'une liste chaînée\n\n```{python}\n\nclass Node:\n    def __init__(self, valeur, suivant: 'Node' =None):\n        self.valeur = valeur\n        self.suivant = suivant\n\nclass Liste:\n    def __init__(self, head: Node):\n        self.head = head\n\n    def __str__(self) -> str:\n        return \"(\" + \",\".join(map(lambda e: str(Liste(e) if isinstance(e, Node) else e),\n                                  self.to_list())) + \")\"\n\n    def to_list(self) -> list:\n        if self.head is None:\n            return []\n        return [self.head.valeur] + self.cdr().to_list()\n\n    def __len__(self) -> int:\n        \"\"\"Longueur de la liste.\n        \"\"\"\n        if self.head is None:\n            return 0\n        return 1 + len(self.head.suivant)\n\n    def append(self, valeur) -> None:\n        \"\"\"Ajouter une valeur à la fin de la liste.\n        \"\"\"\n        # cas de base :\n        # on doit s'arrêter dès que la liste est terminer\n        if self.head.suivant is None:\n            # on créé un nouveau Node\n            self.head.suivant = Node(valeur)\n        # récursion pour atteindre la fin de la liste\n        self.cdr().append(valeur)\n\n    def car(self):\n        \"\"\"Récupérer la valeur en tête de liste\n        \"\"\"\n        return self.head.value\n\n    def cdr(self) -> 'Liste':\n        \"\"\"Récupérer la liste sans son premier élément.\n        \"\"\"\n        if self.head is None:\n            return None\n        return Liste(self.head.suivant)\n\n    def last(self):\n        \"\"\"Récupérer le dernier élément de la liste.\n        \"\"\"\n        if self.head.suivant is None:\n            return self.last(Liste(self.head.suivant))\n        return self.head.valeur\n```\n\n:::\n\n# Bégaie - De bégaie\n\n\n> On dit qu'une liste est “bégayée” lorsque chaque élément y\n> apparaît deux fois de suite. Le but de cet exercice est de\n> transformer une liste en une liste bégayée, et inversement\n> de “dé bégayer” une liste en supprimant un élément sur\n> deux.\n\n## Bégaie\n\n### Fonction itérative\n\n> écrire la fonction itérative `begaie` qui, étant donnée\n> une liste d’éléments, renvoie la liste où chaque élément\n> est répété. Par exemple : `begaie(1,2,3,1,4) =\n> (1,1,2,2,3,3,1,1,4,4)` et `begaie(None) = None`.\n\n```{python}\ndef begaie(L: Node) -> Node:\n    p = L\n    while p is not None:\n        # insérer un mode contenant la même valeur\n        tmp = Node(p.valeur, p.suivant)\n        p.suivant = tmp\n        # on passe au pointeur suivant\n        p = p.suivant.suivant\n    return L\n```\n\nOn peut tester :\n\n```{python}\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nprint(Liste(L))\nprint(Liste(begaie(L)))\n```\n\nEt on a bien :\n\n```{python}\nprint(begaie(None))\n```\n\n\n\n### Fonction récursive\n\n> Donner maintenant une fonction récursive `begaieRec` qui\n> effectue le même traitement que la fonction `begaie`\n> précédente\n\n```{python}\ndef begaieRec(L: Node) -> Node:\n    if L is None:\n        return None\n    return Node(L.valeur, Node(L.valeur, begaieRec(L.suivant)))\n```\n\nElle fonctionne également :\n\n```{python}\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nprint(Liste(L))\n# La fonction modifie la valeur de L, donc on pourrait\n# simplement appeler la fonction, sans modifier\n# explicitement L (sans mettre le `L = `)\nL = begaie(L)\n```\n\n## Dé bégaie\n\n\n### Fonction itérative\n\n> Écrire maintenant la fonction itérative `debegaie` qui\n> prend en argument une liste bégayée et retourne la liste\n> privée de ses doublons. La fonction de bégaie est telle que\n> `debegaie(begaie(L)) = L`\n\n```{python}\ndef debegaie(L: Node) -> Node:\n    if L is None:\n        return None\n    p = L\n    # on est obligé \n    while p.suivant.suivant is not None:\n        p.suivant = p.suivant.suivant\n        p = p.suivant\n    # on retire le dernier élément\n    # p.suivant = None\n    return L\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nL = begaie(L)\nprint(Liste(L))\nL = debegaie(L)\nprint(Liste(L))\n```\n\n\n### Fonction récursive\n\n> Écrire enfin la fonction récursive `debegaieRec` qui\n> réalise le même traitement que la fonction `debegaie`.\n\n\n\n```{python}\ndef debegaieRec(L: Node) -> Node:\n    # cas de base\n    if L is None:\n        return None\n    # on doit ajouter ce cas de base car on utilise\n    # L.suivant.suivant, donc L.suivant ne doit pas être None\n    if L.suivant is None:\n        return None\n    # On créée une nouvelle liste qui saute un élément\n    return Node(L.valeur, debegaieRec(L.suivant.suivant))\n\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nL = begaie(L)\nprint(Liste(L))\nL = debegaie(L)\nprint(Liste(L))\n```\n\n# Implémentation de la fonction `zip`\n\nDe très nombreux langages de programmations permettent de\ntravailler sur des structures de listes chaînées. Le langage\nPython notamment permet de travailler nativement avec les\nlistes et implémente la fonction `zip(l1, l2)` qui permet, à partir de 2 listes de même longueur de construire une liste contenant les couples de valeurs formés des éléments de même indice issu des 2 listes. Par exemple :\n\n```{python}\nZ = zip((1, 2, 3), (\"a\", \"b\", \"c\" ))\nprint(list(Z))\n```\n\n## Itérative\n\n 1. Écrire la fonction itérative zip(l1, l2) qui permet d’obtenir le résultat désiré en suivant le formalisme des listes chaînées étudiées en cours. On supposera les listes en argument de même taille et non vides.\n\n\n```{python}\ndef zip_iter(L1: Node, L2: Node) -> Node:\n    p = L1\n    q = L2\n    res = None\n    last = None\n    while p is not None and q is not None:\n        if res is None:\n            res = Node(Node(p.valeur, Node(q.valeur)))\n            last = res\n        else:\n            last.suivant = Node(Node(p.valeur, Node(q.valeur)))\n            last = last.suivant\n        p = p.suivant\n        q = q.suivant\n    return res\n\nL1 = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9, Node(2)))))))\nL2 = Node(1, Node(6, Node(1, Node(8, Node(0, Node(3, Node(3)))))))\nprint(Liste(zip_iter(L1, L2)))\nprint(Liste(L1), Liste(L2))\n```\n\n## Récursive\n\n 2. Produire une solution récursive équivalente.\n\n```{python}\ndef zip_rec(L1: Node, L2: Node) -> Node:\n    if L1 is None or L2 is None:\n        return None\n    return Node(Node(L1.valeur, Node(L2.valeur)),\n                zip_rec(L1.suivant, L2.suivant))\n\n\nL1 = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9, Node(2)))))))\nL2 = Node(1, Node(6, Node(1, Node(8, Node(0, Node(3, Node(3)))))))\nL3 = Node(1, Node(2, Node(3)))\nprint(Liste(zip_rec(L1, L2)))\nprint(Liste(zip_rec(L1, L3)))\n```\n\n\n# Liste croisante\n\nOn considère dans cet exercice une liste contenant des valeurs comparables grâce à l’opérateur `<=`.\n\n## Itérative\n\n 1. Écrire la fonction itérative `croissante(L)` qui prend en argument une telle liste et retourne `True` si et seulement si la liste est triée par ordre croissant au sens large.\n\nOn implémentera la fonction en considérant les cas de base suivants :\n - une liste vide est considérée comme triée par ordre croissant\n - une liste avec un seul élément est croissante également\n\n```{python}\ndef croissante_iter(L: Node) -> bool:\n    if L is None: return True\n    p = L\n    while p.suivant is not None:\n        # si deux éléments sont dans un ordre décroissant\n        if p.valeur > p.suivant.valeur:\n            # on sait que la liste n'est pas croissante\n            return False\n        p = p.suivant\n    # si on a trouvé aucune valeur décroissante dans la liste, on sait qu'elle\n    # est croissante\n    return True\n\nL = Node(1, Node(6, Node(6, Node(42, Node(73)))))\nprint(croissante_iter(L))  # True\nL = Node(1, Node(6, Node(0, Node(42))))\nprint(croissante_iter(L))  # False\n```\n\n## Récursive\n\n2. Proposer une solution récursive.\n\n```{python}\ndef croissante_rec(L: Node) -> bool:\n    if L is None: return True\n    if L.suivant is None: return True\n    # si les valeurs en tête sont décroissantes\n    if L.valeur > L.suivant.valeur:\n        return False\n    return croissante_rec(L.suivant)\n\nL = Node(1, Node(6, Node(6, Node(42, Node(73)))))\nprint(croissante_iter(L))  # True\nL = Node(1, Node(6, Node(0, Node(42))))\nprint(croissante_iter(L))  # False\n```\n\n# Suppression des occurrences d’un élément\n\nNous nous intéressons maintenant à la suppression d’un élément quelconque dans une liste chaînée.\n\n## Itérative\n\n 1. Écrire une fonction itérative `removeAll(L, elem)` qui prend en argument une liste chaînée `L` et une valeur `elem` et retourne la liste privée de ses éléments `elem`.\n\n```{python}\ndef remove_all_iter(L: Node, elem) -> Node:\n    if L is None: return None\n    # on cherche la première valeur\n    while L.valeur == elem:\n        L = L.suivant\n        # si on a passé toutes les valeurs, c'est que la liste ne contient que\n        # des valeurs à supprimer :\n        if L is None: return None\n    res = Node(L.valeur)\n    res_tl = res\n    while L is not None:\n        if L.valeur != elem:\n            res_tl.suivant = Node(L.valeur)\n            res_tl = res_tl.suivant\n        L = L.suivant\n    return res\n\nprint(\"Liste vide :\", remove_all_iter(None, 9))\n\nL = Node(42, Node(42, Node(42, Node(42, Node(42, Node(42, Node(42)))))))\nprint(\"Liste à supprimer complètement :\",\n      Liste(remove_all_iter(L, 42)))\n\nL = Node(73, Node(73, Node(73, Node(42, Node(42)))))\nprint(\"Liste qui commmence par les éléments à supprimer :\",\n      Liste(remove_all_iter(L, 73)))\n\nL = Node(1, Node(1, Node(1, Node(8, Node(1, Node(3, Node(3)))))))\nprint(\"Liste mixte :\",\n      Liste(remove_all_iter(L, 1)))\n```\n\n\n## Récursive\n\n 2. Proposer une solution récursive à ce problème.\nIndications : pensez à différencier les cas suivants :\n\n - la liste est vide initialement,\n - la liste ne contient que l’élément à supprimer,\n - la liste commence par les éléments à supprimer,\n - la liste est mixte : composée pour une part de l’élément à supprimer et pour une autre part d’autres éléments à conserver.\n\n\n```{python}\ndef remove_all(L: Node, elem) -> Node:\n    if L is None: return None\n    if L.valeur == elem:\n        return remove_all(L.suivant, elem)\n    return Node(L.valeur, remove_all(L.suivant, elem))\n\nprint(\"Liste vide :\", remove_all_iter(None, 9))\n\nL = Node(42, Node(42, Node(42, Node(42, Node(42, Node(42, Node(42)))))))\nprint(\"Liste à supprimer complètement :\",\n      Liste(remove_all_iter(L, 42)))\n\nL = Node(73, Node(73, Node(73, Node(42, Node(42)))))\nprint(\"Liste qui commmence par les éléments à supprimer :\",\n      Liste(remove_all_iter(L, 73)))\n\nL = Node(1, Node(1, Node(1, Node(8, Node(1, Node(3, Node(3)))))))\nprint(\"Liste mixte :\",\n      Liste(remove_all_iter(L, 1)))\n```\n\n\n# Suite de Fibonacci\n\nLa suite de Fibonacci est définie comme suit :\n\n - $f_0 = 1$\n - $f_1 = 1$\n - $f_n = f_{n-1} + f_{n-2}$ si $n > 1$\n\n\n## Itérative\n\n 1. Écrire la définition de la fonction itérative `fibonacci(n)` qui, étant donné un entier naturel `n` renvoie la liste $(f_n, f_{n−1}, f_{n−2}, \\ldots, f_1, f_0)$ où les fi sont les termes de la suite de Fibonacci.\n\nPar exemple :\n\n```python\nfibonacci(0) = (1)\nfibonacci(1) = (1, 1)\nfibonacci(4) = (1, 1, 2, 3, 5)\nfibonacci(5) = (1, 1, 2, 3, 5, 8)\n```\n\n```{python}\ndef fibonacci(n: int) -> Node:\n    if n == 0:\n        return Node(1)\n    res = Node(1, Node(1))\n    # on a déjà fait la 1ère étape en définissant res, donc on peut diminuer n\n    n -= 1\n    # _ est un nom de variable que l'on utilise quand on sait que l'on ne va\n    # pas utiliser cette variable.\n    for _ in range(n):\n        # somme de la dernière et l'avant dernière valeur\n        res = Node(res.valeur + res.suivant.valeur, res)\n    return res\n\nfor n in range(10):\n    print(f\"fibonacci({n}) = {Liste(fibonacci(n))}\")\n```\n\n::: {.callout-tip collapse=true}\n## Les f-string en python\n\nLes \"*f-strings*\" sont des chaînes de caractères (*strings*) devant lesquelles on met un `f`.\n\nCela permet de mettre du code à l'intérieur, qui sera évalué et intégré dans la chaîne.\n\nPar exemple :\n\n```{python}\nfor i in range(5):\n    print(f\"{i*10}km à pied, ça use les souliers.\")\n```\n\nIci, on voit que c'est l'expression entourée par des accolades `{...}` qui est évaluée. Elle est bien intégrée dans le reste de la chaîne de caractères.\n\nBien sûr, il est possible de mettre plusieurs expressions dans une même f-string :\n\n```{python}\nfor i in range(5):\n    print(f\"{i} au carré donne {i**2}\")\n```\n\nEt on peut même imaginer ce genre d'exemples :\n\n```{python}\nfor i in range(5):\n    print(f\"{i} est un nombre {'impair' if i%2 else 'pair'} et {'non'*(0 != i%3)} divisible par 3.\")\n```\n\nLes f-strings sont plus rapides et plus lisibles que d'autres techniques pour créer des listes contenant des résultats. Il vaut donc mieux utiliser des f-string plutôt que faire des concaténations de listes avec `+`.\n\n:::\n\n\n## Récursive\n\n 2. Produire une version récursive de cette fonction\n\n```{python}\ndef fibonacci_rec(n: int) -> Node:\n    if n == 0:\n        return Node(1)\n    if n == 1:\n        return Node(1, Node(1))\n    recursion = fibonacci_rec(n - 1)\n    return Node(recursion.valeur + recursion.suivant.valeur,\n                recursion)\n\nfor n in range(10):\n    print(f\"fibonacci({n}) = {Liste(fibonacci(n))}\")\n```\n\n\n# interclassement\n\nOn s’intéresse dans cet exercice à deux méthodes d’interclassement de listes. L’interclassement vise à parcourir deux listes en parallèle et, à chaque itération, à insérer un élément venant de l’une ou de l’autre liste, dans la liste résultat. Le critère utilisé pour choisir la liste qui fournit l’élément à insérer suivant définit le type d’interclassement.\n\n\n\n\n## Interclassement strict\n\n 1. On s’intéresse tout d’abord à un interclassement strict qui insère alternativement un élément de la première liste puis un élément de la seconde liste. Dans le cas où une liste est plus courte que l’autre, les éléments restants de la plus longue sont insérés à la fin de la liste résultat sans interclassement. Plus précisément, si une liste est vide dès le début, la seconde est retournée. Si les deux listes sont vides, alors la liste vide (None) est retournée. Par exemple :\n\n\nOn commence par créer une fonction qui permet de copier une liste chaînée (créer une nouvelle liste qui contien les mêmes valeurs).\n```{python}\ndef copy(L: Node) -> Node:\n    \"\"\"Créer une copie d'une liste chaînée.\"\"\"\n    if L is None: return None\n    return Node(L.valeur, copy(L.suivant))\n```\n\n::: {.callout-tip collapse=true}\n## Version itérative de `copy`\n\nLa version itérative nécessite de garder à la fois un pointeur vers la position dans la liste originale et vers la fin de la nouvelle liste.\n\n```{python}\ndef copy_iter(L: Node) -> Node:\n    \"\"\"Créer une copie d'une liste chaînée.\"\"\"\n    if L is None: return None\n    res = Node(L.valeur)\n    p = res\n    q = L.suivant\n    while q is not None:\n        p.suivant = Node(q.valeur)\n        p = p.suivant\n        q = q.suivant\n    return res\n```\n:::\n\n\n### Itératif\n\n```{python}\ndef inter_strict_iter(L1: Node, L2: Node) -> Node:\n    if L1 is None: return copy(L2)\n    if L2 is None: return copy(L1)\n    res = Node(L1.valeur, Node(L2.valeur))\n    L1_p = L1.suivant\n    L2_p = L2.suivant\n    res_tail = res.suivant\n    while L1_p is not None and L2_p is not None:\n        res_tail.suivant = Node(L1_p.valeur, Node(L2_p.valeur))\n        res_tail = res_tail.suivant.suivant\n        L1_p = L1_p.suivant\n        L2_p = L2_p.suivant\n    if L1_p is None: res_tail.suivant = copy(L2_p)\n    if L2_p is None: res_tail.suivant = copy(L1_p)\n    return res\n\nL1 = Node(2, Node(6, Node(42, Node(73, Node(1237)))))\nL2 = Node(0, Node(1, Node(0)))\nprint(Liste(inter_strict_iter(L1, L2)))\n```\n\n\n\n\n### Récursif\n\n```{python}\ndef inter_strict_rec(L1: Node, L2: Node) -> Node:\n    if L1 is None or L2 is None: return None\n    return Node(L1.valeur, Node(L2.valeur,\n                inter_strict_rec(L1.suivant, L2.suivant)))\n\nL1 = Node('A', Node('B', Node('C', Node('D', Node('E')))))\nL2 = Node(0, Node(1, Node(2)))\nprint(Liste(inter_strict_iter(L1, L2)))\n```\n\n\n\n\n::: {.callout-tip collapse=true}\n## Avec `match`\n\nLe mot clef `match` de python permet de faire du \"_pattern matching_\", un peu comme en ocaml. Cette syntaxe (avec `match` et `case`) peut être plus lisible que des `if` dans certains cas.\n\nIci, on profite du fait d'avoir deux cas symétrique : si `L1` est `None` et si `L2` est `Non`. Dans chaque cas, il faut retourner une copie de l'autre liste.\n\nL'expression `(L, None) | (None, L)` va _matcher_ tous les cas où l'une des deux listes `(L1, L2)` est vide. Alors, `L` sera l'autre liste, exactement ce qu'il faut pour faire un `return copy(L)` !\n\n\n```{python}\ndef inter_strict_rec(L1: Node, L2: Node) -> Node:\n    match (L1, L2):\n        case (L, None) | (None, L): return copy(L)\n    return Node(L1.valeur, Node(L2.valeur,\n                inter_strict_rec(L1.suivant, L2.suivant)))\n\nL1 = Node('A', Node('B', Node('C', Node('D', Node('E')))))\nL2 = Node(0, Node(1, Node(2)))\nprint(Liste(inter_strict_iter(L1, L2)))\n```\n\n\nComme on fait un `return copy(L)`, on a pas besoin de préciser que le `return` récursif ne doit pas être exécuté dans tous les cas. Mais si on ne fait pas de `return`, on peut utiliser le cas `case other:`, qui correspondra à un `else` : il sera atteint seulement si aucun des autres cas ne sont trouvés.\n\n\n```{python}\nfor a in range(8):\n    match a:\n        case 0:\n            print(a, \"un nombre nul\")\n        case 1:\n            print(a, \"premier nombre, mais pas un nombre premier\")\n        case 2:\n            print(a, \"est le premier nombre premier\")\n        case 3:\n            print(a, \"est un autre nombre premier\")\n        case 4:\n            print(a, \"est le premier nombre pas premier\")\n        case 5:\n            print(a, \"est encore un nombre premier\")\n        case other:\n            print(a, \"est trop grand pour moi\")\n    # sera exécuté à chaque fois, quel que soit le match\n    print(\"--------------------------------------------\")\n```\n\n:::\n\n\n## Interclassement croissant\n\n\n 2. On considère maintenant deux listes de nombres `L1` et `L2` qui sont triées par ordre croissant. Écrire une fonction d’interclassement `interCroissant(L1, L2)` qui insère à chaque itération l’élément le plus petit qui se trouve en tête de liste soit de `L1` soit de `L2`. Un tel interclassement produit une liste fusionnée elle-même triée par ordre croissant. Proposer une solution itérative puis une solution récursive à ce problème.\n\n\n\n\n### Itératif\n\n```{python}\ndef inter_croissant_iter(L1: Node, L2: Node) -> Node:\n    if L1 is None: return copy(L2)\n    if L2 is None: return copy(L1)\n    L1_p = L1\n    L2_p = L2\n    # init 1ère valeur\n    res = None\n    if L1_p.valeur < L2_p.valeur:\n        res = Node(L1_p.valeur)\n        L1_p = L1_p.suivant\n    else:\n        res = Node(L2_p.valeur)\n        L2_p = L2_p.suivant\n    res_tail = res\n    while L1_p is not None and L2_p is not None:\n        if L1_p.valeur < L2_p.valeur:\n            res_tail.suivant = Node(L1_p.valeur)\n            res_tail = res_tail.suivant\n            L1_p = L1_p.suivant\n        else:\n            res_tail.suivant = Node(L2_p.valeur)\n            res_tail = res_tail.suivant\n            L2_p = L2_p.suivant\n    if L1_p is None:\n        res_tail.suivant = copy(L2_p)\n    elif L2_p is None:\n        res_tail.suivant = copy(L1_p)\n    return res\n\nL1 = Node(1, Node(6, Node(42, Node(73, Node(1237)))))\nL2 = Node(0, Node(12, Node(37, Node(67, Node(68)))))\nprint(Liste(inter_croissant_iter(L1, L2)))\n```\n\n\n### Récursif\n\n\n\n```{python}\ndef inter_croissant_rec(L1: Node, L2: Node) -> Node:\n    match (L1, L2):\n        case (L, None) | (None, L): return copy(L)\n        case (L1, L2) if L1.valeur < L2.valeur:\n            return Node(L1.valeur,\n                        inter_croissant_rec(L1.suivant, L2))\n        case other:\n            return Node(L2.valeur,\n                        inter_croissant_rec(L1, L2.suivant))\n\nL1 = Node(1, Node(6, Node(42, Node(73, Node(1237)))))\nL2 = Node(0, Node(12, Node(37, Node(67, Node(68)))))\nprint(Liste(inter_croissant_iter(L1, L2)))\n```\n\n\n# Calculatrice\n\nNous nous intéressons à la conception d’une calculatrice qui repose sur une représentation des opérations à l’aide d’une **pile**. De façon à mener à bien ce programme, il va donc falloir\n - implémenter les fonctions de la barrière d’abstraction de la structure pile de données (push, pop),\n - comprendre la notation postfixée pour la saisie des opérations\n\n\nDe manière traditionnelle, les opérations sont notées de manière infixée avec, dans le cas d’un opérateur binaire, le placement de l’opérateur entre les 2 opérandes. On obtient la notation suivante :\nDe manière traditionnelle, les opérations sont notées de manière infixée avec, dans le cas d’un opérateur binaire, le placement de l’opérateur entre les 2 opérandes. On obtient la notation suivante :\n$$\\text{opérande}_1 \\text{opérateur} \\text{opérande}_2$$\n\ncomme par exemple : $3 + 4$, $2.5 / 3.14 \\ldots$\n\nEn notation postfixée, l’opérateur succède à son (dans le cas d’un opérateur unaire) ou ses (dans le cas d’un opérateur binaire) opérande(s).\n\nAinsi : “$3+4$” s’écrit en postfixe “$3 4 +$”.\n\nL’intérêt d’une telle représentation est de pouvoir ensuite utiliser une pile pour réaliser les calculs en suivant le schéma de résolution suivant :\n\n - si la pile ne contient qu’une valeur réelle, il s’agit du résultat du calcul,\n - sinon on empile les valeurs réelles lorsqu’elles sont lues en entrée,\n - si on lit un caractère correspondant à un opérateur binaire on dépile les deux dernières valeurs réelles, on effectue le calcul et on empile le résultat,\n - si on lit un caractère correspondant à un opérateur unaire, comme l’opérateur de négation, on dépile la dernière valeur, on applique l’opérateur et on empile le résultat.\n\nAttention : la division est une loi non commutative, c’est-à-dire que $x/y \\neq y/x$. Il faut donc garder à l’esprit qu’en écrivant “$x y /$” en postifixé, l’opération souhaitée est $\\frac{x}{y}$ mais que du fait de l’utilisation d’une pile, la valeur de $y$ sera dépilée avant celle de $x$ (pile = dernier arrivé, premier sorti).\n\nDans le cadre de notre programme, les opérateurs suivants doivent être reconnus :\n\n - `+` : addition,\n - `-` : soustraction,\n - `*` : multiplication,\n - `/` division\n - `n` : négation\n\nSimilairement, on veillera à bien gérer les erreurs :\n\n• soit de division par 0,\n• soit de dépilement de valeur inexistante : par exemple, essayer de dépiler les deux opérandes d’un opérateur `+` alors qu’il n’y en a qu’un seul dans la pile\n\n## Notation postfixée\n\nIndiquer la traduction en notation postfixée des expressions suivantes exprimées en notation infixée (les parenthèses ne sont là que pour vous aider à comprendre la priorité des opérations) :\n\n - `(2 + 4) * n 5`\n     - `2 4 + 5 n *` ou bien `5 n 2 4 + *`\n - `9 / (3.5 + 6)`\n     - `9 3.5 6 + /`\n - `(3 - 5) / (3 + 5)`\n     - `3 5 - 3 5 + /`\n\n\n\n## Caculatrice\n\n 2. Implémenter une calculatrice simple en notation postfixée sur la base d’une pile gérée par votre barrière d’abstraction.\n\n### Pile\n\n::: {.callout-note collapse=true}\n## Notes sur l'implémentation\n\n - Le dessus de la pile (la tête de la pile) sera la tête de liste (le premier élément de la liste), pour minimiser la complexité des opérations de base.\n - Les opérations sur les piles seront faîtes en-place (\"_in place_\"), c'est-à-dire que les listes seront modifiées (une nouvelle liste ne sera pas créée à chaque fois)\n - On peut alors avoir un `push` et un `pop` en $O(1)$\n\n:::\n\n#### Push\n\n```{python}\ndef push(L: Node, valeur) -> Node:\n    return Node(valeur, L)\n\nA = Node(1, Node(2))\nA = push(A, 42)\nprint(Liste(A))\n```\n\n#### Get\n\n```{python}\ndef get(L: Node) -> Node:\n    if L is None:\n        return None\n    return L.valeur\n\nprint(Liste(A))\nprint(get(A))\n```\n\n#### Del\n\n```{python}\ndef delete(L: Node) -> Node:\n    if L is None:\n        return None\n    return L.suivant\n```\n\n#### Pop\n\n```{python}\ndef pop(L: Node) -> (Node, object):\n    if L is None:\n        raise ValueError(\"pop from empty stack.\")\n    return delete(L), get(L)\n\nprint(Liste(A))\nval, A = pop(A)\nprint(val, A)\n```\n\n\n#### Is empty\n\n```{python}\ndef is_empty(L: Node) -> bool:\n    return L is None\n\nprint(is_empty(None))\nprint(is_empty(Node(1, Node(2))))\n```\n\n#### Height\n\n```{python}\ndef height(L: Node) -> int:\n    if is_empty(L):\n        return 0\n    return 1 + height(L.suivant)\n\nL = Node(1, Node(2, Node(3, Node(42))))\nprint(height(L))\n```\n\n\n\n### Abstraction de la calculatrice\n\n\nOn créée d'abord une fonction qui permet d'appliquer un opérateur binaire à une pile (sur les deux premiers éléments).\n\n```{python}\ndef appliquer(bin_operator, L: Node) -> Node:\n    \"\"\"Appliquer `bin_operator` sur les deux premières valeurs de la pile.\n\n    Le premier paramètre donné à `bin_operator` est le dessus de la pile, et le\n    second est le second élément de la pile.\n    \"\"\"\n    if L is None:\n        raise ValueError(\"applying operator on empty stack\")\n    if L.suivant is None:\n        raise ValueError(\"applying operator on stack with only one element\")\n    return Node(bin_operator(L.valeur, L.suivant.valeur), L.suivant.suivant)\n    L, first = pop(L)\n    L, second = pop(L)\n    result = bin_operator(first, second)\n    return push(result, L)\n\nA = Node(3, Node(2, Node(4, Node(1, Node(5)))))\nadd = lambda x, y: x+y\ndiv = lambda x, y: y / x\nA = appliquer(add, A)\nprint(Liste(A))\nA = appliquer(div, A)\nprint(Liste(A))\n```\n\n#### Opérateurs de base\n\n```{python}\ndef add(L: Node) -> Node:\n    return appliquer(lambda x, y: x+y, L)\n\ndef sub(L: Node) -> Node:\n    return appliquer(lambda x, y: y - x, L)\n\ndef mult(L: Node) -> Node:\n    return appliquer(lambda x, y: x * y, L)\n\ndef div(L: Node) -> Node:\n    return appliquer(lambda x, y: y / x, L)\n\nA = Node(3, Node(2, Node(1, Node(1, Node(5)))))\nprint(Liste(A))\nA = add(A)\nprint(Liste(A))\nA = sub(A)\nprint(Liste(A))\nA = div(A)\nprint(Liste(A))\nA = mult(A)\nprint(Liste(A))\n```\n\n\n#### Opérations unaires\n\nLes opérations unaires sont des opérations qui modifient uniquement le premier élément de la pile.\n\n```{python}\ndef appliquer_unaire(operation, L: Node) -> Node:\n    if L is None:\n        raise ValueError(\"cannot apply unary function to an empty stack\")\n    return Node(operation(L.valeur), L.suivant)\n```\n\nVoici quelques opérations unaires utiles :\n\n```{python}\ndef neg(L: Node) -> Node:\n    \"\"\"Négation : transformer la première valeur de la pile en son opposé.\n    \"\"\"\n    return appliquer_unaire(lambda x: -x, L)\n\ndef inv(L: Node) -> Node:\n    \"\"\"Inversion : inverser le premier élément de la pile (l'inverse de x est 1/x).\n    \"\"\"\n    return appliquer_unaire(lambda x: 1/x, L)\n\nprint(Liste(A))\nA = neg(A)\nprint(Liste(A))\nA = inv(A)\nprint(Liste(A))\n```\n\n\n\n#### Affichage d'une pile\n\nOn veut afficher la pile avec la tête en base, pour que les nombres les plus récents soient plus près de l'entrée utilisateur.\n\n```{python}\ndef stack_to_list(L: Node) -> list:\n    if L is None: return []\n    return [L.valeur] + stack_to_list(L.suivant)\n\ndef show_stack(L: Node) -> None:\n    # pour afficher la liste la tête en bas, on retourne la liste\n    print(*reversed(stack_to_list(L)), sep='\\n')\n\nL = Node(1, Node(2, Node(3, Node(4, Node(5)))))\nshow_stack(L)\n```\n\n#### Traduction des commandes\n\nOn veut créer une fonction qui transforme une liste selon une chaîne de caractères donnée, qui représente l'opération voulue.\n\nOn pourrait utiliser des structures `if ... elif ... elif ... else`, ainsi que des clauses `or` pour tester les différentes commandes, mais la structure `match` (apparue dans la version 3.10 de python) permet une syntaxe plus claire, et des expressions plus riches.\n\n```{python}\n\ndef appliquer_str(op_str: str, L: Node) -> Node:\n    \"\"\"Appliquer l'opération désignée par `op_str` sur `L`.\n    Exemples :\n    >>> appliquer_str(\"+\", Node(1, Node(2))) # donne Node(3)\n    >>> appliquer_str(\"/\", Node(5, Node(2))) # donne Node(0.4)\n    \"\"\"\n    match op_str:\n        case \"+\" | \"add\":\n            return add(L)\n        case \"-\" | \"sub\" | \"subs\":\n            return sub(L)\n        case \"*\" | \"mul\" | \"mult\" | \"times\":\n            return mult(L)\n        case \"/\" | \"÷\" | \"div\" | \"divide\":\n            return div(L)\n        case \"-\" | \"neg\" | \"negate\" | \"oppose\" | \"opposite\":\n            return neg(L)\n        case \"inv\" | \"invs\" | \"inverse\":\n            return inv(L)\n        case \"pop\" | \"del\":\n            return pop(L)\n\n\n```\n\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"include-in-header":{"text":"<script data-goatcounter=\"https://osk42.goatcounter.com/count\" async src=\"//gc.zgo.at/count.js\"></script>\n"},"toc":true,"number-sections":true,"output-file":"algo avancee activite 3.html"},"language":{"toc-title-document":"Table des matières","toc-title-website":"Sur cette page","related-formats-title":"Autres formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"La source","other-links-title":"Autres liens","code-links-title":"Liens de code","launch-dev-container-title":"Lancer le Dev Container","launch-binder-title":"Lancer le Binder","article-notebook-label":"Cahier d'articles","notebook-preview-download":"Télécharger le cahier","notebook-preview-download-src":"Télécharger le code source","notebook-preview-back":"Retour à l'article","manuscript-meca-bundle":"Archive MECA","section-title-abstract":"Résumé","section-title-appendices":"Annexes","section-title-footnotes":"Notes de bas de page","section-title-references":"Les références","section-title-reuse":"Réutilisation","section-title-copyright":"Droits d'auteur","section-title-citation":"Citation","appendix-attribution-cite-as":"Veuillez citer ce travail comme suit :","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Voir la Licence","title-block-author-single":"Auteur·rice","title-block-author-plural":"Auteur·rice·s","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Date de publication","title-block-modified":"Modifié","title-block-keywords":"Mots clés","callout-tip-title":"Astuce","callout-note-title":"Note","callout-warning-title":"Avertissement","callout-important-title":"Important","callout-caution-title":"Mise en garde","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Montrer tout le code","code-tools-hide-all-code":"Cacher tout le code","code-tools-view-source":"Voir les sources","code-tools-source-code":"Code source","tools-share":"Share","tools-download":"Download","code-line":"Ligne","code-lines":"Lignes","copy-button-tooltip":"Copier vers le presse-papier","copy-button-tooltip-success":"Copié","repo-action-links-edit":"Modifier cette page","repo-action-links-source":"Voir la source","repo-action-links-issue":"Faire part d'un problème","back-to-top":"Retour au sommet","search-no-results-text":"Pas de résultats","search-matching-documents-text":"documents trouvés","search-copy-link-title":"Copier le lien vers la recherche","search-hide-matches-text":"Cacher les correspondances additionnelles","search-more-match-text":"correspondance de plus dans ce document","search-more-matches-text":"correspondances de plus dans ce document","search-clear-button-title":"Effacer","search-text-placeholder":"","search-detached-cancel-button-title":"Annuler","search-submit-button-title":"Envoyer","search-label":"Recherche","toggle-section":"Basculer la section","toggle-sidebar":"Basculer la barre latérale","toggle-dark-mode":"Basculer le mode sombre","toggle-reader-mode":"Basculer en mode lecteur","toggle-navigation":"Basculer la navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Théorème","crossref-lem-title":"Lemme","crossref-cor-title":"Corollaire","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Définition","crossref-exm-title":"Exemple","crossref-exr-title":"Exercice","crossref-ch-prefix":"Chapitre","crossref-apx-prefix":"Annexe","crossref-sec-prefix":"Section","crossref-eq-prefix":"Équation","crossref-lof-title":"Liste des Figures","crossref-lot-title":"Liste des Tables","crossref-lol-title":"Liste des Listings","environment-proof-title":"Preuve","environment-remark-title":"Remarque","environment-solution-title":"Solution","listing-page-order-by":"Trier par","listing-page-order-by-default":"Ordre par défaut","listing-page-order-by-date-asc":"Le plus ancien","listing-page-order-by-date-desc":"Le plus récent","listing-page-order-by-number-desc":"Descendant","listing-page-order-by-number-asc":"Ascendant","listing-page-field-date":"Date","listing-page-field-title":"Titre","listing-page-field-description":"Description","listing-page-field-author":"Auteur·rice","listing-page-field-filename":"Nom de fichier","listing-page-field-filemodified":"Modifié","listing-page-field-subtitle":"Sous-titre","listing-page-field-readingtime":"Temps de lecture","listing-page-field-wordcount":"Compteur de Mots","listing-page-field-categories":"Catégories","listing-page-minutes-compact":"{0} min.","listing-page-category-all":"Tous","listing-page-no-matches":"Aucun article correspondant","listing-page-words":"{0} mots","listing-page-filter":"Filtre","draft":"Brouillon"},"metadata":{"lang":"fr","fig-responsive":true,"quarto-version":"1.6.42","editor":{"render-on-save":false},"comments":{"giscus":{"repo":"OsKaR31415/blog","repo-id":"R_kgDOItLnjQ","category":"Announcements","category-id":"DIC_kwDOItLnjc4CYln7","mapping":"url","reactions-enabled":true,"loading":"lazy","input-position":"bottom","theme":{"light":"noborder_light","dark":"noborder_dark"},"language":"fr"}},"theme":{"light":"flatly","dark":"darkly"},"title-block-banner":true,"page-layout":"full","title":"Algorithmique avancée : activité 3","date":"2023-01-13","categories":["informatique"],"jupyter":"python3","draft":true},"extensions":{"book":{"multiFile":true}}}},"draft":true,"projectFormats":["html"]}