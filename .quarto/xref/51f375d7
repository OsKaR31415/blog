{"entries":[],"headings":["nombres-aléatoires","générer-un-nombre-entier-aléatoire","générer-une-liste-de-nombres-aléatoires","vitesse-dexécution","temps-dexécution-de-la-première-méthode-de-génération","temps-dexécution-avec-des-list-comprehension","pour-aller-plus-loin","inverser-une-liste","avec-la-méthode-reverse","avec-la-fonction-reversed","avec-des-slice","avec-la-méthode-pop","avec-la-méthode-insert-pop","un-élément-sur-n-dans-une-liste","avec-une-boucle-et-une-nouvelle-liste","avec-une-condition-sur-les-indices","en-utilisant-un-pas-sur-range","avec-une-list-comprehension","avec-une-condition-sur-les-indices-1","en-utilisant-un-pas-sur-range-1","maximum-de-nombes-dans-deux-tableaux","en-parcourant-les-indices-des-deux-tableaux","en-utilisant-la-fonction-zip","avec-zip-et-map","reprogrammer-la-fonction-zip","en-parcourant-les-indices-des-deux-listes","si-les-deux-listes-ne-font-pas-la-même-taille","générer-une-matrice-aléatoire","avec-des-list-comprehension","en-créant-la-liste-au-fur-et-à-mesure","diagonale-dune-matrice","avec-des-list-comprehension-1","pour-aller-plus-loin-2","trace-dune-matrice","avec-une-list-comprehension-et-la-fonction-sum","en-réutilisant-la-fonction-diagonale","somme-de-deux-matrices","avec-une-list-comprehension-1","avec-des-zip-et-des-map","produit-matriciel","avec-des-list-comprehension-2","avec-le-module-numpy","divisibilité-par-récursion","récursion-simple","palindrome-par-récursion","nombre-de-chiffres-par-récursion","récursion-classique","récursion-terminale","chiffres-4-par-récursion","récursion-classique-1","avec-des-conversions-de-types","récursion-terminale-1"]}