{
  "hash": "11f74bb6bb9ecbddc87c95998614e5f5",
  "result": {
    "markdown": "---\ntitle: 'Algorithmique avancée : activité 3'\ndate: '2023-01-13'\ncategories:\n  - informatique\ntoc: true\nnumber-sections: true\ndraft: true\n---\n\n::: {.callout-tip collapse=true}\n\n## Définition d'une liste chaînée\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nclass Node:\n    def __init__(self, valeur, suivant: 'Node' =None):\n        self.valeur = valeur\n        self.suivant = suivant\n\nclass Liste:\n    def __init__(self, head: Node):\n        self.head = head\n\n    def __str__(self) -> str:\n        return \"(\" + \",\".join(map(lambda e: str(Liste(e) if isinstance(e, Node) else e),\n                                  self.to_list())) + \")\"\n\n    def to_list(self) -> list:\n        if self.head is None:\n            return []\n        return [self.head.valeur] + self.cdr().to_list()\n\n    def __len__(self) -> int:\n        \"\"\"Longueur de la liste.\n        \"\"\"\n        if self.head is None:\n            return 0\n        return 1 + len(self.head.suivant)\n\n    def append(self, valeur) -> None:\n        \"\"\"Ajouter une valeur à la fin de la liste.\n        \"\"\"\n        # cas de base :\n        # on doit s'arrêter dès que la liste est terminer\n        if self.head.suivant is None:\n            # on créé un nouveau Node\n            self.head.suivant = Node(valeur)\n        # récursion pour atteindre la fin de la liste\n        self.cdr().append(valeur)\n\n    def car(self):\n        \"\"\"Récupérer la valeur en tête de liste\n        \"\"\"\n        return self.head.value\n\n    def cdr(self) -> 'Liste':\n        \"\"\"Récupérer la liste sans son premier élément.\n        \"\"\"\n        if self.head is None:\n            return None\n        return Liste(self.head.suivant)\n\n    def last(self):\n        \"\"\"Récupérer le dernier élément de la liste.\n        \"\"\"\n        if self.head.suivant is None:\n            return self.last(Liste(self.head.suivant))\n        return self.head.valeur\n```\n:::\n\n\n:::\n\n# Bégaie - De bégaie\n\n\n> On dit qu'une liste est “bégayée” lorsque chaque élément y\n> apparaît deux fois de suite. Le but de cet exercice est de\n> transformer une liste en une liste bégayée, et inversement\n> de “dé bégayer” une liste en supprimant un élément sur\n> deux.\n\n## Bégaie\n\n### Fonction itérative\n\n> écrire la fonction itérative `begaie` qui, étant donnée\n> une liste d’éléments, renvoie la liste où chaque élément\n> est répété. Par exemple : `begaie(1,2,3,1,4) =\n> (1,1,2,2,3,3,1,1,4,4)` et `begaie(None) = None`.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef begaie(L: Node) -> Node:\n    p = L\n    while p is not None:\n        # insérer un mode contenant la même valeur\n        tmp = Node(p.valeur, p.suivant)\n        p.suivant = tmp\n        # on passe au pointeur suivant\n        p = p.suivant.suivant\n    return L\n```\n:::\n\n\nOn peut tester :\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nprint(Liste(L))\nprint(Liste(begaie(L)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(3,1,4,1,5,9)\n(3,3,1,1,4,4,1,1,5,5,9,9)\n```\n:::\n:::\n\n\nEt on a bien :\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(begaie(None))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNone\n```\n:::\n:::\n\n\n### Fonction récursive\n\n> Donner maintenant une fonction récursive `begaieRec` qui\n> effectue le même traitement que la fonction `begaie`\n> précédente\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef begaieRec(L: Node) -> Node:\n    if L is None:\n        return None\n    return Node(L.valeur, Node(L.valeur, begaieRec(L.suivant)))\n```\n:::\n\n\nElle fonctionne également :\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nprint(Liste(L))\n# La fonction modifie la valeur de L, donc on pourrait\n# simplement appeler la fonction, sans modifier\n# explicitement L (sans mettre le `L = `)\nL = begaie(L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(3,1,4,1,5,9)\n```\n:::\n:::\n\n\n## Dé bégaie\n\n\n### Fonction itérative\n\n> Écrire maintenant la fonction itérative `debegaie` qui\n> prend en argument une liste bégayée et retourne la liste\n> privée de ses doublons. La fonction de bégaie est telle que\n> `debegaie(begaie(L)) = L`\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef debegaie(L: Node) -> Node:\n    if L is None:\n        return None\n    p = L\n    # on est obligé \n    while p.suivant.suivant is not None:\n        p.suivant = p.suivant.suivant\n        p = p.suivant\n    # on retire le dernier élément\n    # p.suivant = None\n    return L\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nL = begaie(L)\nprint(Liste(L))\nL = debegaie(L)\nprint(Liste(L))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(3,3,1,1,4,4,1,1,5,5,9,9)\n(3,1,4,1,5,9,9)\n```\n:::\n:::\n\n\n### Fonction récursive\n\n> Écrire enfin la fonction récursive `debegaieRec` qui\n> réalise le même traitement que la fonction `debegaie`.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndef debegaieRec(L: Node) -> Node:\n    # cas de base\n    if L is None:\n        return None\n    # on doit ajouter ce cas de base car on utilise\n    # L.suivant.suivant, donc L.suivant ne doit pas être None\n    if L.suivant is None:\n        return None\n    # On créée une nouvelle liste qui saute un élément\n    return Node(L.valeur, debegaieRec(L.suivant.suivant))\n\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nL = begaie(L)\nprint(Liste(L))\nL = debegaie(L)\nprint(Liste(L))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(3,3,1,1,4,4,1,1,5,5,9,9)\n(3,1,4,1,5,9,9)\n```\n:::\n:::\n\n\n# Implémentation de la fonction `zip`\n\nDe très nombreux langages de programmations permettent de\ntravailler sur des structures de listes chaînées. Le langage\nPython notamment permet de travailler nativement avec les\nlistes et implémente la fonction `zip(l1, l2)` qui permet, à partir de 2 listes de même longueur de construire une liste contenant les couples de valeurs formés des éléments de même indice issu des 2 listes. Par exemple :\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nZ = zip((1, 2, 3), (\"a\", \"b\", \"c\" ))\nprint(list(Z))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(1, 'a'), (2, 'b'), (3, 'c')]\n```\n:::\n:::\n\n\n## Itérative\n\n 1. Écrire la fonction itérative zip(l1, l2) qui permet d’obtenir le résultat désiré en suivant le formalisme des listes chaînées étudiées en cours. On supposera les listes en argument de même taille et non vides.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndef zip_iter(L1: Node, L2: Node) -> Node:\n    p = L1\n    q = L2\n    res = None\n    last = None\n    while p is not None and q is not None:\n        if res is None:\n            res = Node(Node(p.valeur, Node(q.valeur)))\n            last = res\n        else:\n            last.suivant = Node(Node(p.valeur, Node(q.valeur)))\n            last = last.suivant\n        p = p.suivant\n        q = q.suivant\n    return res\n\nL1 = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9, Node(2)))))))\nL2 = Node(1, Node(6, Node(1, Node(8, Node(0, Node(3, Node(3)))))))\nprint(Liste(zip_iter(L1, L2)))\nprint(Liste(L1), Liste(L2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n((3,1),(1,6),(4,1),(1,8),(5,0),(9,3),(2,3))\n(3,1,4,1,5,9,2) (1,6,1,8,0,3,3)\n```\n:::\n:::\n\n\n## Récursive\n\n 2. Produire une solution récursive équivalente.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndef zip_rec(L1: Node, L2: Node) -> Node:\n    if L1 is None or L2 is None:\n        return None\n    return Node(Node(L1.valeur, Node(L2.valeur)),\n                zip_rec(L1.suivant, L2.suivant))\n\n\nL1 = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9, Node(2)))))))\nL2 = Node(1, Node(6, Node(1, Node(8, Node(0, Node(3, Node(3)))))))\nL3 = Node(1, Node(2, Node(3)))\nprint(Liste(zip_rec(L1, L2)))\nprint(Liste(zip_rec(L1, L3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n((3,1),(1,6),(4,1),(1,8),(5,0),(9,3),(2,3))\n((3,1),(1,2),(4,3))\n```\n:::\n:::\n\n\n# Liste croisante\n\nOn considère dans cet exercice une liste contenant des valeurs comparables grâce à l’opérateur `<=`.\n\n## Itérative\n\n 1. Écrire la fonction itérative `croissante(L)` qui prend en argument une telle liste et retourne `True` si et seulement si la liste est triée par ordre croissant au sens large.\n\nOn implémentera la fonction en considérant les cas de base suivants :\n - une liste vide est considérée comme triée par ordre croissant\n - une liste avec un seul élément est croissante également\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndef croissante_iter(L: Node) -> bool:\n    if L is None: return True\n    p = L\n    while p.suivant is not None:\n        # si deux éléments sont dans un ordre décroissant\n        if p.valeur > p.suivant.valeur:\n            # on sait que la liste n'est pas croissante\n            return False\n        p = p.suivant\n    # si on a trouvé aucune valeur décroissante dans la liste, on sait qu'elle\n    # est croissante\n    return True\n\nL = Node(1, Node(6, Node(6, Node(42, Node(73)))))\nprint(croissante_iter(L))  # True\nL = Node(1, Node(6, Node(0, Node(42))))\nprint(croissante_iter(L))  # False\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\n```\n:::\n:::\n\n\n## Récursive\n\n2. Proposer une solution récursive.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndef croissante_rec(L: Node) -> bool:\n    if L is None: return True\n    if L.suivant is None: return True\n    # si les valeurs en tête sont décroissantes\n    if L.valeur > L.suivant.valeur:\n        return False\n    return croissante_rec(L.suivant)\n\nL = Node(1, Node(6, Node(6, Node(42, Node(73)))))\nprint(croissante_iter(L))  # True\nL = Node(1, Node(6, Node(0, Node(42))))\nprint(croissante_iter(L))  # False\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\n```\n:::\n:::\n\n\n# Suppression des occurrences d’un élément\n\nNous nous intéressons maintenant à la suppression d’un élément quelconque dans une liste chaînée.\n\n## Itérative\n\n 1. Écrire une fonction itérative `removeAll(L, elem)` qui prend en argument une liste chaînée `L` et une valeur `elem` et retourne la liste privée de ses éléments `elem`.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ndef remove_all_iter(L: Node, elem) -> Node:\n    if L is None: return None\n    # on cherche la première valeur\n    while L.valeur == elem:\n        L = L.suivant\n        # si on a passé toutes les valeurs, c'est que la liste ne contient que\n        # des valeurs à supprimer :\n        if L is None: return None\n    res = Node(L.valeur)\n    res_tl = res\n    while L is not None:\n        if L.valeur != elem:\n            res_tl.suivant = Node(L.valeur)\n            res_tl = res_tl.suivant\n        L = L.suivant\n    return res\n\nprint(\"Liste vide :\", remove_all_iter(None, 9))\n\nL = Node(42, Node(42, Node(42, Node(42, Node(42, Node(42, Node(42)))))))\nprint(\"Liste à supprimer complètement :\",\n      Liste(remove_all_iter(L, 42)))\n\nL = Node(73, Node(73, Node(73, Node(42, Node(42)))))\nprint(\"Liste qui commmence par les éléments à supprimer :\",\n      Liste(remove_all_iter(L, 73)))\n\nL = Node(1, Node(1, Node(1, Node(8, Node(1, Node(3, Node(3)))))))\nprint(\"Liste mixte :\",\n      Liste(remove_all_iter(L, 1)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nListe vide : None\nListe à supprimer complètement : ()\nListe qui commmence par les éléments à supprimer : (42,42,42)\nListe mixte : (8,8,3,3)\n```\n:::\n:::\n\n\n## Récursive\n\n 2. Proposer une solution récursive à ce problème.\nIndications : pensez à différencier les cas suivants :\n\n - la liste est vide initialement,\n - la liste ne contient que l’élément à supprimer,\n - la liste commence par les éléments à supprimer,\n - la liste est mixte : composée pour une part de l’élément à supprimer et pour une autre part d’autres éléments à conserver.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ndef remove_all(L: Node, elem) -> Node:\n    if L is None: return None\n    if L.valeur == elem:\n        return remove_all(L.suivant, elem)\n    return Node(L.valeur, remove_all(L.suivant, elem))\n\nprint(\"Liste vide :\", remove_all_iter(None, 9))\n\nL = Node(42, Node(42, Node(42, Node(42, Node(42, Node(42, Node(42)))))))\nprint(\"Liste à supprimer complètement :\",\n      Liste(remove_all_iter(L, 42)))\n\nL = Node(73, Node(73, Node(73, Node(42, Node(42)))))\nprint(\"Liste qui commmence par les éléments à supprimer :\",\n      Liste(remove_all_iter(L, 73)))\n\nL = Node(1, Node(1, Node(1, Node(8, Node(1, Node(3, Node(3)))))))\nprint(\"Liste mixte :\",\n      Liste(remove_all_iter(L, 1)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nListe vide : None\nListe à supprimer complètement : ()\nListe qui commmence par les éléments à supprimer : (42,42,42)\nListe mixte : (8,8,3,3)\n```\n:::\n:::\n\n\n# Suite de Fibonacci\n\nLa suite de Fibonacci est définie comme suit :\n\n - $f_0 = 1$\n - $f_1 = 1$\n - $f_n = f_{n-1} + f_{n-2}$ si $n > 1$\n\n\n## Itérative\n\n 1. Écrire la définition de la fonction itérative `fibonacci(n)` qui, étant donné un entier naturel `n` renvoie la liste $(f_n, f_{n−1}, f_{n−2}, \\ldots, f_1, f_0)$ où les fi sont les termes de la suite de Fibonacci.\n\nPar exemple :\n\n```python\nfibonacci(0) = (1)\nfibonacci(1) = (1, 1)\nfibonacci(4) = (1, 1, 2, 3, 5)\nfibonacci(5) = (1, 1, 2, 3, 5, 8)\n```\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ndef fibonacci(n: int) -> Node:\n    if n == 0:\n        return Node(1)\n    res = Node(1, Node(1))\n    # on a déjà fait la 1ère étape en définissant res, donc on peut diminuer n\n    n -= 1\n    # _ est un nom de variable que l'on utilise quand on sait que l'on ne va\n    # pas utiliser cette variable.\n    for _ in range(n):\n        # somme de la dernière et l'avant dernière valeur\n        res = Node(res.valeur + res.suivant.valeur, res)\n    return res\n\nfor n in range(10):\n    print(f\"fibonacci({n}) = {Liste(fibonacci(n))}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfibonacci(0) = (1)\nfibonacci(1) = (1,1)\nfibonacci(2) = (2,1,1)\nfibonacci(3) = (3,2,1,1)\nfibonacci(4) = (5,3,2,1,1)\nfibonacci(5) = (8,5,3,2,1,1)\nfibonacci(6) = (13,8,5,3,2,1,1)\nfibonacci(7) = (21,13,8,5,3,2,1,1)\nfibonacci(8) = (34,21,13,8,5,3,2,1,1)\nfibonacci(9) = (55,34,21,13,8,5,3,2,1,1)\n```\n:::\n:::\n\n\n::: {.callout-tip collapse=true}\n## Les f-string en python\n\nLes \"*f-strings*\" sont des chaînes de caractères (*strings*) devant lesquelles on met un `f`.\n\nCela permet de mettre du code à l'intérieur, qui sera évalué et intégré dans la chaîne.\n\nPar exemple :\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nfor i in range(5):\n    print(f\"{i*10}km à pied, ça use les souliers.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0km à pied, ça use les souliers.\n10km à pied, ça use les souliers.\n20km à pied, ça use les souliers.\n30km à pied, ça use les souliers.\n40km à pied, ça use les souliers.\n```\n:::\n:::\n\n\nIci, on voit que c'est l'expression entourée par des accolades `{...}` qui est évaluée. Elle est bien intégrée dans le reste de la chaîne de caractères.\n\nBien sûr, il est possible de mettre plusieurs expressions dans une même f-string :\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nfor i in range(5):\n    print(f\"{i} au carré donne {i**2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 au carré donne 0\n1 au carré donne 1\n2 au carré donne 4\n3 au carré donne 9\n4 au carré donne 16\n```\n:::\n:::\n\n\nEt on peut même imaginer ce genre d'exemples :\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nfor i in range(5):\n    print(f\"{i} est un nombre {'impair' if i%2 else 'pair'} et {'non'*(0 != i%3)} divisible par 3.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 est un nombre pair et  divisible par 3.\n1 est un nombre impair et non divisible par 3.\n2 est un nombre pair et non divisible par 3.\n3 est un nombre impair et  divisible par 3.\n4 est un nombre pair et non divisible par 3.\n```\n:::\n:::\n\n\nLes f-strings sont plus rapides et plus lisibles que d'autres techniques pour créer des listes contenant des résultats. Il vaut donc mieux utiliser des f-string plutôt que faire des concaténations de listes avec `+`.\n\n:::\n\n\n## Récursive\n\n 2. Produire une version récursive de cette fonction\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ndef fibonacci_rec(n: int) -> Node:\n    if n == 0:\n        return Node(1)\n    if n == 1:\n        return Node(1, Node(1))\n    recursion = fibonacci_rec(n - 1)\n    return Node(recursion.valeur + recursion.suivant.valeur,\n                recursion)\n\nfor n in range(10):\n    print(f\"fibonacci({n}) = {Liste(fibonacci(n))}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfibonacci(0) = (1)\nfibonacci(1) = (1,1)\nfibonacci(2) = (2,1,1)\nfibonacci(3) = (3,2,1,1)\nfibonacci(4) = (5,3,2,1,1)\nfibonacci(5) = (8,5,3,2,1,1)\nfibonacci(6) = (13,8,5,3,2,1,1)\nfibonacci(7) = (21,13,8,5,3,2,1,1)\nfibonacci(8) = (34,21,13,8,5,3,2,1,1)\nfibonacci(9) = (55,34,21,13,8,5,3,2,1,1)\n```\n:::\n:::\n\n\n# interclassement\n\nOn s’intéresse dans cet exercice à deux méthodes d’interclassement de listes. L’interclassement vise à parcourir deux listes en parallèle et, à chaque itération, à insérer un élément venant de l’une ou de l’autre liste, dans la liste résultat. Le critère utilisé pour choisir la liste qui fournit l’élément à insérer suivant définit le type d’interclassement.\n\n\n\n\n## Interclassement strict\n\n 1. On s’intéresse tout d’abord à un interclassement strict qui insère alternativement un élément de la première liste puis un élément de la seconde liste. Dans le cas où une liste est plus courte que l’autre, les éléments restants de la plus longue sont insérés à la fin de la liste résultat sans interclassement. Plus précisément, si une liste est vide dès le début, la seconde est retournée. Si les deux listes sont vides, alors la liste vide (None) est retournée. Par exemple :\n\n\nOn commence par créer une fonction qui permet de copier une liste chaînée (créer une nouvelle liste qui contien les mêmes valeurs).\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\ndef copy(L: Node) -> Node:\n    \"\"\"Créer une copie d'une liste chaînée.\"\"\"\n    if L is None: return None\n    return Node(L.valeur, copy(L.suivant))\n```\n:::\n\n\n::: {.callout-tip collapse=true}\n## Version itérative de `copy`\n\nLa version itérative nécessite de garder à la fois un pointeur vers la position dans la liste originale et vers la fin de la nouvelle liste.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\ndef copy_iter(L: Node) -> Node:\n    \"\"\"Créer une copie d'une liste chaînée.\"\"\"\n    if L is None: return None\n    res = Node(L.valeur)\n    p = res\n    q = L.suivant\n    while q is not None:\n        p.suivant = Node(q.valeur)\n        p = p.suivant\n        q = q.suivant\n    return res\n```\n:::\n\n\n:::\n\n\n### Itératif\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\ndef inter_strict_iter(L1: Node, L2: Node) -> Node:\n    if L1 is None: return copy(L2)\n    if L2 is None: return copy(L1)\n    res = Node(L1.valeur, Node(L2.valeur))\n    L1_p = L1.suivant\n    L2_p = L2.suivant\n    res_tail = res.suivant\n    while L1_p is not None and L2_p is not None:\n        res_tail.suivant = Node(L1_p.valeur, Node(L2_p.valeur))\n        res_tail = res_tail.suivant.suivant\n        L1_p = L1_p.suivant\n        L2_p = L2_p.suivant\n    if L1_p is None: res_tail.suivant = copy(L2_p)\n    if L2_p is None: res_tail.suivant = copy(L1_p)\n    return res\n\nL1 = Node(2, Node(6, Node(42, Node(73, Node(1237)))))\nL2 = Node(0, Node(1, Node(0)))\nprint(Liste(inter_strict_iter(L1, L2)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(2,0,6,1,42,0,73,1237)\n```\n:::\n:::\n\n\n### Récursif\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\ndef inter_strict_rec(L1: Node, L2: Node) -> Node:\n    if L1 is None or L2 is None: return None\n    return Node(L1.valeur, Node(L2.valeur,\n                inter_strict_rec(L1.suivant, L2.suivant)))\n\nL1 = Node('A', Node('B', Node('C', Node('D', Node('E')))))\nL2 = Node(0, Node(1, Node(2)))\nprint(Liste(inter_strict_iter(L1, L2)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(A,0,B,1,C,2,D,E)\n```\n:::\n:::\n\n\n::: {.callout-tip collapse=true}\n## Avec `match`\n\nLe mot clef `match` de python permet de faire du \"_pattern matching_\", un peu comme en ocaml. Cette syntaxe (avec `match` et `case`) peut être plus lisible que des `if` dans certains cas.\n\nIci, on profite du fait d'avoir deux cas symétrique : si `L1` est `None` et si `L2` est `Non`. Dans chaque cas, il faut retourner une copie de l'autre liste.\n\nL'expression `(L, None) | (None, L)` va _matcher_ tous les cas où l'une des deux listes `(L1, L2)` est vide. Alors, `L` sera l'autre liste, exactement ce qu'il faut pour faire un `return copy(L)` !\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\ndef inter_strict_rec(L1: Node, L2: Node) -> Node:\n    match (L1, L2):\n        case (L, None) | (None, L): return copy(L)\n    return Node(L1.valeur, Node(L2.valeur,\n                inter_strict_rec(L1.suivant, L2.suivant)))\n\nL1 = Node('A', Node('B', Node('C', Node('D', Node('E')))))\nL2 = Node(0, Node(1, Node(2)))\nprint(Liste(inter_strict_iter(L1, L2)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(A,0,B,1,C,2,D,E)\n```\n:::\n:::\n\n\nComme on fait un `return copy(L)`, on a pas besoin de préciser que le `return` récursif ne doit pas être exécuté dans tous les cas. Mais si on ne fait pas de `return`, on peut utiliser le cas `case other:`, qui correspondra à un `else` : il sera atteint seulement si aucun des autres cas ne sont trouvés.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nfor a in range(8):\n    match a:\n        case 0:\n            print(a, \"un nombre nul\")\n        case 1:\n            print(a, \"premier nombre, mais pas un nombre premier\")\n        case 2:\n            print(a, \"est le premier nombre premier\")\n        case 3:\n            print(a, \"est un autre nombre premier\")\n        case 4:\n            print(a, \"est le premier nombre pas premier\")\n        case 5:\n            print(a, \"est encore un nombre premier\")\n        case other:\n            print(a, \"est trop grand pour moi\")\n    # sera exécuté à chaque fois, quel que soit le match\n    print(\"--------------------------------------------\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 un nombre nul\n--------------------------------------------\n1 premier nombre, mais pas un nombre premier\n--------------------------------------------\n2 est le premier nombre premier\n--------------------------------------------\n3 est un autre nombre premier\n--------------------------------------------\n4 est le premier nombre pas premier\n--------------------------------------------\n5 est encore un nombre premier\n--------------------------------------------\n6 est trop grand pour moi\n--------------------------------------------\n7 est trop grand pour moi\n--------------------------------------------\n```\n:::\n:::\n\n\n:::\n\n\n## Interclassement croissant\n\n\n 2. On considère maintenant deux listes de nombres `L1` et `L2` qui sont triées par ordre croissant. Écrire une fonction d’interclassement `interCroissant(L1, L2)` qui insère à chaque itération l’élément le plus petit qui se trouve en tête de liste soit de `L1` soit de `L2`. Un tel interclassement produit une liste fusionnée elle-même triée par ordre croissant. Proposer une solution itérative puis une solution récursive à ce problème.\n\n\n\n\n### Itératif\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\ndef inter_croissant_iter(L1: Node, L2: Node) -> Node:\n    if L1 is None: return copy(L2)\n    if L2 is None: return copy(L1)\n    L1_p = L1\n    L2_p = L2\n    # init 1ère valeur\n    res = None\n    if L1_p.valeur < L2_p.valeur:\n        res = Node(L1_p.valeur)\n        L1_p = L1_p.suivant\n    else:\n        res = Node(L2_p.valeur)\n        L2_p = L2_p.suivant\n    res_tail = res\n    while L1_p is not None and L2_p is not None:\n        if L1_p.valeur < L2_p.valeur:\n            res_tail.suivant = Node(L1_p.valeur)\n            res_tail = res_tail.suivant\n            L1_p = L1_p.suivant\n        else:\n            res_tail.suivant = Node(L2_p.valeur)\n            res_tail = res_tail.suivant\n            L2_p = L2_p.suivant\n    if L1_p is None:\n        res_tail.suivant = copy(L2_p)\n    elif L2_p is None:\n        res_tail.suivant = copy(L1_p)\n    return res\n\nL1 = Node(1, Node(6, Node(42, Node(73, Node(1237)))))\nL2 = Node(0, Node(12, Node(37, Node(67, Node(68)))))\nprint(Liste(inter_croissant_iter(L1, L2)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(0,1,6,12,37,42,67,68,73,1237)\n```\n:::\n:::\n\n\n### Récursif\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\ndef inter_croissant_rec(L1: Node, L2: Node) -> Node:\n    match (L1, L2):\n        case (L, None) | (None, L): return copy(L)\n        case (L1, L2) if L1.valeur < L2.valeur:\n            return Node(L1.valeur,\n                        inter_croissant_rec(L1.suivant, L2))\n        case other:\n            return Node(L2.valeur,\n                        inter_croissant_rec(L1, L2.suivant))\n\nL1 = Node(1, Node(6, Node(42, Node(73, Node(1237)))))\nL2 = Node(0, Node(12, Node(37, Node(67, Node(68)))))\nprint(Liste(inter_croissant_iter(L1, L2)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(0,1,6,12,37,42,67,68,73,1237)\n```\n:::\n:::\n\n\n# Calculatrice\n\nNous nous intéressons à la conception d’une calculatrice qui repose sur une représentation des opérations à l’aide d’une **pile**. De façon à mener à bien ce programme, il va donc falloir\n - implémenter les fonctions de la barrière d’abstraction de la structure pile de données (push, pop),\n - comprendre la notation postfixée pour la saisie des opérations\n\n\nDe manière traditionnelle, les opérations sont notées de manière infixée avec, dans le cas d’un opérateur binaire, le placement de l’opérateur entre les 2 opérandes. On obtient la notation suivante :\nDe manière traditionnelle, les opérations sont notées de manière infixée avec, dans le cas d’un opérateur binaire, le placement de l’opérateur entre les 2 opérandes. On obtient la notation suivante :\n$$\\text{opérande}_1 \\text{opérateur} \\text{opérande}_2$$\n\ncomme par exemple : $3 + 4$, $2.5 / 3.14 \\ldots$\n\nEn notation postfixée, l’opérateur succède à son (dans le cas d’un opérateur unaire) ou ses (dans le cas d’un opérateur binaire) opérande(s).\n\nAinsi : “$3+4$” s’écrit en postfixe “$3 4 +$”.\n\nL’intérêt d’une telle représentation est de pouvoir ensuite utiliser une pile pour réaliser les calculs en suivant le schéma de résolution suivant :\n\n - si la pile ne contient qu’une valeur réelle, il s’agit du résultat du calcul,\n - sinon on empile les valeurs réelles lorsqu’elles sont lues en entrée,\n - si on lit un caractère correspondant à un opérateur binaire on dépile les deux dernières valeurs réelles, on effectue le calcul et on empile le résultat,\n - si on lit un caractère correspondant à un opérateur unaire, comme l’opérateur de négation, on dépile la dernière valeur, on applique l’opérateur et on empile le résultat.\n\nAttention : la division est une loi non commutative, c’est-à-dire que $x/y \\neq y/x$. Il faut donc garder à l’esprit qu’en écrivant “$x y /$” en postifixé, l’opération souhaitée est $\\frac{x}{y}$ mais que du fait de l’utilisation d’une pile, la valeur de $y$ sera dépilée avant celle de $x$ (pile = dernier arrivé, premier sorti).\n\nDans le cadre de notre programme, les opérateurs suivants doivent être reconnus :\n\n - `+` : addition,\n - `-` : soustraction,\n - `*` : multiplication,\n - `/` division\n - `n` : négation\n\nSimilairement, on veillera à bien gérer les erreurs :\n\n• soit de division par 0,\n• soit de dépilement de valeur inexistante : par exemple, essayer de dépiler les deux opérandes d’un opérateur `+` alors qu’il n’y en a qu’un seul dans la pile\n\n## Notation postfixée\n\nIndiquer la traduction en notation postfixée des expressions suivantes exprimées en notation infixée (les parenthèses ne sont là que pour vous aider à comprendre la priorité des opérations) :\n\n - `(2 + 4) * n 5`\n     - `2 4 + 5 n *` ou bien `5 n 2 4 + *`\n - `9 / (3.5 + 6)`\n     - `9 3.5 6 + /`\n - `(3 - 5) / (3 + 5)`\n     - `3 5 - 3 5 + /`\n\n\n\n## Caculatrice\n\n 2. Implémenter une calculatrice simple en notation postfixée sur la base d’une pile gérée par votre barrière d’abstraction.\n\n### Pile\n\n::: {.callout-note collapse=true}\n## Notes sur l'implémentation\n\n - Le dessus de la pile (la tête de la pile) sera la tête de liste (le premier élément de la liste), pour minimiser la complexité des opérations de base.\n - Les opérations sur les piles seront faîtes en-place (\"_in place_\"), c'est-à-dire que les listes seront modifiées (une nouvelle liste ne sera pas créée à chaque fois)\n - On peut alors avoir un `push` et un `pop` en $O(1)$\n\n:::\n\n#### Push\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\ndef push(L: Node, valeur) -> Node:\n    return Node(valeur, L)\n\nA = Node(1, Node(2))\nA = push(A, 42)\nprint(Liste(A))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(42,1,2)\n```\n:::\n:::\n\n\n#### Get\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\ndef get(L: Node) -> Node:\n    if L is None:\n        return None\n    return L.valeur\n\nprint(Liste(A))\nprint(get(A))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(42,1,2)\n42\n```\n:::\n:::\n\n\n#### Pop\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\ndef pop(L: Node) -> Node:\n    if L is None:\n        raise ValueError(\"pop from empty stack.\")\n    return L.suivant\n\nprint(Liste(A))\nA = pop(A)\nprint(Liste(A))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(42,1,2)\n(1,2)\n```\n:::\n:::\n\n\n#### Is empty\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\ndef is_empty(L: Node) -> bool:\n    return L is None\n\nprint(is_empty(None))\nprint(is_empty(Node(1, Node(2))))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\n```\n:::\n:::\n\n\n#### Height\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\ndef height(L: Node) -> int:\n    if is_empty(L):\n        return 0\n    return 1 + height(L.suivant)\n\nL = Node(1, Node(2, Node(3, Node(42))))\nprint(height(L))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n```\n:::\n:::\n\n\n### Abstraction de la calculatrice\n\n\nOn créée d'abord une fonction qui permet d'appliquer un opérateur binaire à une pile (sur les deux premiers éléments).\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\ndef appliquer(bin_operator, L: Node) -> Node:\n    \"\"\"Appliquer `bin_operator` sur les deux premières valeurs de la pile.\n\n    Le premier paramètre donné à `bin_operator` est le dessus de la pile, et le\n    second est le second élément de la pile.\n    \"\"\"\n    if L is None:\n        raise ValueError(\"applying operator on empty stack\")\n    if L.suivant is None:\n        raise ValueError(\"applying operator on stack with only one element\")\n    return Node(bin_operator(L.valeur, L.suivant.valeur), L.suivant.suivant)\n    first = get(L)\n    L = pop(L)\n    second = get(L)\n    L = pop(L)\n    result = bin_operator(first, second)\n    return push(result, L)\n\nA = Node(3, Node(2, Node(4, Node(1, Node(5)))))\nadd = lambda x, y: x+y\ndiv = lambda x, y: y / x\nA = appliquer(add, A)\nprint(Liste(A))\nA = appliquer(div, A)\nprint(Liste(A))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(5,4,1,5)\n(0.8,1,5)\n```\n:::\n:::\n\n\n#### Opérateurs de base\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\ndef add(L: Node) -> Node:\n    return appliquer(lambda x, y: x+y, L)\n\ndef sub(L: Node) -> Node:\n    return appliquer(lambda x, y: y - x, L)\n\ndef mult(L: Node) -> Node:\n    return appliquer(lambda x, y: x * y, L)\n\ndef div(L: Node) -> Node:\n    return appliquer(lambda x, y: y / x, L)\n\nA = Node(3, Node(2, Node(1, Node(1, Node(5)))))\nprint(Liste(A))\nA = add(A)\nprint(Liste(A))\nA = sub(A)\nprint(Liste(A))\nA = div(A)\nprint(Liste(A))\nA = mult(A)\nprint(Liste(A))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(3,2,1,1,5)\n(5,1,1,5)\n(-4,1,5)\n(-0.25,5)\n(-1.25)\n```\n:::\n:::\n\n\n#### Opérations unaires\n\nLes opérations unaires sont des opérations qui modifient uniquement le premier élément de la pile.\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\ndef appliquer_unaire(operation, L: Node) -> Node:\n    if L is None:\n        raise ValueError(\"cannot apply unary function to an empty stack\")\n    return Node(operation(L.valeur), L.suivant)\n```\n:::\n\n\nVoici quelques opérations unaires utiles :\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\ndef neg(L: Node) -> Node:\n    \"\"\"Négation : transformer la première valeur de la pile en son opposé.\n    \"\"\"\n    return appliquer_unaire(lambda x: -x, L)\n\ndef inv(L: Node) -> Node:\n    \"\"\"Inversion : inverser le premier élément de la pile (l'inverse de x est 1/x).\n    \"\"\"\n    return appliquer_unaire(lambda x: 1/x, L)\n\nprint(Liste(A))\nA = neg(A)\nprint(Liste(A))\nA = inv(A)\nprint(Liste(A))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(-1.25)\n(1.25)\n(0.8)\n```\n:::\n:::\n\n\n#### Affichage d'une pile\n\nOn veut afficher la pile avec la tête en base, pour que les nombres les plus récents soient plus près de l'entrée utilisateur.\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\ndef stack_to_list(L: Node) -> list:\n    if L is None: return []\n    return [L.valeur] + stack_to_list(L.suivant)\n\ndef show_stack(L: Node) -> None:\n    # pour afficher la liste la tête en bas, on retourne la liste\n    print(*reversed(stack_to_list(L)), sep='\\n')\n\nL = Node(1, Node(2, Node(3, Node(4, Node(5)))))\nshow_stack(L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n4\n3\n2\n1\n```\n:::\n:::\n\n\n#### Traduction des commandes\n\nOn veut créer une fonction qui transforme une liste selon une chaîne de caractères donnée, qui représente l'opération voulue.\n\nOn pourrait utiliser des structures `if ... elif ... elif ... else`, ainsi que des clauses `or` pour tester les différentes commandes, mais la structure `match` (apparue dans la version 3.10 de python) permet une syntaxe plus claire, et des expressions plus riches.\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\ndef appliquer_str(op_str: str, L: Node) -> Node:\n    \"\"\"Appliquer l'opération désignée par `op_str` sur `L`.\n    Exemples :\n    >>> appliquer_str(\"+\", Node(1, Node(2))) # donne Node(3)\n    >>> appliquer_str(\"/\", Node(5, Node(2))) # donne Node(0.4)\n    \"\"\"\n    match op_str:\n        case \"+\" | \"add\":\n            return add(L)\n        case \"-\" | \"sub\" | \"subs\":\n            return sub(L)\n        case \"*\" | \"mul\" | \"mult\" | \"times\":\n            return mult(L)\n        case \"/\" | \"÷\" | \"div\" | \"divide\":\n            return div(L)\n        case \"-\" | \"neg\" | \"negate\" | \"oppose\" | \"opposite\":\n            return neg(L)\n        case \"inv\" | \"invs\" | \"inverse\":\n            return inv(L)\n        case \"pop\" | \"del\":\n            return pop(L)\n\n```\n:::\n\n\n",
    "supporting": [
      "algo avancee activite 3_files"
    ],
    "filters": [],
    "includes": {}
  }
}