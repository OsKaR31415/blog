{
  "hash": "adc2624eafeb0fd9e185db61b7ee2a8e",
  "result": {
    "markdown": "---\ntitle: Listes chaînées\ndate: '2023-01-13'\ncategories:\n  - informatique\nformat: html\ntoc: true\n---\n\n::: {.callout-note icon=false}\n## Définition\n\nReprésentation d'une liste de façon [récursive](algo_avancee_structures_recursives.qmd).\n - les éléments sont rangés **linéairement**\n - \n\n\nLa liste est un bloc, puis un lien vers la suite de la liste (le bloc suivant).\n\n![](_images/listes_chainees.svg)\n\nUne liste chaînée est donc un bloc contenant :\n - une valeur\n - un pointeur vers le premier bloc de la suite\n     - Cette \"suite\" est aussi une liste chaînée\n\n:::\n\n\n# Implémentation\n\nDeux représentations sont possibles :\n - un objet `Node` qui suit la définition [récursive](algo_avancee_structures_recursives.qmd)\n     - les opérations que l'on fait sur une liste sont alors représentées comme des fonctions (ou procédures) qui prennent un (ou plusieurs) `Node` en argument\n - un objet `LinkedList` qui représente la liste chaînée à plus haut niveau d'abstraction\n     - une liset possède une **tête** de liste qui est un `Node`\n     - les opérations que l'on fait sur une liste sont alors représentées comme des méthodes de cet objet\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nclass Node:\n    def __init__(self, value, next=None):\n        \"\"\"Create a new node.\n        \"\"\"\n        self.valeur = value\n        self.suivant = next\n```\n:::\n\n\n```python\nclass LinkedList:\n    def __init__(self, head: Node =None):\n        \"\"\"Initialize a linked list\"\"\"\n        self.head : Node = head\n```\n\n - possibilité de l'étendre \n     - un itérateur\n     - des attributs pour connaîrte la taille de la liste sans la recalculer\n     - ajouter un pointeur vers le dernier élément de la liste pour accélérer les insertions d'éléments à la fin\n\n## Fonctions sur des `Node`\n\n### Afficher les éléments\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef affichage(L: Node) -> str:\n    chaine = \"\"\n    while L is not None:\n        chaine += \"<\" + str(L.valeur) + \"> \"\n        L = L.suivant\n    return chaine\n\nmylist = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nprint(affichage(mylist))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<3> <1> <4> <1> <5> <9> \n```\n:::\n:::\n\n\nOu bien, dans une version récursive :\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef affichageRec(L: Node) -> str:\n    if L is None:\n        return \"\"\n    return \"<\" + str(L.valeur) + \"> \"\n\nmylist = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9))))))\nprint(affichage(mylist))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<3> <1> <4> <1> <5> <9> \n```\n:::\n:::\n\n\nEt on peut utiliser la méthode magique `__str__` de la classe `LinkedList` :\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nclass LinkedList:\n    def __init__(self, head: Node =None):\n        \"\"\"Initialize a linked list\"\"\"\n        self.head : Node = head\n\n    def __str__(self) -> str:\n        L = self.head\n        res = \"\"\n        while L is not None:\n            res += \"<\" + str(L.valeur) + \"> \"\n            L = L.suivant\n        return res\n\nmylinkedlist = LinkedList(mylist)\n\n# __str__ permet de définir le résultat de str(mylinkedlist)\n# print appelle toujours la fonction str, donc pas beson de l'ajouter\nprint(mylinkedlist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<3> <1> <4> <1> <5> <9> \n```\n:::\n:::\n\n\n### Calculer la longueur\n\nOn peut à nouveau le faire de plusieurs façons. Pour pouvoir utiliser la fonction `len` sur l'objet, on ajoute la méthode `__len__` sur la classe `LinkedList`\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nclass LinkedList:\n    def __init__(self, head: Node =None):\n        \"\"\"Initialize a linked list\"\"\"\n        self.head : Node = head\n\n    def __len__(self) -> int:\n        L = self.head\n        length = 0\n        while L is not None:\n            length += 1\n            L = L.suivant\n        return length\n\n# on re-créée l'objet pour que la nouvelle fonction soit mise à jour\nmylinkedlist = LinkedList(mylist)\nprint(len(mylinkedlist))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\n```\n:::\n:::\n\n\n",
    "supporting": [
      "algo avancee listes chainees_files"
    ],
    "filters": [],
    "includes": {}
  }
}