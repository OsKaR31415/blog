{
  "hash": "6ede7ad93acd7165deda53232b3a6d77",
  "result": {
    "markdown": "---\ntitle: algo avancee correction controle\ndescription: correction détaillée\ndate: '2023-03-02'\ncategories:\n  - informatique\ntoc: true\n---\n\n:::{.callout-tip collapse=true}\n## Implémentation d'une liste chaînée\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nclass Node:\n    def __init__ (self, value, next=None):\n        self.valeur = value\n        self.suivant = next\n\n    def __str__ (self):\n        return f\"({', '.join(map(str, self.to_list()))})\"\n\n    def to_list(self) -> list:\n        if self.suivant is None:\n            return [self.valeur]\n        return [self.valeur] + self.suivant.to_list()\n```\n:::\n\n\n:::\n\n# Sujet de 14h45\n\n\n## 1. `genAlea`\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfrom random import randint\n\ndef genAlea(nb_val: int) -> Node:\n    \"\"\"Retourner une liste chaînée de nbVal entiers aléatoires entre 1 et 100.\n    Args:\n        nb_val (int): Le nombre d'entiers à générer\n    Returns:\n        Node: La liste de nb_val\n    \"\"\"\n    res = None\n    for _ in range(nb_val):\n        res = Node(randint(1, 100), res)\n    return res\n\nprint(\"12 nombres aléatoires :\", genAlea(12))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n12 nombres aléatoires : (2, 23, 90, 98, 93, 94, 64, 34, 44, 9, 76, 77)\n```\n:::\n:::\n\n\n## 2. `compteSup`\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef compteSup(L: Node, seuil) -> int:\n    \"\"\"Retourne le nombre de valeurs de L strictement supérieures à seuil.\n    Args:\n        L (Node): La liste chaînée.\n        seuil (comparable): La valeur de seuil (on compte les valeurs strictement supérieures au seuil).\n    Returns:\n        int: Le nombre de valeurs strictement supérieurs au seuil.\n    \"\"\"\n    nb_vals_sup = 0\n    while L is not None:\n        if L.valeur > seuil:\n            nb_vals_sup += 1\n        L = L.suivant\n    return nb_vals_sup\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9, Node(2)))))))\nseuil = 4\nprint(L, \"contient\", compteSup(L, seuil), \"valeurs strictement supérieures à\", seuil)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(3, 1, 4, 1, 5, 9, 2) contient 2 valeurs strictement supérieures à 4\n```\n:::\n:::\n\n\n## 3. `dansIntervalle` récursivement\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef dansIntervalle(L: Node, a, b) -> Node:\n    \"\"\"Créer une nouvelle liste à partir de L en ne gardant que les éléments dans l'intervalle [a, b].\n    Args:\n        L (Node): La liste chaînée de départ.\n        a (comparable): Le minimum de l'intervalle\n        b (comparable): Le maximum de l'intervalle\n    Returns:\n        Node: Une nouvelle liste pour laquelle on a gardé seulement les élément qui sont dans l'intervalle [a, b].\n    \"\"\"\n    if a > b:\n        raise ValueError(\"a doit être inférieur ou égal à b.\")\n    ##### ajouter/enlever un # devant la ligne suivante pour changer d'implémentation #####\n    if L is None: return None\n    if a <= L.valeur <= b:\n        # on garde le node actuel\n        return Node(L.valeur, dansIntervalle(L.suivant, a, b))\n    return dansIntervalle(L.suivant, a, b)\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9, Node(2, Node(6, Node(5, Node(3, Node(5, Node(8, Node(9, Node(7, Node(9, Node(3, Node(2, Node(3))))))))))))))))))\nprint(dansIntervalle(L, 2, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(3, 4, 2, 3, 3, 2, 3)\n```\n:::\n:::\n\n\n## 4. `dansIntervalle` avec un itérateur fonctionnel\n\n\n:::{.callout-info collapse=true}\n## Implémentation de `Lfilter`\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef Lfilter(L : Node, f):\n    \"\"\"Filtrer les valeurs de L selon le prédicat f.\n    On garde seulement les valeurs de les pour lesquelles\n    f(valeur) == True.\n    Args:\n        L (Node): La liste de départ.\n        f (fonction): Le prédicat (fonction qui renvoie True\n                      ou False).\n    Returns:\n        Node: La nouvelle liste contenant seulement les\n              valeurs de L pour lesquelles f(valeur) == True\n              (on conserve l'ordre).\n    \"\"\"\n    if L is None:\n        return None\n    p = L\n    while p is not None and not f(p.valeur):\n        p = p.suivant\n    if p is None:\n        return None\n\n    res = Node(p.valeur)\n    w = res\n    while p.suivant is not None:\n        p = p.suivant\n        if f(p.valeur):\n            w.suivant = Node(p.valeur)\n            w = w.suivant\n    return res\n```\n:::\n\n\n:::\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndef dansIntervalle(L: Node, a, b) -> Node:\n    \"\"\"Créer une nouvelle liste à partir de L en ne gardant que les éléments dans l'intervalle [a, b].\n    Args:\n        L (Node): La liste chaînée de départ.\n        a (comparable): Le minimum de l'intervalle\n        b (comparable): Le maximum de l'intervalle\n    Returns:\n        Node: Une nouvelle liste pour laquelle on a gardé seulement les élément qui sont dans l'intervalle [a, b].\n    \"\"\"\n    if a > b:\n        raise ValueError(\"a doit être inférieur ou égal à b.\")\n    # avec un itérateur fonctionnel\n    return Lfilter(L, lambda x: a <= x <= b)\n\n\nL = Node(3, Node(1, Node(4, Node(1, Node(5, Node(9, Node(2, Node(6, Node(5, Node(3, Node(5, Node(8, Node(9, Node(7, Node(9, Node(3, Node(2, Node(3))))))))))))))))))\nprint(dansIntervalle(L, 2, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(3, 4, 2, 3, 3, 2, 3)\n```\n:::\n:::\n\n\n# Sujet de 15h30\n\n\n## 1. `genRandom`\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef genRandom(nbVal: int) -> Node:\n    \"\"\"Créer une liste de nbVal nombres aléatoires entre 0 et 20\n    Args:\n        nbVal (int): Le nombre de nombres aléatoires à générer.\n    Returns:\n        Node: Une liste chaînée qui contient `nbVal` nombre\n              aléatoires entre 0 et 20.\n    \"\"\"\n    if nbVal <= 0:\n        return None\n    return Node(randint(0, 20), genRandom(nbVal - 1))\n\nL = genRandom(10)\nprint(L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(13, 3, 6, 6, 14, 14, 0, 11, 16, 17)\n```\n:::\n:::\n\n\n## 2. `compteInf`\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndef compteInf(L: Node, seuil) -> int:\n    \"\"\"Compter le nombre de valeurs strictement inférieures à `seuil` dans L.\n    Args:\n        L (Node): La liste dans laquelle on compte.\n        seuil: La valeur utilisée pour les comparaisons.\n    Returns:\n        int: Le nombre de valeurs dans `L` qui sont\n             strictement inférieures à `seuil`.\n    \"\"\"\n    res = 0\n    while L is not None:\n        if L.valeur < seuil:\n            res += 1\n        L = L.suivant\n    return res\n\nprint(compteInf(L, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n```\n:::\n:::\n\n\n## 3. `horsIntervalle` récursivement\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndef horsIntervalle(L: Node, a, b) -> Node:\n    \"\"\"Retirer les éléments de L qui sont dans [a, b].\n    Args:\n        L (Node): La liste que l'on veut filtrer.\n        a: La valeur minimale de l'intervalle exclue.\n        b: La valeur maximale de l'intervalle exclue.\n    Returns:\n        Node: Une nouvelle liste qui est L sans les élément\n              de L qui sont compris entre a et b inclus.\n    \"\"\"\n    if a > b or L is None:\n        return None\n    # Si la valeur dépasse en dessous de a ou au dessus de b\n    if L.valeur < a or L.valeur > b :\n        # on garde la valeur dan la nouvelle liste\n        return Node(L.valeur, horsIntervalle(L.suivant, a, b))\n    # sinon on no garde pas la valeur\n    return horsIntervalle(L.suivant, a, b)\n\nprint(horsIntervalle(L, 5, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(13, 3, 14, 14, 0, 11, 16, 17)\n```\n:::\n:::\n\n\n## 4. `horsIntervalleFonc` avec un itérateur fonctionnel\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndef horsIntervalleFonc(L: Node, a, b) -> Node:\n    \"\"\"Retirer les éléments de L qui sont dans [a, b].\n    Args:\n        L (Node): La liste que l'on veut filtrer.\n        a: La valeur minimale de l'intervalle exclue.\n        b: La valeur maximale de l'intervalle exclue.\n    Returns:\n        Node: Une nouvelle liste qui est L sans les élément\n              de L qui sont compris entre a et b inclus.\n    \"\"\"\n    if a > b:\n        raise ValueError(\"a doit être inférieur ou égal à b.\")\n    return Lfilter(L, lambda x: x < a or x > b)\n\nprint(horsIntervalleFonc(L, 5, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(13, 3, 14, 14, 0, 11, 16, 17)\n```\n:::\n:::\n\n\n",
    "supporting": [
      "algo avancee correction controle 1_files"
    ],
    "filters": [],
    "includes": {}
  }
}