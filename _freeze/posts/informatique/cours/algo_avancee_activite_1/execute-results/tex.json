{
  "hash": "c22d41d5da2837e7885550182dd78ca0",
  "result": {
    "markdown": "---\ntitle: Algorithmique avancée - activité 1\ndate: '2023-01-15'\nauthor: Oscar Plaisant\ncategories:\n  - informatique\ntoc: true\n---\n\nCorrection détaillée de l'activité 1 d'algorithmique avancée.\n\n# 1. Nombres aléatoires\n\nOn veut écrire une fonction :\n\n$\\begin{array}{rl} \\texttt{generation :}& (\\texttt{int > 0})^3 \\to \\texttt{list[int > 0]}\\\\ & \\texttt{(nb\\_val, nb\\_min, nb\\_max)} \\mapsto [\\texttt{x} | \\texttt{x}  \\in [\\![\\texttt{nb\\_min}, \\texttt{nb\\_max} ]\\!] ] \\end{array}$\n\nQui génère $\\texttt{nb\\_val}$ nombres aléatoires entiers entre $\\texttt{nb\\_min}$ et $\\texttt{nb\\_max}$\n\n\n### Générer un nombre entier aléatoire\n\nAvec `randon.random`, qui renvoie un réel aléatoire dans $[0; 1[$\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom random import random\nfrom math import floor\n\ndef random_gen_with_random (nb_min: int, nb_max: int) -> int:\n    return floor(random() * (nb_max - nb_min) + nb_min) # floor -> arrondi inferieur (int fait la meme chose)\n\nprint(random_gen_with_random(5, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n```\n:::\n:::\n\n\nAutre version avec la fonction `randint`\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfrom random import randint\n\ndef random_gen (nb_min: int, nb_max: int) -> int:\n    return randint(nb_min, nb_max)\n\n# Note: cette fonction est un peu inutile, car elle est exactement similaire a\n# randint.\n\nprint(random_gen(8, 18))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n16\n```\n:::\n:::\n\n\n### Générer une liste de nombres aléatoires\n\nOn utilise la fonction `random_gen` que l'on a définie plus haut.\n\nPremière version, avec une boucle :\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef generation(nb_val: int, nb_min: int, nb_max: int) -> list[int]:\n    \"\"\"Renvoie une liste de *nb_val* nombres entiers aleatoires entre nb_min, \n    \"\"\"\n    new_list = []\n    for i in range(nb_val):\n        new_list.append(random_gen(nb_min, nb_max))\n    return new_list\n\nprint(generation(10, 5, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 9, 5, 6, 7, 10, 6, 5, 7, 5]\n```\n:::\n:::\n\n\nAutre version, avec une _list comprehension_ :\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef generation_comprehension(nb_val: int, nb_min: int, nb_max: int) -> list[int]:\n    return [random_gen(nb_min, nb_max) for i in range(nb_val)]\n\nprint(generation_comprehension(10, 5, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[9, 9, 9, 9, 6, 7, 6, 9, 5, 7]\n```\n:::\n:::\n\n\n# 2. Vitesse d'exécution\n\nOn veut mesurer (et comparer) le temps d'exécution des fonctions de génération de nombres aléatoires créées précédemment.\n\nOn veut en fait comparer les temps de génération pour des listes contenant entre 10 et 1000 éléments (avec plusieurs valeurs intermédiaires).\n\nPour cela, on utilise la fonction `time.time()`, du module `time`\n\n::: {.callout-tip collapse=true}\n## Fonctionnement de la fonction `time`\n\nLa fonction `time` renvoie le nombre de secondes depuis le début de \"l'époque\" (Epoch en anglais), c'est-à-dire depuis la \"date initiale\" définie par votre système d'exploitation. Sur les systèmes UNIX et leurs dérivés, cette date est généralement fixée au 1$^{\\text{er}}$ janvier 1970.\n\nCe qui est à comprendre, c'est que c'est un nombre qui augmente de 1 chaque seconde (les chiffres après la virgule augmentent continuellement pour avoir une mesure plus précise).\n\nDonc, pour mesurer la durée d'exécution d'une fonction, il suffit de mémoriser dans une variable le résultat de `time` avant l'exécution, puis celui après, et de faire la différence entre ces deux nombres. On obtient ainsi la durée de l'exécution en secondes.\n:::\n\n\n## Temps d'exécution de la première méthode de génération\n\nVoici donc le code :\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nfrom time import time\n\n# liste des nombres d'éléments dans la liste que l'on veut tester\n# on peut aussi utiliser range(10, 10000, 10) par exemple\nLIST_NUMBER_OF_ELEMENTS = [10, 100, 1000, 10000]\n\nfor number_of_elements in LIST_NUMBER_OF_ELEMENTS:\n    # on stocke le moment de début de la génération\n    start = time()\n\n    # on génère des nombres aléatoires\n    foo = generation(number_of_elements, 42, 73)\n\n    # on stocke le moment de fin de la génération\n    end = time()\n\n    # la durée d'exécution est la différence entre le moment de début et de fin\n    # Attention : si on inverse end et start, on obtient un nombre négatif\n    duration = end - start\n\n    # on arrondi la durée, pour que le tout soit plus lisible\n    duration = round(duration, 5)\n\n    # affichage du résultat\n    print(f\"générer {number_of_elements} à mis {duration} secondes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngénérer 10 à mis 1e-05 secondes\ngénérer 100 à mis 4e-05 secondes\ngénérer 1000 à mis 0.0004 secondes\ngénérer 10000 à mis 0.00405 secondes\n```\n:::\n:::\n\n\n## Temps d'exécution avec des _list comprehension_\n\nOn utilise exactement le même code, mais avec la fonction `generation_comprehension` au lieu de `generation` :\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nLIST_NUMBER_OF_ELEMENTS = [10, 100, 1000, 10000]\n\nfor number_of_elements in LIST_NUMBER_OF_ELEMENTS:\n    start = time()\n    foo = generation_comprehension(number_of_elements, 42, 73)\n    end = time()\n\n    duration = end - start\n    duration = round(duration, 5)\n    print(f\"générer {number_of_elements} à mis {duration} secondes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngénérer 10 à mis 2e-05 secondes\ngénérer 100 à mis 4e-05 secondes\ngénérer 1000 à mis 0.0004 secondes\ngénérer 10000 à mis 0.00398 secondes\n```\n:::\n:::\n\n\nOn remarque que le code avec des _list comprehension_ est\neffectivement plus rapide.\n\n## Pour aller plus loin\n\n::: {.callout-warning collapse=true icon=false}\n## Pour aller plus loin\n\nOn peut, par exemple, définir une fonction qui mesure le temps d'exécution d'une autre fonction.\n\nPour cela, il faut que cette nouvelle fonction (appelons-la `temps_execution`), prenne en argument la fonction dont on mesure le temps d'exécution.\n\nOn obtient donc quelque chose comme ça :\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef temps_execution(fonction_a_tester, number_of_elements: int) -> float:\n    # ici, on mesure le temps d'exécution\n    start = time()\n    foo = fonction_a_tester(number_of_elements, 42, 73)\n    end = time()\n    # l'idéal est de retourner le temps d'exécution plutôt\n    # que de mettre un print à l'intérieur d'une fonction\n    # (ce qui est à # éviter en général)\n    return end - start\n\nprint(temps_execution(generation,               1000))\nprint(temps_execution(generation_comprehension, 1000))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.0004031658172607422\n0.0003840923309326172\n```\n:::\n:::\n\n\n:::\n\n\n# 3. Inverser une liste\n\nOn veut écrire une fonction qui inverse l'ordre des éléments d'une liste\n\nOn note que, puisqu'en python, les listes ne sont pas modifiables, on devra nécessairement créer une nouvelle liste.\n\nUne première solution fonctionne\n\n\n### Avec la méthode reverse\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndef reverse_list (liste: list) -> list:\n    # retourne la liste (change le contenu de la variable)\n    liste.reverse()\n    return liste\n\nprint(reverse_list([1, 2, 3, 4, 5]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n### Avec la fonction `reversed`\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndef reverse_list_reversed(liste: list) -> list:\n    # on est obligé de mettre la fonction list pour que le\n    # résultat soit bien une liste (voir le \"pour aller plus\n    # loin\")\n    return list(reversed(liste))\n```\n:::\n\n\n::: {.callout-warning collapse=true icon=false}\n## Pour aller plus loin - Comprendre la méthode reverse\n\nSi on exécute ce code : \n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nl = [1, 2, 3, 5, 8, 13, 21]\nr = reversed(l)\nprint(r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<list_reverseiterator object at 0x1039850c0>\n```\n:::\n:::\n\n\nOn remarque que `r` n'est pas une liste, mais un itérateur.\n\nUn itérateur est un objet que l'on parcourt (tous les\nitérateurs peuvent donc être mis dans une boucle for).\n\nLe concept d'itérateur est très utile lorsque l'on crée\nsoi-même un objet qui doit être parcouru, car python permet\nde créer assez facilement ses propres itérateurs.\n:::\n\n\n### Avec des slice\n\nEn python, on peut indexer des listes de façon assez riche. Cela s'appelle des _slices_ (des parts en anglais, car on prend des \"parts\" de la liste).\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndef reverse_list_slice (liste: list) -> list:\n    # :: car on prends toute la liste\n    # -1 car on a un pas de -1 (donc on recule dans la liste)\n    return liste[::-1]\n\nprint(reverse_list_slice([1, 2, 3, 4, 5]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n### Avec la méthode pop\n\nLa méthode `pop` des listes permet de retirer le dernier\nélément d'une liste. Elle retourne l'élément qu'elle retire,\nce qui permet d'utiliser cet élément dans une autre fonction\n\nSi on répète l'opération de mettre le dernier élément de\nl'ancienne liste à la fin de la nouvelle, retourne bien la\nliste\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndef reverse_list_pop (liste: list) -> list:\n    new_list = []\n    for _ in range(len(liste)):\n        new_list.append(liste.pop())\n    return new_list\n\nprint(reverse_list_pop([1, 2, 3, 4, 5]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n### Avec la méthode insert + Pop\n\nLa méthode `list.insert` permet d'insérer un élément dans\nune liste, avant l'élément à l'indice précisé.\n\nDans ce cas, on insère avant l'indice 0, donc au début de la\nliste. C'est pourquoi on utilise plus `pop()`, mais\n`pop(0)`, qui va retirer le premier élément au lieu du\ndernier.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndef reverse_list_insert (liste: list) -> list:\n    new_list = []\n    for _ in range(len(liste)):\n        new_list.insert(0, liste.pop(0))\n    return new_list\n\nprint(reverse_list_insert([1, 2, 3, 4, 5]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n# 4. Un élément sur `n` dans une liste\n\nOn cherche à écrire une fonction qui, à partir d'une liste,\nsélectionne un élément sur `n` dans cette liste.\n\nPar exemple, si $n=3$, on veut transformer cette liste :\n$[\\underline{3}, 9, 2, \\underline{1}, 7, 8, \\underline{4}, 3, 0, \\underline{1}, 9, 7, \\underline{5}, 3, 1, \\underline{9}]$ en\ncelle-ci : $[3, 1, 4, 1, 5, 9]$\n\n\nVoici la liste de test que nous allons utiliser pour la\nsuite :\n\n\n## Avec une boucle et une nouvelle liste\n\nOn peut utiliser une approche classique : créer la nouvelle\nliste au fur-et-à-mesure, en parcourant la liste de départ.\n\n### Avec une condition sur les indices\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ndef un_sur_n_indices(n: int, liste: list) -> list:\n    \"\"\"Sélectionne un élément sur `n` dans `liste`\"\"\"\n    new_list = []\n    for i in range(len(liste)):\n        # si i est divisible par n (une fois sur n)\n        if 0 == i % n:\n            # on ajoute l'élément à l'indice actuel dans la\n            # nouvelle liste\n            new_list.append(liste[i])\n    return new_list\n\nprint(un_sur_n_indices(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 8, 1]\n```\n:::\n:::\n\n\n### En utilisant un pas sur `range`\n\nUne technique plus simple (et plus efficace) est, plutôt que\nde tester pour tous les indices, d'utiliser un `range` dans\nlequel on met un pas de `n`.\n\nCela permet de n'avoir dans la boucle que les indices qui\nnous intéressent.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ndef un_sur_n_range(n: int, liste: list) -> list:\n    new_list = []\n    # on met un 0 pour que n soit bien le 3ème argument\n    for i in range(0, len(liste), n):\n        new_list.append(liste[i])\n    return new_list\n\nprint(un_sur_n_range(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 8, 1]\n```\n:::\n:::\n\n\n## Avec une _list comprehension_\n\nPour être encore plus efficace, on peut simplement utiliser\nun _list comprehension_, en conjonction avec les techniques\ncitées plus haut.\n\nLe code est en fait équivalent, mais permet de créer la\nliste de façon plus efficace.\n\n### Avec une condition sur les indices\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ndef un_sur_n_comprehension_indices(n: int, liste: list) -> list:\n    return [liste[i] for i in range(len(liste)) if 0 == i%n]\n\nprint(un_sur_n_comprehension_indices(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 8, 1]\n```\n:::\n:::\n\n\n:::{.callout-tip collapse=true}\n## Retours à la ligne pour plus de clarté\n\nPour rendre le code plus clair, on peut mettre un retour à\nla ligne avant le `for` et le `if` :\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\ndef un_sur_n_comprehension_indices(n: int, liste: list) -> list:\n    return [liste[i]\n            for i in range(len(liste))\n            if 0 == i%n]\n```\n:::\n\n\nCela est très utile quand on construit des expressions\ncomplexes, par exemple avec des _list comprehension_ à\nl'intérieur de _list comprehension_.\n:::\n\n### En utilisant un pas sur `range`\n\nOn peut à nouveau utiliser un pas sur le `range` pour ne pas\navoir à tester toutes les itérations.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ndef un_sur_n_comprehension_range(n: int, liste: list) -> list:\n    return [liste[i] for i in range(0, len(liste), n)]\n\nprint(un_sur_n_comprehension_range(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 8, 1]\n```\n:::\n:::\n\n\n# 5. Maximum de nombes dans deux tableaux\n\nOn veut écrire une fonction `maxDes2(tab1, tab2)` qui prend\nen argument deux tableaux de nombres `tab1` et `tab2` de même\nlongueur et retourne un tableau formé des valeurs maximales\nobservées pour chaque indice entre les tableaux tab1 et\ntab2. Par exemple, `maxDes2([1, 4, 5], [2, 2, 3])` retourne\nle tableau `[2, 4, 5]`.\n\n## En parcourant les indices des deux tableaux\n\nL'approche classique est de parcourir les indices `i` des\ndeux tableaux (que l'on suppose de même taille), et de\ncalculer le maximum pour chaque indice, que l'on mettra dans\nune nouvelle liste.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndef max_des_2_indices(tab1: list[int], tab2: list[int]) -> list[int]:\n    new_list: list[int] = []\n    # on parcoure les indices des deux tableaux en même\n    # temps avec i\n    for i in range(len(tab1)):\n        # la fonction max calcul le maximum de ses arguments\n        # ici, les arguments sont les valeurs des deux\n        # tableaux pour un même indice i\n        new_list.append(max(tab1[i], tab2[i]))\n    return new_list\n\nprint(max_des_2_indices([1, 4, 5], [2, 2, 3]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 4, 5]\n```\n:::\n:::\n\n\n## En utilisant la fonction `zip`\n\nLa fonction `zip` va permettre de regrouper les éléments\nexactement comme on le souhaite. En effet, si on essaie de\nl'appliquer :\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nz = zip([3, 1, 4, 1, 5, 9, 2, 6], [2, 7, 1, 8, 2, 8, 1, 8])\nprint(list(z))  # on utilise list pour que le contenu soit bien affiché\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(3, 2), (1, 7), (4, 1), (1, 8), (5, 2), (9, 8), (2, 1), (6, 8)]\n```\n:::\n:::\n\n\nOn observe que le résultat contient les paires d'éléments\ndont on veut faire le maximum : les deux premiers de chaque\ntableau, plus les deux deuxièmes, les deux troisièmes\netc...\n\nOn peut alors proposer la solution suivante :\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\ndef max_des_2_zip(tab1: list[int], tab2: list[int]) -> list[int]:\n    new_list: list[int] = []\n    for couple in zip(tab1, tab2):\n        # on note que la fonction `max` peut s'appliquer sur\n        # une liste d'élément (ici `couple`)\n        new_list.append(max(couple))\n    return new_list\n\nprint(max_des_2_zip([1, 4, 5], [2, 2, 3]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 4, 5]\n```\n:::\n:::\n\n\n## Avec `zip` et `map`\n\nOn remarque dans cet exercice une structure que l'on a déjà\nvue dans les exercices suivants : on veut appliquer une\nfonction particulière sur chaque élément d'une liste, puis\nrécupérer le résultat.\n\nL'approche classique consiste à parcourir la liste, et à\ncréer au fur-et-à-mesure une nouvelle liste.\n\nCependant, une des fonctions de base de python, la fonction\n`map`, permet directement d'appliquer une fonction sur tous\nles éléments d'une liste, et de récupérer le résultat.\n\nOn peut donc tout simplement écrire :\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\ndef max_des_2_map(tab1: list[int], tab2: list[int]) -> list[int]:\n    # on utilise list pour bien récupérer une liste\n    # on applique la fonction max sur le résultat du zip\n    return list(\n        map(max, zip(tab1, tab2))\n    )\n\nprint(max_des_2_map([1, 4, 5], [2, 2, 3]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 4, 5]\n```\n:::\n:::\n\n\nCette approche est une approche _fonctionnelle_ du problème,\npuisque la solution est créée en composant des fonctions\nexistantes (`map`, `max`, `zip`...) et sans structures de\ncontrôles comme des boucles ou des conditions.\n\n\n# 6. Reprogrammer la fonction zip\n\nOn veut écrire une fonction `myzip(tab1, tab2)` qui retourne\nune liste dont chaque élément d’indice `i` est lui-même une\nliste possédant deux valeurs issues des listes `tab1` et\n`tab2` à l’indice `i`. Par exemple, `myzip({1, 4, 5}, {2, 2,\n3})` retourne la liste `{{1, 2}, {4, 2}, {5, 3}}` ; comparer\nvotre solution à la fonction `zip()` de Python.\n\n\n## En parcourant les indices des deux listes\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\ndef myzip_indices(tab1: list[int], tab2: list[int]) -> list[int]:\n    zipped_list: list[int] = []\n    for idx in range(len(tab1)):\n        # on ajoute le couple (tab1[idx], tab2[idx]) à la\n        # liste de résultat. On a bien un couple d'éléments\n        # aux mêmes indices\n        zipped_list.append((tab1[idx], tab2[idx]))\n    return zipped_list\n\nprint(myzip_indices([1, 4, 5], [2, 2, 3]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(1, 2), (4, 2), (5, 3)]\n```\n:::\n:::\n\n\n## Si les deux listes ne font pas la même taille\n\nSi les deux listes ne font pas la même taille, il faut\ns'arrêter quand la première liste est arrivée au bout. On\npeut donc simplement parcourir les indices de `1` à\n`min(len(tab1), len(tab2))`.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\ndef myzip_indices(tab1: list[int], tab2: list[int]) -> list[int]:\n    zipped_list: list[int] = []\n    for idx in range(min(len(tab1), len(tab2))):\n        # on ajoute le couple (tab1[idx], tab2[idx]) à la\n        # liste de résultat. On a bien un couple d'éléments\n        # aux mêmes indices\n        zipped_list.append((tab1[idx], tab2[idx]))\n    return zipped_list\n\nprint(myzip_indices([1, 4, 5], [2, 2, 3, 99, 0]))\nprint(myzip_indices([1, 4, 5, 7, 13, 4], [2, 2, 3, 99]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(1, 2), (4, 2), (5, 3)]\n[(1, 2), (4, 2), (5, 3), (7, 99)]\n```\n:::\n:::\n\n\n# 7. Générer une matrice aléatoire\n\nOn veut écrire une fonction `genMat(row, col, mini, maxi)` qui construit une liste de liste contenant `row` lignes et `col` colonnes et dont les valeurs sont comprises entre `mini` et `maxi`\n\n## Avec des _list comprehension_\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\ndef genMat(row: int, col: int, mini: int, maxi: int) -> list[list[int]]:\n    \"\"\"Initialiser une matrice aléatoire de taille (row, col), avec des valeurs dans [mini, maxi].\n    \"\"\"\n    return [[randint(mini, maxi) for i in range(col)] for j in range(row)]\n\nprint(genMat(3, 3, 0, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0, 0, 8], [1, 3, 10], [8, 8, 10]]\n```\n:::\n:::\n\n\n## En créant la liste au fur-et-à-mesure\n\nLes _list comprehension_ sont plus rapides, plus courtes et beaucoup plus simples à utiliser. Cet exemple est simplement là pour montrer d'autres techniques de programmation.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\ndef genMat(row: int, col: int, mini: int, maxi: int) -> list[list[int]]:\n    \"\"\"Initialiser une matrice aléatoire de taille (row, col), avec des valeurs dans [mini, maxi].\n    \"\"\"\n    mat = []\n    for i in range(row):\n        line = []\n        for j in range(col):\n            line.append(randint(mini, maxi))\n        mat.append(line)\n    return mat\n\n\nprint(genMat(3, 3, 0, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[8, 0, 0], [4, 10, 0], [4, 1, 4]]\n```\n:::\n:::\n\n\n# 8. Diagonale d'une matrice\n\nOn veut écrire une fonction diagonale(mat) qui prend en argument une matrice de réels mat et retourne une liste contenant les éléments de sa diagonale.\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nM = [[1, 6, 1],\n     [8, 0, 3],\n     [9, 8, 8]]\n```\n:::\n\n\n## Avec des _list comprehension_\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\ndef diagonale(mat: list[list[float]]) -> list[float]:\n    \"\"\"Diagonale d'une matrice.\n    Args:\n        mat (list[list[float]]): Une matrice qui doit être carrée\n                                 (sinon la diagonale n'existe pas).\n    Returns:\n        list[float]: La liste des coefficients diagonaux de mat.\n    \"\"\"\n    return [mat[i][i] for i in range(len(mat))]\n\nprint(diagonale(M))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 0, 8]\n```\n:::\n:::\n\n\n## Pour aller plus loin\n\n::: {.callout-warning icon=false collapse=true}\n## Lever une erreur si la matrice n'est pas carrée\n\nPour bien faire, il faudrait lever une erreur si la matrice n'est pas carrée. Pour cela, on utilise le mot clef `raise`, ainsi qu'une erreur classique de python. Ici, on utilisera `ValueError` (on pourrait également créer une classe d'erreurs nous-même, puisque les erreurs sont simplement des objets particuliers).\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\ndef diagonale(mat: list[list[float]]) -> list[float]:\n    \"\"\"Diagonale d'une matrice.\n    Args:\n        mat (list[list[float]]): Une matrice qui doit être carrée\n                                 (sinon la diagonale n'existe pas).\n    Returns:\n        list[float]: La liste des coefficients diagonaux de mat.\n    Raises:\n        ValueError: Si la matrice donnêé en entrée n'est pas carrée.\n    \"\"\"\n    # si la matrice n'est pas carrée\n    if not all(len(mat) == len(ligne) for ligne in mat):\n        # on lève une exception.\n        raise ValueError(\"La matrice n'est pas carrée.\")\n    return [mat[i][i] for i in range(len(mat))]\n\nprint(diagonale(M))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 0, 8]\n```\n:::\n:::\n\n\n:::\n\n\n# 9. Trace d'une matrice\n\nOn veut écrire une fonction `trace(mat)` qui prend en argument une matrice de réels `mat` et retourne la somme de ses éléments diagonaux.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nM = [[0, 1, 1],\n     [2, 3, 5],\n     [8, 1, 3]]\n```\n:::\n\n\n## Avec une _list comprehension_ et la fonction `sum`\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\ndef trace(mat: list[list[float]]) -> float:\n    return sum([mat[i][i] for i in range(len(mat))])\n\nprint(trace(M))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\n```\n:::\n:::\n\n\n## En réutilisant la fonction `diagonale`\n\nComme on a déjà programmé la fonction `diagonale`, on peut l'utiliser, car la trace d'une matrice est la somme de ses coefficients diagonaux.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\ndef trace(mat: list[list[float]]) -> float:\n    return sum(diagonale(mat))\n\nprint(trace(M))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\n```\n:::\n:::\n\n\nCela rend le code moins redondant et plus clair. C'est l'intérêt d'utiliser des fonctions.\n\n# 10. Somme de deux matrices\n\nOn veut écrire une fonction `somme(mat1, mat2)` qui prend en argument deux matrices de réels `mat1` et `mat2`, et retourne la matrice somme de ces deux matrices.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nA = [[0, 1, 0, 1],\n     [1, 0, 1, 0],\n     [0, 1, 0, 1]]\n\nB = [[0, 1, 2, 3],\n     [0, 1, 2, 3],\n     [2, 4, 6, 8]]\n```\n:::\n\n\n## Avec une _list comprehension_\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\ndef somme(mat1: list[list[float]], mat2: list[list[float]]) -> list[list[float]]:\n    \"\"\"Somme de deux matrices que l'on suppose de même taille.\n    \"\"\"\n    # nombre de lignes et de colonnes de mat1 (on la prends comme référence)\n    rows = len(mat1)\n    cols = len(mat1[0])\n    return [[mat1[i][j] + mat2[i][j] for j in range(cols)] for i in range(rows)]\n\nprint(somme(A, B))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0, 2, 2, 4], [1, 1, 3, 3], [2, 5, 6, 9]]\n```\n:::\n:::\n\n\n## Avec des `zip` et des `map`\n\nCette solution est plus complexe, mais elle peut avoir des avantages.\n\nPar exemple, si on retire les fonctions `list` du code, la fonction va retourner un objet `map`, qui est une structure paresseuse (\"_lazy_\"). Cela veut dire qu'un élément donné ne sera calculé que lorsque l'on en aura besoin (lorsque l'on parcourra la matrice, par exemple).\n\nCe mécanisme est utile si, quand une fonction est longue à calculer, vous ne voulez pas être obligé d'attendre que toutes les valeurs soient passées par cette fonction avant de pouvoir passer à l'étape suivante : la fonction ne sera exécutée que sur les valeurs nécessaires, au fur-et-à-mesure.\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\ndef somme(mat1: list[list[float]], mat2: list[list[float]]) -> list[list[float]]:\n    \"\"\"Somme de deux matrices que l'on suppose de même taille.\n    \"\"\"\n    return list(map(lambda x: list(map(sum, zip(*x))), zip(mat1, mat2)))\n\nprint(somme(A, B))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0, 2, 2, 4], [1, 1, 3, 3], [2, 5, 6, 9]]\n```\n:::\n:::\n\n\n# 11. Produit matriciel\n\nOn veut écrire une fonction `produit(mat1, mat2)` qui prend en argument deux matrices de réels `mat1` de dimension $n\\times k$ et `mat2` de dimension $k \\times m$, et retourne la matrice produit de ces deux matrices de dimension $n \\times m$.\n\n::: {.callout-tip collapse=true}\n## Rappel de la formule\n\nSoient $mat_1 \\in \\mathcal{M}_{n,k}(\\mathbb{R})$ et $mat_2 \\in \\mathcal{M}_{k, m}(\\mathbb{R})$ deux matrices.\n\nOn sait que le produit $mat_1 \\times mat_2$ est une matrice de taille $n \\times m$.\n\nAlors :\n\n$\\displaystyle \\forall i \\in [\\![1, n]\\!], \\quad \\forall j \\in [\\![1, m]\\!], \\quad (mat_1 \\times mat_2)_{i, j} = \\sum\\limits_{l=1}^{k} \\Big(  mat_1(i, l) \\times mat_2(l, j) \\Big)$\n:::\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\nA = [[1, 1, 0],\n     [0, 2, 1],\n     [0, 1, 3],\n     [0, 0, 0]]\n\nB = [[1, 5, 2, 5],\n     [1, 1, 3, 1],\n     [7, 6, 2, 6]]\n```\n:::\n\n\n## Avec des _list comprehension_\n\nEn utilisant presque directement la formule de définition du produit de matrices, on obtient cette fonction :\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\ndef produit(mat1: list[list[float]], mat2: list[list[float]]) -> list[list[float]]:\n    \"\"\"Produit matriciel mat1 * mat2.\n    On suppose que les matrices sont de la bonne taille, c'est-à-dire que la largeur de mat1 est égale à la longueur de mat2.\n    \"\"\"\n    # largeur et hauteur de la matrice résultat\n    width = len(mat1)\n    height = len(mat2[0])\n    common_length = len(mat2)\n    # on applique la formule :\n    return [[sum(mat1[j][l] * mat2[l][i] for l in range(common_length)) for i in range(height)] for j in range(width)]\n\nprint(produit(A, B))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[2, 6, 5, 6], [9, 8, 8, 8], [22, 19, 9, 19], [0, 0, 0, 0]]\n```\n:::\n:::\n\n\n## Avec le module `numpy`\n\nLe module `numpy` (qui n'est pas un module standard, il faudra donc l'installer avec `pip3 --install numpy`) possède des fonctions pour l'algèbre linéaire et pour les tableaux en général.\n\nUn objet `matrix` est implémenté, et il permet de faire des multiplications de matrices... Avec l'opérateur `*` ! (Attention : si on utilise l'objet `array` de numpy plutôt que l'objet `matrix`, la multiplication sera une multiplication élément-par-élément plutôt qu'une vraie multiplication matricielle).\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\nimport numpy as np\n\nmA = np.matrix(A)\nmB = np.matrix(B)\n\nprint(mA * mB)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 2  6  5  6]\n [ 9  8  8  8]\n [22 19  9 19]\n [ 0  0  0  0]]\n```\n:::\n:::\n\n\n**Note :** Avec cette méthode, le résultat n'est pas une liste de listes, mais une matrice.\n\n\n\n# 12. Divisibilité par récursion\n\nOn veut écrire une fonction **récursive** `estDivisible(n, m)` qui retourne `True` si et seulement si `m` [divise](../../maths/maths divisibilité.md) `n`, et `false` sinon.\n\nLa fonction ne doit pas utiliser les opérateurs de division, `/`, ou le modulo, `%`.\n\n## Récursion simple\n\nOn va simplement utiliser cette propriété : `n` divise `m` si et seulement si `n` divise `m - n` : $\\forall (m, n) \\in \\mathbb{Z}^{2}, \\quad n \\mid n \\iff n \\mid m-n$\n\nOn utilise aussi le fait que `n` divise `m` si et seulement si la valeur absolue de `n` divise la valeur absolue de `m`.\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\ndef estDivisible(n: int, m: int) -> bool:\n    if m == 0:\n        return True\n    if m < 0:\n        return False\n    return estDivisible(abs(n), abs(m) - abs(n))\n\nprint(estDivisible(3, 6))    # True\nprint(estDivisible(-3, 12))  # True\nprint(estDivisible(-3, 11))  # False\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\nFalse\n```\n:::\n:::\n\n\n# 13. Palindrome par récursion\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\ndef palindrome(tab: list) -> bool:\n    # les listes de longueur 0 ou 1 sont toutes des palindrômes\n    if len(tab) <= 1:\n        return True\n    # si les deux extrémités sont différentes, ce n'est pas un palindrome\n    if tab[0] != tab[-1]:\n        return False\n    # récursion en enlevant les deux extrémités, que l'on a déjà vérifiées\n    return palindrome(tab[1:-1])\n\nprint(estDivisible(3, 6))    # True\nprint(estDivisible(-3, 12))  # True\nprint(estDivisible(-3, 11))  # False\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\nFalse\n```\n:::\n:::\n\n\n# 14. Nombre de chiffres par récursion\n\n\n## Récursion classique\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\ndef longueur(n: int) -> int:\n    n = abs(n)\n    if n < 10:\n        return 1\n    return 1 + longueur(n / 10)\n\nprint(longueur(314159265358))\nprint(longueur(73))\nprint(longueur(1732))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n12\n2\n4\n```\n:::\n:::\n\n\n## Récursion terminale\n\n::: {.callout-tip collapse=true}\n## Détails sur la récursion terminale\n\nLa récursion terminale est un récursion dans laquelle la dernière opération est l'appel récursif. Cela veut dire que le `return` qui contient l'appel récursif ne contient pas d'autre opération.\n\nPar exemple, la définition précédente de `longueur` n'est pas terminale, car on doit ajouter 1 après l'appel récursif (la ligne de l'appel récursif est `return 1 + longueur(n / 10)`).\n\n\nLa récursion terminale à plusieurs avantages :\n\n - dans certains langages, elle est optimisée (l'optimisation de pile d'appel) et rend l'exécution plus rapide et moins coûteuse en mémoire\n - Elle peut être très facilement convertie en une boucle (la variable de boucle est l'accumulateur de la récursion terminale)\n     - Dans certains livres, comme [SICP](https://web.mit.edu/6.001/6.037/sicp.pdf), on voit que la récursion terminale est appelée \"itérative\"\n:::\n\nIci, on a aussi optimisé le programme en travaillant uniquement sur des entiers, ce qui permet d'éviter des calculs de division de flottants, qui sont inutiles.\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\ndef longueur(n: int, acc: int =0) -> int:\n    n = int(abs(n))\n    if n < 10:\n        return acc + 1\n    return longueur(n // 10, acc + 1)\n\nprint(longueur(314159265358))\nprint(longueur(73))\nprint(longueur(1732))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n12\n2\n4\n```\n:::\n:::\n\n\n# 15. Chiffres $<4$ par récursion\n\nOn veut écrire une fonction **récursive** `combienInf4(n)`, qui prend en argument un entier naturel `n`, et retourne le nombre de chiffres qui le compose et qui sont strictement inférieurs à 4.\n\n**Méthode :** On va simplement utiliser les opérateurs `//` et `%`, qui donnent respectivement le quotient et le reste d'une division euclidienne. En prenant en boucle le reste de la division par 10, on obtient chaque chiffre du nombre de départ.\n\n## Récursion classique\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\ndef combienInf4(n: int) -> int:\n    # si le dernier chiffre de n est un 4\n    if n % 10 < 4:\n        # si n est un chiffre\n        if n < 10:\n            # le résultat est 1\n            return 1\n        # on ajoute 1 à la récursion car n finit par 4\n        return 1 + combienInf4(n // 10)\n    # si n ne finit pas par 4 :\n    # si n est un chiffre\n    if n < 10:\n        # aucun 4 dans n\n        return 0\n    # on ajoute rien à la récursion car n ne finit pas par 4\n    return combienInf4(n // 10)\n\nprint(combienInf4(123456))\nprint(combienInf4(314159265358))\nprint(combienInf4(789456))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n5\n0\n```\n:::\n:::\n\n\n## Avec des conversions de types\n\nPour rendre le code plus simple (et plus lisible pour un programmeur averti), on utilise le fait que la fonction `int` puisse convertir des booléens en entiers.\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\ndef combienInf4(n: int) -> int:\n    if n < 10:\n        # (n < 4) est un booléen\n        # int(True) vaut 1, et int(False) vaut 0\n        return int(n < 4)\n    # on ajoute 1 à la récursion si le dernier chiffre de n est 4\n    return int(n % 10 < 4) + combienInf4(n // 10)\n\nprint(combienInf4(123456))\nprint(combienInf4(314159265358))\nprint(combienInf4(789456))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n5\n0\n```\n:::\n:::\n\n\n## Récursion terminale\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\ndef combienInf4(n: int, acc: int =0) -> int:\n    if n < 10:\n        return int(n < 4) + acc\n    return combienInf4(n // 10, acc + int(n % 10 < 4))\n\n\nprint(combienInf4(123456))\nprint(combienInf4(314159265358))\nprint(combienInf4(789456))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n5\n0\n```\n:::\n:::\n\n\n",
    "supporting": [
      "algo_avancee_activite_1_files/figure-pdf"
    ],
    "filters": []
  }
}