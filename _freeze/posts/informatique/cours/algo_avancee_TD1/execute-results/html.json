{
  "hash": "d909330f8283c6f239cac0db1d9b413f",
  "result": {
    "markdown": "---\ntitle: Algorithmique avancée\ndate: '2023-01-08'\ncategories:\n  - maths\ntoc: true\nfreeze: auto\n---\n\nCorrection détaillée du TD1 d'algorithmique avancée.\n\n# 1. Nombres aléatoires\n\nOn veut écrire une fonction :\n\n$\\begin{array}{rl} \\texttt{generation :}& (\\texttt{int > 0})^3 \\to \\texttt{list[int > 0]}\\\\ & \\texttt{(nb\\_val, nb\\_min, nb\\_max)} \\mapsto [\\texttt{x} | \\texttt{x}  \\in [\\![\\texttt{nb\\_min}, \\texttt{nb\\_max} ]\\!] ] \\end{array}$\n\nQui génère $\\texttt{nb\\_val}$ nombres aléatoires entiers entre $\\texttt{nb\\_min}$ et $\\texttt{nb\\_max}$\n\n\n### Générer un nombre entier aléatoire\n\nAvec `randon.random`, qui renvoie un réel aléatoire dans $[0; 1[$\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom random import random\nfrom math import floor\n\ndef random_gen_with_random (nb_min: int, nb_max: int) -> int:\n    return floor(random() * (nb_max - nb_min) + nb_min) # floor -> arrondi inferieur (int fait la meme chose)\n\nprint(random_gen_with_random(5, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n```\n:::\n:::\n\n\nAutre version avec la fonction `randint`\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfrom random import randint\n\ndef random_gen (nb_min: int, nb_max: int) -> int:\n    return randint(nb_min, nb_max)\n\n# Note: cette fonction est un peu inutile, car elle est exactement similaire a\n# randint.\n\nprint(random_gen(8, 18))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n13\n```\n:::\n:::\n\n\n### Générer une liste de nombres aléatoires\n\nOn utilise la fonction `random_gen` que l'on a définie plus haut.\n\nPremière version, avec une boucle :\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef generation(nb_val: int, nb_min: int, nb_max: int) -> list[int]:\n    \"\"\"Renvoie une liste de *nb_val* nombres entiers aleatoires entre nb_min, \n    \"\"\"\n    new_list = []\n    for i in range(nb_val):\n        new_list.append(random_gen(nb_min, nb_max))\n    return new_list\n\nprint(generation(10, 5, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[9, 10, 6, 6, 9, 9, 8, 9, 5, 8]\n```\n:::\n:::\n\n\nAutre version, avec une _list comprehension_ :\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef generation_comprehension(nb_val: int, nb_min: int, nb_max: int) -> list[int]:\n    return [random_gen(nb_min, nb_max) for i in range(nb_val)]\n\nprint(generation_comprehension(10, 5, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[6, 5, 9, 9, 10, 7, 9, 8, 10, 10]\n```\n:::\n:::\n\n\n# 2. Vitesse d'exécution\n\nOn veut mesurer (et comparer) le temps d'exécution des fonctions de génération de nombres aléatoires créées précédemment.\n\nOn veut en fait comparer les temps de génération pour des listes contenant entre 10 et 1000 éléments (avec plusieurs valeurs intermédiaires).\n\nPour cela, on utilise la fonction `time.time()`, du module `time`\n\n::: {.callout-tip collapse=true}\n## Fonctionnement de la fonction `time`\n\nLa fonction `time` renvoie le nombre de secondes depuis le début de \"l'époque\" (Epoch en anglais), c'est-à-dire depuis la \"date initiale\" définie par votre système d'exploitation. Sur les systèmes UNIX et leurs dérivés, cette date est généralement fixée au 1$^{\\text{er}}$ janvier 1970.\n\nCe qui est à comprendre, c'est que c'est un nombre qui augmente de 1 chaque seconde (les chiffres après la virgule augmentent continuellement pour avoir une mesure plus précise).\n\nDonc, pour mesurer la durée d'exécution d'une fonction, il suffit de mémoriser dans une variable le résultat de `time` avant l'exécution, puis celui après, et de faire la différence entre ces deux nombres. On obtient ainsi la durée de l'exécution en secondes.\n:::\n\n\n## Temps d'exécution de la première méthode de génération\n\nVoici donc le code :\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nfrom time import time\n\n# liste des nombres d'éléments dans la liste que l'on veut tester\n# on peut aussi utiliser range(10, 10000, 10) par exemple\nLIST_NUMBER_OF_ELEMENTS = [10, 100, 1000, 10000]\n\nfor number_of_elements in LIST_NUMBER_OF_ELEMENTS:\n    # on stocke le moment de début de la génération\n    start = time()\n\n    # on génère des nombres aléatoires\n    foo = generation(number_of_elements, 42, 73)\n\n    # on stocke le moment de fin de la génération\n    end = time()\n\n    # la durée d'exécution est la différence entre le moment de début et de fin\n    # Attention : si on inverse end et start, on obtient un nombre négatif\n    duration = end - start\n\n    # on arrondi la durée, pour que le tout soit plus lisible\n    duration = round(duration, 5)\n\n    # affichage du résultat\n    print(f\"générer {number_of_elements} à mis {duration} secondes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngénérer 10 à mis 3e-05 secondes\ngénérer 100 à mis 0.00012 secondes\ngénérer 1000 à mis 0.00149 secondes\ngénérer 10000 à mis 0.01207 secondes\n```\n:::\n:::\n\n\n## Temps d'exécution avec des _list comprehension_\n\nOn utilise exactement le même code, mais avec la fonction `generation_comprehension` au lieu de `generation` :\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nLIST_NUMBER_OF_ELEMENTS = [10, 100, 1000, 10000]\n\nfor number_of_elements in LIST_NUMBER_OF_ELEMENTS:\n    start = time()\n    foo = generation_comprehension(number_of_elements, 42, 73)\n    end = time()\n\n    duration = end - start\n    duration = round(duration, 5)\n    print(f\"générer {number_of_elements} à mis {duration} secondes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngénérer 10 à mis 0.00015 secondes\ngénérer 100 à mis 0.00013 secondes\ngénérer 1000 à mis 0.00112 secondes\ngénérer 10000 à mis 0.01252 secondes\n```\n:::\n:::\n\n\nOn remarque que le code avec des _list comprehension_ est\neffectivement plus rapide.\n\n## Pour aller plus loin\n\n::: {.callout-warning collapse=true icon=false}\n## Pour aller plus loin\n\nOn peut, par exemple, définir une fonction qui mesure le temps d'exécution d'une autre fonction.\n\nPour cela, il faut que cette nouvelle fonction (appelons-la `temps_execution`), prenne en argument la fonction dont on mesure le temps d'exécution.\n\nOn obtient donc quelque chose comme ça :\n\n```python\ndef temps_execution(fonction_a_tester):\n    # ici, on mesure le temps d'exécution (code à ajouter)\n    # on peut notamment utiliser la fonction à tester :\n    fonction_a_tester(42, 6, 28)\n    # l'idéal est de retourner le temps d'exécution plutôt\n    # que de mettre un print dans une fonction (ce qui est à\n    # éviter en général)\n    return 73\n\nprint(temps_execution(generation))\n```\n\n:::\n\n\n# 3. Inverser une liste\n\nOn veut écrire une fonction qui inverse l'ordre des éléments d'une liste\n\nOn note que, puisqu'en python, les listes ne sont pas modifiables, on devra nécessairement créer une nouvelle liste.\n\nUne première solution fonctionne\n\n\n### Avec la méthode reverse\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef reverse_list (liste: list) -> list:\n    # retourne la liste (change le contenu de la variable)\n    liste.reverse()\n    return liste\n\nprint(reverse_list([1, 2, 3, 4, 5]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n### Avec la fonction `reversed`\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndef reverse_list_reversed(liste: list) -> list:\n    # on est obligé de mettre la fonction list pour que le\n    # résultat soit bien une liste (voir le \"pour aller plus\n    # loin\")\n    return list(reversed(liste))\n```\n:::\n\n\n::: {.callout-warning collapse=true icon=false}\n## Pour aller plus loin - Comprendre la méthode reverse\n\nSi on exécute ce code : \n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nl = [1, 2, 3, 5, 8, 13, 21]\nr = reversed(l)\nprint(r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<list_reverseiterator object at 0x103fa2aa0>\n```\n:::\n:::\n\n\nOn remarque que `r` n'est pas une liste, mais un itérateur.\n\nUn itérateur est un objet que l'on parcourt (tous les\nitérateurs peuvent donc être mis dans une boucle for).\n\nLe concept d'itérateur est très utile lorsque l'on crée\nsoi-même un objet qui doit être parcouru, car python permet\nde créer assez facilement ses propres itérateurs.\n:::\n\n\n### Avec des slice\n\nEn python, on peut indexer des listes de façon assez riche. Cela s'appelle des _slices_ (des parts en anglais, car on prend des \"parts\" de la liste).\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndef reverse_list_slice (liste: list) -> list:\n    # :: car on prends toute la liste\n    # -1 car on a un pas de -1 (donc on recule dans la liste)\n    return liste[::-1]\n\nprint(reverse_list_slice([1, 2, 3, 4, 5]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n### Avec la méthode pop\n\nLa méthode `pop` des listes permet de retirer le dernier\nélément d'une liste. Elle retourne l'élément qu'elle retire,\nce qui permet d'utiliser cet élément dans une autre fonction\n\nSi on répète l'opération de mettre le dernier élément de\nl'ancienne liste à la fin de la nouvelle, retourne bien la\nliste\n\n![comment se passe l'inversion de la\nliste](../_images/demo_inverser_liste.gif)_\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndef reverse_list_pop (liste: list) -> list:\n    new_list = []\n    for _ in range(len(liste)):\n        new_list.append(liste.pop())\n    return new_list\n\nprint(reverse_list_pop([1, 2, 3, 4, 5]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n### Avec la méthode insert + Pop\n\nLa méthode `list.insert` permet d'insérer un élément dans\nune liste, avant l'élément à l'indice précisé.\n\nDans ce cas, on insère avant l'indice 0, donc au début de la\nliste. C'est pourquoi on utilise plus `pop()`, mais\n`pop(0)`, qui va retirer le premier élément au lieu du\ndernier.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndef reverse_list_insert (liste: list) -> list:\n    new_list = []\n    for _ in range(len(liste)):\n        new_list.insert(0, liste.pop(0))\n    return new_list\n\nprint(reverse_list_insert([1, 2, 3, 4, 5]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n# 4. Un élément sur `n` dans une liste\n\nOn cherche à écrire une fonction qui, à partir d'une liste,\nsélectionne un élément sur `n` dans cette liste.\n\nPar exemple, si $n=3$, on veut transformer cette liste :\n$[\\underline{3}, 9, 2, \\underline{1}, 7, 8, \\underline{4}, 3, 0, \\underline{1}, 9, 7, \\underline{5}, 3, 1, \\underline{9}]$ en\ncelle-ci : $[3, 1, 4, 1, 5, 9]$\n\n\nVoici la liste de test que nous allons utiliser pour la\nsuite :\n\n\n## Avec une boucle et une nouvelle liste\n\nOn peut utiliser une approche classique : créer la nouvelle\nliste au fur-et-à-mesure, en parcourant la liste de départ.\n\n### Avec une condition sur les indices\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndef un_sur_n_indices(n: int, liste: list) -> list:\n    \"\"\"Sélectionne un élément sur `n` dans `liste`\"\"\"\n    new_list = []\n    for i in range(len(liste)):\n        # si i est divisible par n (une fois sur n)\n        if 0 == i % n:\n            # on ajoute l'élément à l'indice actuel dans la\n            # nouvelle liste\n            new_list.append(liste[i])\n    return new_list\n\nprint(un_sur_n_indices(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 8, 1]\n```\n:::\n:::\n\n\n### En utilisant un pas sur `range`\n\nUne technique plus simple (et plus efficace) est, plutôt que\nde tester pour tous les indices, d'utiliser un `range` dans\nlequel on met un pas de `n`.\n\nCela permet de n'avoir dans la boucle que les indices qui\nnous intéressent.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ndef un_sur_n_range(n: int, liste: list) -> list:\n    new_list = []\n    # on met un 0 pour que n soit bien le 3ème argument\n    for i in range(0, len(liste), n):\n        new_list.append(liste[i])\n    return new_list\n\nprint(un_sur_n_range(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 8, 1]\n```\n:::\n:::\n\n\n## Avec une _list comprehension_\n\nPour être encore plus efficace, on peut simplement utiliser\nun _list comprehension_, en conjonction avec les techniques\ncitées plus haut.\n\nLe code est en fait équivalent, mais permet de créer la\nliste de façon plus efficace.\n\n### Avec une condition sur les indices\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ndef un_sur_n_comprehension_indices(n: int, liste: list) -> list:\n    return [liste[i] for i in range(len(liste)) if 0 == i%n]\n\nprint(un_sur_n_comprehension_indices(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 8, 1]\n```\n:::\n:::\n\n\n:::{.callout-tip collapse=true}\n## Retours à la ligne pour plus de clarté\n\nPour rendre le code plus clair, on peut mettre un retour à\nla ligne avant le `for` et le `if` :\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ndef un_sur_n_comprehension_indices(n: int, liste: list) -> list:\n    return [liste[i]\n            for i in range(len(liste))\n            if 0 == i%n]\n```\n:::\n\n\nCela est très utile quand on construit des expressions\ncomplexes, avec par exemple des _list comprehension_ à\nl'intérieur de _list comprehension_.\n:::\n\n### En utilisant un pas sur `range`\n\nOn peut à nouveau utiliser un pas sur le `range` pour ne pas\navoir à tester toutes les itérations.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\ndef un_sur_n_comprehension_range(n: int, liste: list) -> list:\n    return [liste[i] for i in range(0, len(liste), n)]\n\nprint(un_sur_n_comprehension_range(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 8, 1]\n```\n:::\n:::\n\n\n# 5. Maximum de nombes dans deux tableaux\n\nOn veut écrire une fonction `maxDes2(tab1, tab2)` qui prend\nen argument deux tableaux de nombres `tab1` et `tab2` de même\nlongueur et retourne un tableau formé des valeurs maximales\nobservées pour chaque indice entre les tableaux tab1 et\ntab2.  Par exemple, `maxDes2([1, 4, 5], [2, 2, 3])` retourne\nle tableau `[2, 4, 5]`.\n\n## En parcourant les indices des deux tableaux\n\nL'approche classique est de parcourir les incides `i` des\ndeux tableaux (que l'on suppose de même taille), et de\ncalculer le maximum pour chaque indice, que l'on mettra dans\nune nouvelle liste.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ndef max_des_2_indices(tab1: list[int], tab2: list[int]) -> list[int]:\n    new_list: list[int] = []\n    # on parcoure les indices des deux tableaux en même\n    # temps avec i\n    for i in range(len(tab1)):\n        # la fonction max calcul le maximum de ses arguments\n        # ici, les arguments sont les valeurs des deux\n        # tableaux pour un même indice i\n        new_list.append(max(tab1[i], tab2[i]))\n    return new_list\n\nprint(max_des_2_indices([1, 4, 5], [2, 2, 3]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 4, 5]\n```\n:::\n:::\n\n\n## En utilisant la fonction `zip`\n\nLa fonction `zip` va permettre de regroupper les éléments\nexctement comme on le souhaite. En effet, si on essaie de\nl'appliquer :\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nz = zip([3, 1, 4, 1, 5, 9, 2, 6], [2, 7, 1, 8, 2, 8, 1, 8])\nprint(list(z))  # on utilise list pour que le contenu soit bien affiché\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(3, 2), (1, 7), (4, 1), (1, 8), (5, 2), (9, 8), (2, 1), (6, 8)]\n```\n:::\n:::\n\n\nOn observe que le résultat contient les paires d'éléments\ndont on veut faire le maxumum : les deux premiers de chaque\ntableau, plus les deux deuixièmes, les deux troisièmes\netc...\n\nOn peut alors proposer la solution suivante :\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ndef max_des_2_zip(tab1: list[int], tab2: list[int]) -> list[int]:\n    new_list: list[int] = []\n    for couple in zip(tab1, tab2):\n        # on note que la fonction `max` peut s'appliquer sur\n        # une liste d'élément (ici `couple`)\n        new_list.append(max(couple))\n    return new_list\n\nprint(max_des_2_zip([1, 4, 5], [2, 2, 3]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 4, 5]\n```\n:::\n:::\n\n\n## Avec `zip` et `map`\n\nOn remarque dans cet exercice une structure que l'on a déjà\nvue dans les exercices suivants : on veut appliquer une\nfonction particulière sur chaque élément d'une liste, puis\nrécupérer le résultat.\n\nL'approche classique consiste à parcourir la liste, et à\ncréer au fur-et-à-mesure une nouvelle liste.\n\nCependant, une des fonctions de base de python, la fonction\n`map`, permet directement d'appliquer une fonction sur tous\nles éléments d'une liste, et de récupérer le résultat.\n\nOn peut donc tout simplement écrire :\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\ndef max_des_2_map(tab1: list[int], tab2: list[int]) -> list[int]:\n    # on utilise list pour bien récupérer une liste\n    # on applique la fonction max sur le résultat du zip\n    return list(\n        map(max, zip(tab1, tab2))\n    )\n\nprint(max_des_2_map([1, 4, 5], [2, 2, 3]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 4, 5]\n```\n:::\n:::\n\n\nCette approche est une approche _fonctionnelle_ du problème,\npuisque la solution est créée en composant des fonction\nexistantes (`map`, `max`, `zip`...) et sant structures de\ncontrôles comme des boucles ou des conditions.\n\n\n# 6. Reprogrammer la fonction zip\n\nOn veut écrire une fonction `myzip(tab1, tab2)` qui retourne\nune liste dont chaque élément d’indice `i` est lui-même une\nliste possédant deux valeurs issues des listes `tab1` et\n`tab2` à l’indice `i`. Par exemple, `myzip({1, 4, 5}, {2, 2,\n3})` retourne la liste `{{1, 2}, {4, 2}, {5, 3}}` ; comparer\nvotre solution à la fonction `zip()` de Python.\n\n\n## En parcourant les indices des deux listes\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\ndef myzip_indices(tab1: list[int], tab2: list[int]) -> list[int]:\n    zipped_list: list[int] = []\n    for idx in range(len(tab1)):\n        # on ajoute le couple (tab1[idx], tab2[idx]) à la\n        # liste de résultat. On a bien un couple d'éléments\n        # aux mêmes indices\n        zipped_list.append((tab1[idx], tab2[idx]))\n    return zipped_list\n\nprint(myzip_indices([1, 4, 5], [2, 2, 3]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(1, 2), (4, 2), (5, 3)]\n```\n:::\n:::\n\n\n## Si les deux listes ne font pas la même taille\n\nSi les deux listes ne font pas la même taille, il faut\ns'arrêter quand la première liste est arrivée au bout. On\npeut donc simplement parcourir les indices de `1` à\n`min(len(tab1), len(tab2))`.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\ndef myzip_indices(tab1: list[int], tab2: list[int]) -> list[int]:\n    zipped_list: list[int] = []\n    for idx in range(min(len(tab1), len(tab2))):\n        # on ajoute le couple (tab1[idx], tab2[idx]) à la\n        # liste de résultat. On a bien un couple d'éléments\n        # aux mêmes indices\n        zipped_list.append((tab1[idx], tab2[idx]))\n    return zipped_list\n\nprint(myzip_indices([1, 4, 5], [2, 2, 3, 99, 0]))\nprint(myzip_indices([1, 4, 5, 7, 13, 4], [2, 2, 3, 99]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(1, 2), (4, 2), (5, 3)]\n[(1, 2), (4, 2), (5, 3), (7, 99)]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "algo_avancee_TD1_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}