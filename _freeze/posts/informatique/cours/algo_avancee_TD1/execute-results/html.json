{
  "hash": "524de07fc81596dcc6c8c67a9164ada8",
  "result": {
    "markdown": "---\ntitle: Algorithmique avancée\ndate: '2023-01-08'\ncategories:\n  - maths\ntoc: true\nfreeze: auto\nheader-includes: '\\usepackage[left=2cm, right=2cm, top=1cm, bottom=2cm]{geometry}'\n---\n\n# 1. Nombres aléatoires\n\nOn veut écrire une fonction :\n\n$\\begin{array}{rl} \\texttt{generation :}& (\\texttt{int > 0})^3 \\to \\texttt{list[int > 0]}\\\\ & \\texttt{(nb\\_val, nb\\_min, nb\\_max)} \\mapsto [\\texttt{x} | \\texttt{x}  \\in [\\![\\texttt{nb\\_min}, \\texttt{nb\\_max} ]\\!] ] \\end{array}$\n\nQui génère $\\texttt{nb\\_val}$ nombres aléatoires entiers entre $\\texttt{nb\\_min}$ et $\\texttt{nb\\_max}$\n\n\n### Générer un nombre entier aléatoire\n\nAvec `randon.random`, qui renvoie un réel aléatoire dans $[0; 1[$\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom random import random\nfrom math import floor\n\ndef random_gen_with_random (nb_min: int, nb_max: int) -> int:\n    return floor(random() * (nb_max - nb_min) + nb_min) # floor -> arrondi inferieur (int fait la meme chose)\n\nprint(random_gen_with_random(5, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n8\n```\n:::\n:::\n\n\nAutre version avec la fonction `randint`\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfrom random import randint\n\ndef random_gen (nb_min: int, nb_max: int) -> int:\n    return randint(nb_min, nb_max)\n\n# Note: cette fonction est un peu inutile, car elle est exactement similaire a\n# randint.\n\nprint(random_gen(8, 18))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n15\n```\n:::\n:::\n\n\n### Générer une liste de nombres aléatoires\n\nOn utilise la fonction `random_gen` que l'on a définie plus haut.\n\nPremière version, avec une boucle :\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef generation(nb_val: int, nb_min: int, nb_max: int) -> list[int]:\n    \"\"\"Renvoie une liste de *nb_val* nombres entiers aleatoires entre nb_min, \n    \"\"\"\n    new_list = []\n    for i in range(nb_val):\n        new_list.append(random_gen(nb_min, nb_max))\n    return new_list\n\nprint(generation(10, 5, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[7, 7, 10, 7, 5, 9, 7, 8, 5, 9]\n```\n:::\n:::\n\n\nAutre version, avec une _list comprehension_ :\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef generation_comprehension(nb_val: int, nb_min: int, nb_max: int) -> list[int]:\n    return [random_gen(nb_min, nb_max) for i in range(nb_val)]\n\nprint(generation_comprehension(10, 5, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[7, 9, 5, 6, 10, 10, 8, 7, 10, 8]\n```\n:::\n:::\n\n\n# 2. Vitesse d'exécution\n\nOn veut mesurer (et comparer) le temps d'exécution des fonctions de génération de nombres aléatoires créées précédemment.\n\nOn veut en fait comparer les temps de génération pour des listes contenant entre 10 et 1000 éléments (avec plusieurs valeurs intermédiaires).\n\nPour cela, on utilise la fonction `time.time()`, du module `time`\n\n::: {.callout-tip collapse=true}\n## Fonctionnement de la fonction `time`\n\nLa fonction `time` renvoie le nombre de secondes depuis le début de \"l'époque\" (Epoch en anglais), c'est-à-dire depuis la \"date initiale\" définie par votre système d'exploitation. Sur les systèmes UNIX et leurs dérivés, cette date est généralement fixée au 1$^{\\text{er}}$ janvier 1970.\n\nCe qui est à comprendre, c'est que c'est un nombre qui augmente de 1 chaque seconde (les chiffres après la virgule augmentent continuellement pour avoir une mesure plus précise).\n\nDonc, pour mesurer la durée d'exécution d'une fonction, il suffit de mémoriser dans une variable le résultat de `time` avant l'exécution, puis celui après, et de faire la différence entre ces deux nombres. On obtient ainsi la durée de l'exécution en secondes.\n:::\n\n\n## Temps d'exécution de la première méthode de génération\n\nVoici donc le code :\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nfrom time import time\n\n# liste des nombres d'éléments dans la liste que l'on veut tester\n# on peut aussi utiliser range(10, 10000, 10) par exemple\nLIST_NUMBER_OF_ELEMENTS = [10, 100, 1000, 10000]\n\nfor number_of_elements in LIST_NUMBER_OF_ELEMENTS:\n    # on stocke le moment de début de la génération\n    start = time()\n\n    # on génère des nombres aléatoires\n    foo = generation(number_of_elements, 42, 73)\n\n    # on stocke le moment de fin de la génération\n    end = time()\n\n    # la durée d'exécution est la différence entre le moment de début et de fin\n    # Attention : si on inverse end et start, on obtient un nombre négatif\n    duration = end - start\n\n    # on arrondi la durée, pour que le tout soit plus lisible\n    duration = round(duration, 5)\n\n    # affichage du résultat\n    print(f\"générer {number_of_elements} à mis {duration} secondes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngénérer 10 à mis 1e-05 secondes\ngénérer 100 à mis 5e-05 secondes\ngénérer 1000 à mis 0.00042 secondes\ngénérer 10000 à mis 0.00407 secondes\n```\n:::\n:::\n\n\n## Temps d'exécution avec des _list comprehension_\n\nOn utilise exactement le même code, mais avec la fonction `generation_comprehension` au lieu de `generation` :\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nLIST_NUMBER_OF_ELEMENTS = [10, 100, 1000, 10000]\n\nfor number_of_elements in LIST_NUMBER_OF_ELEMENTS:\n    start = time()\n    foo = generation_comprehension(number_of_elements, 42, 73)\n    end = time()\n\n    duration = end - start\n    duration = round(duration, 5)\n    print(f\"générer {number_of_elements} à mis {duration} secondes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngénérer 10 à mis 2e-05 secondes\ngénérer 100 à mis 5e-05 secondes\ngénérer 1000 à mis 0.00042 secondes\ngénérer 10000 à mis 0.00384 secondes\n```\n:::\n:::\n\n\n## Pour aller plus loin\n\n::: {.callout-warning collapse=true icon=false}\n## Pour aller plus loin\n\nOn peut, par exemple, définir une fonction qui mesure le temps d'exécution d'une autre fonction.\n\nPour cela, il faut que cette nouvelle fonction (appelons-la `temps_execution`), prenne en argument la fonction dont on mesure le temps d'exécution.\n\nOn obtient donc quelque chose comme ça :\n\n```python\ndef temps_execution(fonction_a_tester):\n    # ici, on mesure le temps d'exécution (code à ajouter)\n    # on peut notamment utiliser la fonction à tester :\n    fonction_a_tester(42, 6, 28)\n    # l'idéal est de retourner le temps d'exécution plutôt\n    # que de mettre un print dans une fonction (ce qui est à\n    # éviter en général)\n    return 73\n\nprint(temps_execution(generation))\n```\n\n:::\n\n\n# 3. Inverser une liste\n\nOn veut écrire une fonction qui inverse l'ordre des éléments d'une liste\n\nOn note que, puisqu'en python, les listes ne sont pas modifiables, on devra nécessairement créer une nouvelle liste.\n\nUne première solution fonctionne\n\n\n### Avec la méthode reverse\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef reverse_list (liste: list) -> list:\n    # retourne la liste (change le contenu de la variable)\n    liste.reverse()\n    return liste\n\nprint(reverse_list([1, 2, 3, 4, 5]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n### Avec la fonction `reversed`\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndef reverse_list_reversed(liste: list) -> list:\n    # on est obligé de mettre la fonction list pour que le\n    # résultat soit bien une liste (voir le \"pour aller plus\n    # loin\")\n    return list(reversed(liste))\n```\n:::\n\n\n::: {.callout-warning collapse=true icon=false}\n## Pour aller plus loin - Comprendre la méthode reverse\n\nSi on exécute ce code : \n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nl = [1, 2, 3, 5, 8, 13, 21]\nr = reversed(l)\nprint(r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<list_reverseiterator object at 0x107cb46a0>\n```\n:::\n:::\n\n\nOn remarque que `r` n'est pas une liste, mais un itérateur.\n\nUn itérateur est un objet que l'on parcourt (tous les\nitérateurs peuvent donc être mis dans une boucle for).\n\nLe concept d'itérateur est très utile lorsque l'on crée\nsoi-même un objet qui doit être parcouru, car python permet\nde créer assez facilement ses propres itérateurs.\n:::\n\n\n### Avec des slice\n\nEn python, on peut indexer des listes de façon assez riche. Cela s'appelle des _slices_ (des parts en anglais, car on prend des \"parts\" de la liste).\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndef reverse_list_slice (liste: list) -> list:\n    # :: car on prends toute la liste\n    # -1 car on a un pas de -1 (donc on recule dans la liste)\n    return liste[::-1]\n\nprint(reverse_list_slice([1, 2, 3, 4, 5]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n### Avec la méthode pop\n\nLa méthode `pop` des listes permet de retirer le dernier\nélément d'une liste. Elle retourne l'élément qu'elle retire,\nce qui permet d'utiliser cet élément dans une autre fonction\n\nSi on répète l'opération de mettre le dernier élément de\nl'ancienne liste à la fin de la nouvelle, retourne bien la\nliste\n\n![comment se passe l'inversion de la liste](../_images/demo_inverser_liste.gif)\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndef reverse_list_pop (liste: list) -> list:\n    new_list = []\n    for _ in range(len(liste)):\n        new_list.append(liste.pop())\n    return new_list\n\nprint(reverse_list_pop([1, 2, 3, 4, 5]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n### Avec la méthode insert + Pop\n\nLa méthode `list.insert` permet d'insérer un élément dans\nune liste, avant l'élément à l'indice précisé.\n\nDans ce cas, on insère avant l'indice 0, donc au début de la\nliste. C'est pourquoi on utilise plus `pop()`, mais\n`pop(0)`, qui va retirer le premier élément au lieu du\ndernier.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndef reverse_list_insert (liste: list) -> list:\n    new_list = []\n    for _ in range(len(liste)):\n        new_list.insert(0, liste.pop(0))\n    return new_list\n\nprint(reverse_list_insert([1, 2, 3, 4, 5]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n# 4. Un élément sur `n` dans une liste\n\nOn cherche à écrire une fonction qui, à partir d'une liste,\nsélectionne un élément sur `n` dans cette liste.\n\nPar exemple, si $n=3$, on veut transformer cette liste :\n$[\\underline{3}, 9, 2, \\underline{1}, 7, 8, \\underline{4}, 3, 0, \\underline{1}, 9, 7, \\underline{5}, 3, 1, \\underline{9}]$ en\ncelle-ci : $[3, 1, 4, 1, 5, 9]$\n\n\nVoici la liste de test que nous allons utiliser pour la\nsuite :\n\n\n## Avec une boucle et une nouvelle liste\n\nOn peut utiliser une approche classique : créer la nouvelle\nliste au fur-et-à-mesure, en parcourant la liste de départ.\n\n### Avec une condition sur les indices\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndef un_sur_n_indices(n: int, liste: list) -> list:\n    \"\"\"Sélectionne un élément sur `n` dans `liste`\"\"\"\n    new_list = []\n    for i in range(len(liste)):\n        # si i est divisible par n (une fois sur n)\n        if 0 == i % n:\n            # on ajoute l'élément à l'indice actuel dans la\n            # nouvelle liste\n            new_list.append(liste[i])\n    return new_list\n\nprint(un_sur_n_indices(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 8, 1]\n```\n:::\n:::\n\n\n### En utilisant un pas sur `range`\n\nUne technique plus simple (et plus efficace) est, plutôt que\nde tester pour tous les indices, d'utiliser un `range` dans\nlequel on met un pas de `n`.\n\nCela permet de n'avoir dans la boucle que les indices qui\nnous intéressent.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ndef un_sur_n_range(n: int, liste: list) -> list:\n    new_list = []\n    # on met un 0 pour que n soit bien le 3ème argument\n    for i in range(0, len(liste), n):\n        new_list.append(liste[i])\n    return new_list\n\nprint(un_sur_n_range(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 8, 1]\n```\n:::\n:::\n\n\n## Avec une _list comprehension_\n\nPour être encore plus efficace, on peut simplement utiliser\nun _list comprehension_, en conjonction avec les techniques\ncitées plus haut.\n\nLe code est en fait équivalent, mais permet de créer la\nliste de façon plus efficace.\n\n### Avec une condition sur les indices\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ndef un_sur_n_comprehension_indices(n: int, liste: list) -> list:\n    return [liste[i] for i in range(len(liste)) if 0 == i%n]\n\nprint(un_sur_n_comprehension_indices(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 8, 1]\n```\n:::\n:::\n\n\n:::{.callout-tip collapse=true}\n## Retours à la ligne pour plus de clarté\n\nPour rendre le code plus clair, on peut mettre un retour à\nla ligne avant le `for` et le `if` :\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ndef un_sur_n_comprehension_indices(n: int, liste: list) -> list:\n    return [liste[i]\n            for i in range(len(liste))\n            if 0 == i%n]\n```\n:::\n\n\nCela est très utile quand on construit des expressions\ncomplexes, avec par exemple des _list comprehension_ à\nl'intérieur de _list comprehension_.\n:::\n\n### En utilisant un pas sur `range`\n\nOn peut à nouveau utiliser un pas sur le `range` pour ne pas\navoir à tester toutes les itérations.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\ndef un_sur_n_comprehension_range(n: int, liste: list) -> list:\n    return [liste[i] for i in range(0, len(liste), n)]\n\nprint(un_sur_n_comprehension_range(3, [2, 7, 1, 8, 2, 8, 1, 8]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 8, 1]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "algo_avancee_TD1_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}